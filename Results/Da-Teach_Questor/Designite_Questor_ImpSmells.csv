Implementation smell,Namespace,Class,File,Method,Description
Long Method,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The method has 109 lines of code.
Long Method,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The method has 391 lines of code.
Long Method,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The method has 166 lines of code.
Long Method,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The method has 152 lines of code.
Long Method,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The method has 1650 lines of code.
Complex Method,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,Cyclomatic complexity of the method is 33
Complex Method,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,Cyclomatic complexity of the method is 21
Complex Method,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,Cyclomatic complexity of the method is 21
Complex Method,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,Cyclomatic complexity of the method is 563
Complex Method,Mono.Options,StringCoda,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,CreateWrappedLinesIterator,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,AddSeparators,Cyclomatic complexity of the method is 17
Complex Method,Mono.Options,ArgumentSource,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParseBundledValue,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,GetDescription,Cyclomatic complexity of the method is 20
Complex Method,Questor.Storylines,GenericCombatStoryline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\GenericCombatStoryline.cs,ExecuteMission,Cyclomatic complexity of the method is 34
Complex Method,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,Cyclomatic complexity of the method is 9
Complex Method,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,ProcessState,Cyclomatic complexity of the method is 45
Complex Method,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,ExecuteMission,Cyclomatic complexity of the method is 15
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,GetOptionParts,The method has 5 parameters.
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteDescription,The method has 5 parameters.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,SetQuestorStatetoCloseQuestor,The length of the statement  "		Logging.Log ("SetQuestorStatetoCloseQuestor - Changes the QuestorState to CloseQuestor which will GotoBase and then Exit"); " is 123.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The length of the statement  "		text = "Questor [" + _questor.CharacterName + "][" + String.Format ("{0:0'0}"' Cache.Instance.Wealth / 1000000) + "mil isk]"; " is 125.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The length of the statement  "			var newlblCurrentMissionInfotext = "[ " + Cache.Instance.MissionName + " ][ " + Math.Round (DateTime.Now.Subtract (Statistics.Instance.StartedMission).TotalMinutes' 0) + " min][ #" + Statistics.Instance.MissionsThisSession + " ]"; " is 230.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The length of the statement  "			var newlblCurrentMissionInfotext = "[ " + Cache.Instance.MissionName + " ][ " + Math.Round (DateTime.Now.Subtract (Statistics.Instance.StartedMission).TotalMinutes' 0) + " min][ #" + Statistics.Instance.MissionsThisSession + " ]"; " is 230.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The length of the statement  "	if (DateTime.Now.Subtract (_questor._lastFrame).TotalSeconds > 90 && DateTime.Now.Subtract (Program.AppStarted).TotalSeconds > 300) { " is 133.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The length of the statement  "	if (Cache.Instance.MaxRuntime > 0 && Cache.Instance.MaxRuntime != Int32.MaxValue)//if runtime is specified' overrides stop time " is 127.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The length of the statement  "	this.QuestorStateComboBox.SelectedIndexChanged += new System.EventHandler (this.QuestorStateComboBox_SelectedIndexChanged); " is 123.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The length of the statement  "	this.QuestorStateComboBox.MouseWheel += new System.Windows.Forms.MouseEventHandler (this.QuestorStateComboBox_MouseWheel); " is 122.
Long Statement,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The length of the statement  "	this.txtExtConsole.Font = new System.Drawing.Font ("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 164.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The length of the statement  "			Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime); " is 199.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The length of the statement  "			} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now " is 125.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The length of the statement  "				Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go."); " is 124.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The length of the statement  "				Logging.Log ("Questor: Content of telecom window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]"); " is 137.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The length of the statement  "					Logging.Log ("Startup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]"); " is 135.
Long Statement,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The length of the statement  "					Logging.Log ("Questor: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]"); " is 135.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.ValidateSettings_seconds)//default is a 15 second interval " is 123.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	// Description: Closes Windows' and eventually other things considered 'cleanup' useful to more than just Questor(Missions) but also Anomalies' Mining' etc " is 155.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	if (DateTime.Now.Subtract (_lastupdateofSessionRunningTime).TotalSeconds < (int)Time.SessionRunningTimeUpdate_seconds) { " is 120.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) { " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB"); " is 121.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally " is 179.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n"); " is 207.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			//Logging.Log("[Questor] Wallet Balance Debug Info: lastknowngoodconnectedtime = " + Settings.Instance.lastKnownGoodConnectedTime); " is 131.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			//Logging.Log("[Questor] Wallet Balance Debug Info: DateTime.Now - lastknowngoodconnectedtime = " + DateTime.Now.Subtract(Settings.Instance.lastKnownGoodConnectedTime).TotalSeconds); " is 182.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log (String.Format ("Questor: Wallet Balance Has Not Changed in [ {0} ] minutes."' Math.Round (DateTime.Now.Subtract (Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes' 0))); " is 188.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			if (Math.Round (DateTime.Now.Subtract (Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes) < Settings.Instance.walletbalancechangelogoffdelay) { " is 149.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log (String.Format ("Questor: Wallet Balance Has Not Changed in [ {0} ] minutes. Switching to QuestorState.CloseQuestor"' Math.Round (DateTime.Now.Subtract (Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes' 0))); " is 227.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Cache.Instance.ReasonToStopQuestor = "Wallet Balance did not change for over " + Settings.Instance.walletbalancechangelogoffdelay + "min"; " is 138.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					Logging.Log ("Questor: walletbalancechangelogoffdelayLogofforExit is set to: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit); " is 143.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					Logging.Log ("Questor: walletbalancechangelogoffdelayLogofforExit is set to: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit); " is 143.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		_panic.InMission |= _storyline.StorylineHandler is GenericCombatStoryline && (_storyline.StorylineHandler as GenericCombatStoryline).State == GenericCombatStorylineState.ExecuteMission; " is 185.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay; " is 135.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging."); " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission " is 143.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) { " is 139.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again"); " is 149.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault (); " is 221.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault(); " is 170.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter")); " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault (); " is 146.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any) " is 120.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp " is 214.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it"); " is 182.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId)); " is 191.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second " is 139.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) { " is 135.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) { " is 148.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB"); " is 121.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") { " is 169.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB"); " is 182.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB"; " is 196.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault (); " is 163.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 132.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId)); " is 191.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once " is 141.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60)); " is 146.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60)); " is 148.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60)); " is 180.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated); " is 185.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n"); " is 207.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up"); " is 143.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file"); " is 167.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) { " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one"); " is 181.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session " is 143.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "								Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session"); " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session " is 137.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "								Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set"); " is 124.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) { " is 134.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) { " is 196.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging " is 134.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) { " is 271.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) { " is 231.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago "); " is 172.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. "); " is 290.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago "); " is 172.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "						Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. "); " is 281.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault (); " is 133.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) { " is 129.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe); " is 146.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) { " is 167.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]"); " is 134.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching"); " is 188.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets); " is 141.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	//    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id)) " is 157.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	//        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching"); " is 198.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "	//        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets); " is 148.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]"); " is 146.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]"); " is 124.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet); " is 120.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit); " is 124.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit); " is 124.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) { " is 151.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away"); " is 133.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching"); " is 192.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets); " is 141.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) { " is 168.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe); " is 146.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "		if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) { " is 151.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "					Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]"); " is 134.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching"); " is 201.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets); " is 141.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "				Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]"); " is 137.
Long Statement,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The length of the statement  "			//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb) " is 133.
Long Statement,Mono.Options,StringCoda,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,GetNextWidth,The length of the statement  "			throw new ArgumentOutOfRangeException ("widths"' string.Format ("Element must be >= {0}' was {1}."' minWidth.Length' curWidth)); " is 128.
Long Statement,Mono.Options,OptionValueCollection,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,AssertValid,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Missing required value for option '{0}'.")' c.OptionName)' c.OptionName); " is 146.
Long Statement,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Parse,The length of the statement  "	bool nullable = tt.IsValueType && tt.IsGenericType && !tt.IsGenericTypeDefinition && tt.GetGenericTypeDefinition () == typeof(Nullable<>); " is 138.
Long Statement,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Parse,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Could not convert string `{0}' to type {1} for option `{2}'.")' value' targetType.Name' c.OptionName)' c.OptionName' e); " is 193.
Long Statement,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParsePrototype,The length of the statement  "			throw new ArgumentException (string.Format ("Conflicting option types: '{0}' vs. '{1}'."' type' name [end])' "prototype"); " is 122.
Long Statement,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParsePrototype,The length of the statement  "		throw new ArgumentException (string.Format ("Cannot provide key/value separators for Options taking {0} value(s)."' count)' "prototype"); " is 137.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParseValue,The length of the statement  "		foreach (string o in c.Option.ValueSeparators != null ? option.Split (c.Option.ValueSeparators' c.Option.MaxValueCount - c.OptionValues.Count' StringSplitOptions.None) : new string[] { " is 184.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParseValue,The length of the statement  "		throw new OptionException (localizer (string.Format ("Error: Found {0} option values when expecting {1}."' c.OptionValues.Count' c.Option.MaxValueCount))' c.OptionName); " is 169.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParseBool,The length of the statement  "	if (n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))) { " is 127.
Long Statement,Questor.Storylines,GenericCombatStoryline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\GenericCombatStoryline.cs,ExecuteMission,The length of the statement  "		var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault (); " is 221.
Long Statement,Questor.Storylines,GenericCombatStoryline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\GenericCombatStoryline.cs,ExecuteMission,The length of the statement  "			_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (storyline.AgentId' "Encounter")); " is 124.
Long Statement,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The length of the statement  "		Logging.Log (String.Format ("MaterialsForWarPreparation: We have [{0}] {1}' accepting mission"' hangar.Items.Where (i => i.TypeId == oreid).Sum (i => i.Quantity).ToString ()' hangar.Items.Where (i => i.TypeId == oreid).FirstOrDefault ().TypeName)); " is 248.
Long Statement,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The length of the statement  "		Logging.Log ("MaterialsForWarPreparation: Not enough (reasonably priced) ore available! Blacklisting agent for this Questor session!"); " is 135.
Long Statement,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,GotoAgent,The length of the statement  "		_traveler.Destination = new StationDestination (agent.SolarSystemId' agent.StationId' Cache.Instance.DirectEve.GetLocationName (agent.StationId)); " is 146.
Long Statement,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The length of the statement  "		Logging.Log ("TransactionDataDelivery: Moving [" + item.TypeName + "][" + item.ItemId + "] to " + (pickup ? "cargo" : "hangar")); " is 129.
Complex Conditional,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The conditional expression  "Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)"  is complex.
Complex Conditional,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The conditional expression  "_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)"  is complex.
Complex Conditional,Mono.Options,Option,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 && ((names.Length == 1 && this.type != OptionValueType.None) || (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))"  is complex.
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,SetAutoStart,The following statement contains a magic number: if (args.Length != 2 || !bool.TryParse (args [1]' out value)) {  	Logging.Log ("SetAutoStart true|false");  	return -1;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,SetDisable3D,The following statement contains a magic number: if (args.Length != 2 || !bool.TryParse (args [1]' out value)) {  	Logging.Log ("SetDisable3D true|false");  	return -1;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,SetExitWhenIdle,The following statement contains a magic number: if (args.Length != 2 || !bool.TryParse (args [1]' out value)) {  	Logging.Log ("SetExitWhenIdle true|false");  	Logging.Log ("Note: AutoStart is automatically turned off when ExitWhenIdle is turned on");  	return -1;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (_questor.CharacterName != string.Empty && Cache.Instance.Wealth > 10000000) {  	text = "Questor [" + _questor.CharacterName + "][" + String.Format ("{0:0'0}"' Cache.Instance.Wealth / 1000000) + "mil isk]";  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (_questor.CharacterName != string.Empty && Cache.Instance.Wealth > 10000000) {  	text = "Questor [" + _questor.CharacterName + "][" + String.Format ("{0:0'0}"' Cache.Instance.Wealth / 1000000) + "mil isk]";  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: text = "Questor [" + _questor.CharacterName + "][" + String.Format ("{0:0'0}"' Cache.Instance.Wealth / 1000000) + "mil isk]";  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (DateTime.Now.Subtract (_questor._lastFrame).TotalSeconds > 90 && DateTime.Now.Subtract (Program.AppStarted).TotalSeconds > 300) {  	if (DateTime.Now.Subtract (_lastlogmessage).TotalSeconds > 60) {  		Logging.Log ("The Last UI Frame Drawn by EVE was more than 90 seconds ago! This is bad.");  		//  		// closing eve would be a very good idea here  		//  		_lastlogmessage = DateTime.Now;  	}  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (DateTime.Now.Subtract (_questor._lastFrame).TotalSeconds > 90 && DateTime.Now.Subtract (Program.AppStarted).TotalSeconds > 300) {  	if (DateTime.Now.Subtract (_lastlogmessage).TotalSeconds > 60) {  		Logging.Log ("The Last UI Frame Drawn by EVE was more than 90 seconds ago! This is bad.");  		//  		// closing eve would be a very good idea here  		//  		_lastlogmessage = DateTime.Now;  	}  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (DateTime.Now.Subtract (_questor._lastFrame).TotalSeconds > 90 && DateTime.Now.Subtract (Program.AppStarted).TotalSeconds > 300) {  	if (DateTime.Now.Subtract (_lastlogmessage).TotalSeconds > 60) {  		Logging.Log ("The Last UI Frame Drawn by EVE was more than 90 seconds ago! This is bad.");  		//  		// closing eve would be a very good idea here  		//  		_lastlogmessage = DateTime.Now;  	}  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastlogmessage).TotalSeconds > 60) {  	Logging.Log ("The Last UI Frame Drawn by EVE was more than 90 seconds ago! This is bad.");  	//  	// closing eve would be a very good idea here  	//  	_lastlogmessage = DateTime.Now;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (Cache.Instance.MaxRuntime > 0 && Cache.Instance.MaxRuntime != Int32.MaxValue)//if runtime is specified' overrides stop time   {  	if (DateTime.Now.Subtract (Program.startTime).TotalSeconds > 120) {  		if (Cache.Instance.MaxRuntime.ToString () != textBoxMaxRunTime.Text) {  			textBoxMaxRunTime.Text = Cache.Instance.MaxRuntime.ToString ();  		}  	}  } else {  	textBoxMaxRunTime.Text = string.Empty;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (DateTime.Now.Subtract (Program.startTime).TotalSeconds > 120) {  	if (Cache.Instance.MaxRuntime.ToString () != textBoxMaxRunTime.Text) {  		textBoxMaxRunTime.Text = Cache.Instance.MaxRuntime.ToString ();  	}  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,tUpdateUI_Tick,The following statement contains a magic number: if (dateTimePickerStopTime.Value > Cache.Instance.StartTime.AddMinutes (5)) {  	Cache.Instance.StopTimeSpecified = true;  	Cache.Instance.StopTime = dateTimePickerStopTime.Value;  } else {  	Cache.Instance.StopTimeSpecified = false;  	dateTimePickerStopTime.Value = Cache.Instance.StartTime;  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,txtComand_KeyPress,The following statement contains a magic number: if (e.KeyChar == (char)13) {  	LavishScript.ExecuteCommand (txtComand.Text);  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: if (chkShowDetails.Checked) {  	this.Size = new System.Drawing.Size (901' 406);  } else {  	this.Size = new System.Drawing.Size (362' 124);  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: if (chkShowDetails.Checked) {  	this.Size = new System.Drawing.Size (901' 406);  } else {  	this.Size = new System.Drawing.Size (362' 124);  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: if (chkShowDetails.Checked) {  	this.Size = new System.Drawing.Size (901' 406);  } else {  	this.Size = new System.Drawing.Size (362' 124);  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: if (chkShowDetails.Checked) {  	this.Size = new System.Drawing.Size (901' 406);  } else {  	this.Size = new System.Drawing.Size (362' 124);  }  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: this.Size = new System.Drawing.Size (901' 406);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: this.Size = new System.Drawing.Size (901' 406);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: this.Size = new System.Drawing.Size (362' 124);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,chkShowConsole_CheckedChanged,The following statement contains a magic number: this.Size = new System.Drawing.Size (362' 124);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.AutoStartCheckBox.Location = new System.Drawing.Point (215' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.AutoStartCheckBox.Location = new System.Drawing.Point (215' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.AutoStartCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.AutoStartCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.AutoStartCheckBox.TabIndex = 2;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tUpdateUI.Interval = 50;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.DamageTypeComboBox.Location = new System.Drawing.Point (79' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.DamageTypeComboBox.Location = new System.Drawing.Point (79' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.DamageTypeComboBox.Size = new System.Drawing.Size (130' 21);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.DamageTypeComboBox.Size = new System.Drawing.Size (130' 21);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.DamageTypeComboBox.TabIndex = 4;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDamageType.Location = new System.Drawing.Point (1' 34);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDamageType.Size = new System.Drawing.Size (77' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDamageType.Size = new System.Drawing.Size (77' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblDamageType.TabIndex = 90;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblQuestorState.Location = new System.Drawing.Point (3' 9);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblQuestorState.Location = new System.Drawing.Point (3' 9);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblQuestorState.Size = new System.Drawing.Size (75' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblQuestorState.Size = new System.Drawing.Size (75' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.QuestorStateComboBox.Location = new System.Drawing.Point (79' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.QuestorStateComboBox.Location = new System.Drawing.Point (79' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.QuestorStateComboBox.Size = new System.Drawing.Size (130' 21);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.QuestorStateComboBox.Size = new System.Drawing.Size (130' 21);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.StartButton.Location = new System.Drawing.Point (285' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.StartButton.Location = new System.Drawing.Point (285' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.StartButton.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.StartButton.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.StartButton.TabIndex = 3;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.PauseCheckBox.Location = new System.Drawing.Point (285' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.PauseCheckBox.Location = new System.Drawing.Point (285' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.PauseCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.PauseCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.PauseCheckBox.TabIndex = 6;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Disable3DCheckBox.Location = new System.Drawing.Point (215' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Disable3DCheckBox.Location = new System.Drawing.Point (215' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Disable3DCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Disable3DCheckBox.Size = new System.Drawing.Size (68' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Disable3DCheckBox.TabIndex = 5;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkShowDetails.Location = new System.Drawing.Point (270' 68);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkShowDetails.Location = new System.Drawing.Point (270' 68);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkShowDetails.Size = new System.Drawing.Size (83' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkShowDetails.Size = new System.Drawing.Size (83' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.chkShowDetails.TabIndex = 7;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMissionName.Location = new System.Drawing.Point (2' 55);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMissionName.Location = new System.Drawing.Point (2' 55);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMissionName.Size = new System.Drawing.Size (76' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMissionName.Size = new System.Drawing.Size (76' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMissionName.TabIndex = 92;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.Location = new System.Drawing.Point (76' 55);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.Location = new System.Drawing.Point (76' 55);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.MaximumSize = new System.Drawing.Size (250' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.MaximumSize = new System.Drawing.Size (250' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.MinimumSize = new System.Drawing.Size (275' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.MinimumSize = new System.Drawing.Size (275' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.Size = new System.Drawing.Size (275' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.Size = new System.Drawing.Size (275' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentMissionInfo.TabIndex = 93;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPocketAction.Location = new System.Drawing.Point (1' 73);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPocketAction.Size = new System.Drawing.Size (77' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPocketAction.Size = new System.Drawing.Size (77' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPocketAction.TabIndex = 94;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.Location = new System.Drawing.Point (76' 73);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.Location = new System.Drawing.Point (76' 73);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.MaximumSize = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.MaximumSize = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.MinimumSize = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.MinimumSize = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.Size = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.Size = new System.Drawing.Size (180' 15);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblCurrentPocketAction.TabIndex = 95;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestormanager.Location = new System.Drawing.Point (371' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestormanager.Location = new System.Drawing.Point (371' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestormanager.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestormanager.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestormanager.TabIndex = 107;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestorStatistics.Location = new System.Drawing.Point (486' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestorStatistics.Location = new System.Drawing.Point (486' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestorStatistics.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestorStatistics.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonQuestorStatistics.TabIndex = 108;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonSettingsXML.Location = new System.Drawing.Point (601' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonSettingsXML.Location = new System.Drawing.Point (601' 4);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonSettingsXML.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonSettingsXML.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonSettingsXML.TabIndex = 110;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenMissionXML.Location = new System.Drawing.Point (486' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenMissionXML.Location = new System.Drawing.Point (486' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenMissionXML.Size = new System.Drawing.Size (224' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenMissionXML.Size = new System.Drawing.Size (224' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenMissionXML.TabIndex = 118;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenLogDirectory.Location = new System.Drawing.Point (371' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenLogDirectory.Location = new System.Drawing.Point (371' 30);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenLogDirectory.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenLogDirectory.Size = new System.Drawing.Size (109' 23);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenLogDirectory.TabIndex = 109;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.Location = new System.Drawing.Point (4' 22);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.Location = new System.Drawing.Point (4' 22);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.Size = new System.Drawing.Size (769' 276);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.Size = new System.Drawing.Size (769' 276);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.LiveScheduling.TabIndex = 2;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTime1.Location = new System.Drawing.Point (302' 109);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTime1.Location = new System.Drawing.Point (302' 109);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTime1.Size = new System.Drawing.Size (52' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTime1.Size = new System.Drawing.Size (52' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStartTime1.TabIndex = 107;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRunTime1.Location = new System.Drawing.Point (288' 155);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRunTime1.Location = new System.Drawing.Point (288' 155);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRunTime1.Size = new System.Drawing.Size (66' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRunTime1.Size = new System.Drawing.Size (66' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRunTime1.TabIndex = 108;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStartTime.Location = new System.Drawing.Point (360' 105);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStartTime.Location = new System.Drawing.Point (360' 105);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStartTime.Size = new System.Drawing.Size (121' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStartTime.Size = new System.Drawing.Size (121' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStartTime.TabIndex = 109;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMaxRunTime.Location = new System.Drawing.Point (360' 152);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMaxRunTime.Location = new System.Drawing.Point (360' 152);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMaxRunTime.Size = new System.Drawing.Size (46' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMaxRunTime.Size = new System.Drawing.Size (46' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMaxRunTime.TabIndex = 110;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRuntime2.Location = new System.Drawing.Point (412' 155);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRuntime2.Location = new System.Drawing.Point (412' 155);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRuntime2.Size = new System.Drawing.Size (69' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRuntime2.Size = new System.Drawing.Size (69' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblMaxRuntime2.TabIndex = 111;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStopTime.Location = new System.Drawing.Point (302' 133);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStopTime.Location = new System.Drawing.Point (302' 133);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStopTime.Size = new System.Drawing.Size (52' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStopTime.Size = new System.Drawing.Size (52' 13);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.lblStopTime.TabIndex = 112;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStopTime.Location = new System.Drawing.Point (360' 129);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStopTime.Location = new System.Drawing.Point (360' 129);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStopTime.Size = new System.Drawing.Size (121' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStopTime.Size = new System.Drawing.Size (121' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.dateTimePickerStopTime.TabIndex = 113;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Console.Location = new System.Drawing.Point (4' 22);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Console.Location = new System.Drawing.Point (4' 22);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Console.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Console.Size = new System.Drawing.Size (769' 276);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.Console.Size = new System.Drawing.Size (769' 276);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtExtConsole.Location = new System.Drawing.Point (0' 3);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtExtConsole.Size = new System.Drawing.Size (773' 234);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtExtConsole.Size = new System.Drawing.Size (773' 234);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtExtConsole.TabIndex = 25;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtComand.Location = new System.Drawing.Point (3' 243);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtComand.Location = new System.Drawing.Point (3' 243);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtComand.Size = new System.Drawing.Size (760' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtComand.Size = new System.Drawing.Size (760' 20);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.txtComand.TabIndex = 26;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tabInterface1.Location = new System.Drawing.Point (4' 101);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tabInterface1.Location = new System.Drawing.Point (4' 101);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tabInterface1.Size = new System.Drawing.Size (777' 302);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tabInterface1.Size = new System.Drawing.Size (777' 302);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.tabInterface1.TabIndex = 117;  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (356' 96);  
Magic Number,Questor,frmMain,F:\newReposMay17\Da-Teach_Questor\Questor\frmMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (356' 96);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_chantlingScheduler && !string.IsNullOrEmpty (_character)) {  	var path = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location);  	_character = _character.Replace ("\""' "");  	// strip quotation marks if any are present  	CharSchedules = new List<CharSchedule> ();  	var values = XDocument.Load (Path.Combine (path' "Schedules.xml"));  	foreach (var value in values.Root.Elements ("char"))  		CharSchedules.Add (new CharSchedule (value));  	var _schedule = CharSchedules.FirstOrDefault (v => v.Name == _character);  	if (_schedule == null) {  		Logging.Log ("[Startup] Error - character not found!");  		return;  	} else {  		Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  		if (_schedule.User == null || _schedule.PW == null) {  			Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  			return;  		} else {  			_username = _schedule.User;  			_password = _schedule.PW;  		}  		_startTime = _schedule.Start;  		if (_schedule.startTimeSpecified)  			_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  		_scheduledstartTime = _schedule.Start;  		_scheduledstopTime = _schedule.Stop;  		_stopTime = _schedule.Stop;  		//if ((DateTime.Now > _scheduledstopTime))  		//{  		//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  		//	_readyToStarta = false;  		//}  		if ((DateTime.Now > _startTime)) {  			if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  			 {  				_startTime = DateTime.Now;  				_readyToStarta = true;  			} else  				_startTime = _startTime.AddDays (1);  			//otherwise' start tomorrow at start time  		} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		}  		if (_stopTime < _startTime)  			_stopTime = _stopTime.AddDays (1);  		if (_schedule.RunTime > 0)  			//if runtime is specified' overrides stop time  			_stopTime = _startTime.AddHours (_schedule.RunTime);  		string _stopTimeText = "No stop time specified";  		stopTimeSpecified = _schedule.stopTimeSpecified;  		if (stopTimeSpecified)  			_stopTimeText = _stopTime.ToString ();  		Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  		if (!_readyToStarta) {  			minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  			Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  			_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  			if (minutesToStart > 0)  				_timer.Interval = (int)(minutesToStart * 60000);  			else  				_timer.Interval = 1000;  			_timer.Enabled = true;  			_timer.Start ();  		} else {  			_readyToStart = true;  			Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  			System.Threading.Thread.Sleep (15000);  		}  	}  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule == null) {  	Logging.Log ("[Startup] Error - character not found!");  	return;  } else {  	Logging.Log ("[Startup] User: " + _schedule.User + " PW: " + _schedule.PW + " Name: " + _schedule.Name + " Start: " + _schedule.Start + " Stop: " + _schedule.Stop + " RunTime: " + _schedule.RunTime);  	if (_schedule.User == null || _schedule.PW == null) {  		Logging.Log ("[Startup] Error - Login details not specified in Schedules.xml!");  		return;  	} else {  		_username = _schedule.User;  		_password = _schedule.PW;  	}  	_startTime = _schedule.Start;  	if (_schedule.startTimeSpecified)  		_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  	_scheduledstartTime = _schedule.Start;  	_scheduledstopTime = _schedule.Stop;  	_stopTime = _schedule.Stop;  	//if ((DateTime.Now > _scheduledstopTime))  	//{  	//	_startTime = _startTime.AddDays(1); //otherwise' start tomorrow at start time  	//	_readyToStarta = false;  	//}  	if ((DateTime.Now > _startTime)) {  		if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  		 {  			_startTime = DateTime.Now;  			_readyToStarta = true;  		} else  			_startTime = _startTime.AddDays (1);  		//otherwise' start tomorrow at start time  	} else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	}  	if (_stopTime < _startTime)  		_stopTime = _stopTime.AddDays (1);  	if (_schedule.RunTime > 0)  		//if runtime is specified' overrides stop time  		_stopTime = _startTime.AddHours (_schedule.RunTime);  	string _stopTimeText = "No stop time specified";  	stopTimeSpecified = _schedule.stopTimeSpecified;  	if (stopTimeSpecified)  		_stopTimeText = _stopTime.ToString ();  	Logging.Log ("[Startup] Start Time: " + _startTime + " - Stop Time: " + _stopTimeText);  	if (!_readyToStarta) {  		minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  		Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  		_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  		if (minutesToStart > 0)  			_timer.Interval = (int)(minutesToStart * 60000);  		else  			_timer.Interval = 1000;  		_timer.Enabled = true;  		_timer.Start ();  	} else {  		_readyToStart = true;  		Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  		System.Threading.Thread.Sleep (15000);  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (_schedule.startTimeSpecified)  	_startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: _startTime = _startTime.AddSeconds ((double)(_r.Next (0' (_randStartDelay * 60))));  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if ((DateTime.Now > _startTime)) {  	if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	} else  		_startTime = _startTime.AddDays (1);  	//otherwise' start tomorrow at start time  } else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now   {  	_startTime = DateTime.Now;  	_readyToStarta = true;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if ((DateTime.Now > _startTime)) {  	if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now  	 {  		_startTime = DateTime.Now;  		_readyToStarta = true;  	} else  		_startTime = _startTime.AddDays (1);  	//otherwise' start tomorrow at start time  } else if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now   {  	_startTime = DateTime.Now;  	_readyToStarta = true;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if ((DateTime.Now.Subtract (_startTime).TotalMinutes < 1200))//if we're less than x hours past start time' start now   {  	_startTime = DateTime.Now;  	_readyToStarta = true;  } else  	_startTime = _startTime.AddDays (1);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if ((_startTime.Subtract (DateTime.Now).TotalMinutes > 1200))//if we're more than x hours shy of start time' start now   {  	_startTime = DateTime.Now;  	_readyToStarta = true;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (!_readyToStarta) {  	minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  	Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  	_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  	if (minutesToStart > 0)  		_timer.Interval = (int)(minutesToStart * 60000);  	else  		_timer.Interval = 1000;  	_timer.Enabled = true;  	_timer.Start ();  } else {  	_readyToStart = true;  	Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  	System.Threading.Thread.Sleep (15000);  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (!_readyToStarta) {  	minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  	Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  	_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  	if (minutesToStart > 0)  		_timer.Interval = (int)(minutesToStart * 60000);  	else  		_timer.Interval = 1000;  	_timer.Enabled = true;  	_timer.Start ();  } else {  	_readyToStart = true;  	Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  	System.Threading.Thread.Sleep (15000);  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (!_readyToStarta) {  	minutesToStart = _startTime.Subtract (DateTime.Now).TotalMinutes;  	Logging.Log ("[Startup] Starting at " + _startTime + ". " + String.Format ("{0:0.##}"' minutesToStart) + " minutes to go.");  	_timer.Elapsed += new ElapsedEventHandler (TimerEventProcessor);  	if (minutesToStart > 0)  		_timer.Interval = (int)(minutesToStart * 60000);  	else  		_timer.Interval = 1000;  	_timer.Enabled = true;  	_timer.Start ();  } else {  	_readyToStart = true;  	Logging.Log ("[Startup] Already passed start time.  Starting in 15 seconds.");  	System.Threading.Thread.Sleep (15000);  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (minutesToStart > 0)  	_timer.Interval = (int)(minutesToStart * 60000);  else  	_timer.Interval = 1000;  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (minutesToStart > 0)  	_timer.Interval = (int)(minutesToStart * 60000);  else  	_timer.Interval = 1000;  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: _timer.Interval = (int)(minutesToStart * 60000);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: _timer.Interval = 1000;  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep (15000);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: while (!_done) {  	System.Threading.Thread.Sleep (50);  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep (50);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: if (!string.IsNullOrEmpty (_username) && !string.IsNullOrEmpty (_password) && !string.IsNullOrEmpty (_character)) {  	_readyToStart = true;  	_directEve = new DirectEve ();  	_directEve.OnFrame += OnFrame;  	var started = DateTime.Now;  	// Sleep until we're done  	while (!_done) {  		System.Threading.Thread.Sleep (50);  	}  	_directEve.Dispose ();  	// If the last parameter is false' then we only auto-login  	if (_loginOnly)  		return;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: while (!_done) {  	System.Threading.Thread.Sleep (50);  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep (50);  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (_directEve.Windows.Count != 0) {  	foreach (var window in _directEve.Windows) {  		if (string.IsNullOrEmpty (window.Html))  			continue;  		Logging.Log ("[Startup] windowtitles:" + window.Name + "::" + window.Html);  		//  		// Close these windows and continue  		//  		if (window.Name == "telecom") {  			Logging.Log ("Questor: Closing telecom message...");  			Logging.Log ("Questor: Content of telecom window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  			window.Close ();  			continue;  		}  		// Modal windows must be closed  		// But lets only close known modal windows  		if (window.Name == "modal") {  			bool close = false;  			bool restart = false;  			if (!string.IsNullOrEmpty (window.Html)) {  				// Server going down  				//Logging.Log("[Startup] (1) close is: " + close);  				close |= window.Html.Contains ("Please make sure your characters are out of harms way");  				close |= window.Html.Contains ("The socket was closed");  				close |= window.Html.Contains ("accepting connections");  				close |= window.Html.Contains ("Could not connect");  				close |= window.Html.Contains ("The connection to the server was closed");  				close |= window.Html.Contains ("server was closed");  				close |= window.Html.Contains ("Unable to connect to the selected server. Please check the address and try again.");  				close |= window.Html.Contains ("make sure your characters are out of harm");  				close |= window.Html.Contains ("Connection to server lost");  				close |= window.Html.Contains ("The socket was closed");  				close |= window.Html.Contains ("The specified proxy or server node");  				close |= window.Html.Contains ("Starting up");  				close |= window.Html.Contains ("Unable to connect to the selected server");  				close |= window.Html.Contains ("Could not connect to the specified address");  				close |= window.Html.Contains ("Connection Timeout");  				close |= window.Html.Contains ("The cluster is not currently accepting connections");  				close |= window.Html.Contains ("Your character is located within");  				close |= window.Html.Contains ("The transport has not yet been connected");  				close |= window.Html.Contains ("The user's connection has been usurped");  				close |= window.Html.Contains ("The EVE cluster has reached its maximum user limit");  				close |= window.Html.Contains ("The connection to the server was closed");  				close |= window.Html.Contains ("client is already connecting to the server");  				//close |= window.Html.Contains("A client update is available and will now be installed");  				//  				// eventually it would be nice to hit ok on this one and let it update  				//  				close |= window.Html.Contains ("client update is available and will now be installed");  				close |= window.Html.Contains ("You are on a <b>14 day trial</b>.");  				//  				// these windows require a quit of eve all together  				//  				restart |= window.Html.Contains ("The connection was closed");  				restart |= window.Html.Contains ("Connection to server lost.");  				//INFORMATION  				restart |= window.Html.Contains ("Connection to server lost");  				//INFORMATION  				restart |= window.Html.Contains ("Local cache is corrupt");  				restart |= window.Html.Contains ("Local session information is corrupt");  				restart |= window.Html.Contains ("The client's local session");  				// information is corrupt");  				restart |= window.Html.Contains ("restart the client prior to logging in");  				//Logging.Log("[Startup] (2) close is: " + close);  				//Logging.Log("[Startup] (1) window.Html is: " + window.Html);  				_pulsedelay = 60;  			}  			if (restart) {  				Logging.Log ("Startup: Restarting eve...");  				Logging.Log ("Startup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  				_directEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				continue;  			}  			if (close) {  				Logging.Log ("Questor: Closing modal window...");  				Logging.Log ("Questor: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  				window.Close ();  				continue;  			}  		}  		if (string.IsNullOrEmpty (window.Html))  			continue;  		if (window.Name == "telecom")  			continue;  		Logging.Log ("[Startup] We've got an unexpected window' auto login halted.");  		Logging.Log ("[Startup] window.Name is: " + window.Name);  		Logging.Log ("[Startup] window.Caption is: " + window.Caption);  		Logging.Log ("[Startup] window.ID is: " + window.Id);  		Logging.Log ("[Startup] window.Html is: " + window.Html);  		_done = true;  		return;  	}  	return;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: foreach (var window in _directEve.Windows) {  	if (string.IsNullOrEmpty (window.Html))  		continue;  	Logging.Log ("[Startup] windowtitles:" + window.Name + "::" + window.Html);  	//  	// Close these windows and continue  	//  	if (window.Name == "telecom") {  		Logging.Log ("Questor: Closing telecom message...");  		Logging.Log ("Questor: Content of telecom window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  		window.Close ();  		continue;  	}  	// Modal windows must be closed  	// But lets only close known modal windows  	if (window.Name == "modal") {  		bool close = false;  		bool restart = false;  		if (!string.IsNullOrEmpty (window.Html)) {  			// Server going down  			//Logging.Log("[Startup] (1) close is: " + close);  			close |= window.Html.Contains ("Please make sure your characters are out of harms way");  			close |= window.Html.Contains ("The socket was closed");  			close |= window.Html.Contains ("accepting connections");  			close |= window.Html.Contains ("Could not connect");  			close |= window.Html.Contains ("The connection to the server was closed");  			close |= window.Html.Contains ("server was closed");  			close |= window.Html.Contains ("Unable to connect to the selected server. Please check the address and try again.");  			close |= window.Html.Contains ("make sure your characters are out of harm");  			close |= window.Html.Contains ("Connection to server lost");  			close |= window.Html.Contains ("The socket was closed");  			close |= window.Html.Contains ("The specified proxy or server node");  			close |= window.Html.Contains ("Starting up");  			close |= window.Html.Contains ("Unable to connect to the selected server");  			close |= window.Html.Contains ("Could not connect to the specified address");  			close |= window.Html.Contains ("Connection Timeout");  			close |= window.Html.Contains ("The cluster is not currently accepting connections");  			close |= window.Html.Contains ("Your character is located within");  			close |= window.Html.Contains ("The transport has not yet been connected");  			close |= window.Html.Contains ("The user's connection has been usurped");  			close |= window.Html.Contains ("The EVE cluster has reached its maximum user limit");  			close |= window.Html.Contains ("The connection to the server was closed");  			close |= window.Html.Contains ("client is already connecting to the server");  			//close |= window.Html.Contains("A client update is available and will now be installed");  			//  			// eventually it would be nice to hit ok on this one and let it update  			//  			close |= window.Html.Contains ("client update is available and will now be installed");  			close |= window.Html.Contains ("You are on a <b>14 day trial</b>.");  			//  			// these windows require a quit of eve all together  			//  			restart |= window.Html.Contains ("The connection was closed");  			restart |= window.Html.Contains ("Connection to server lost.");  			//INFORMATION  			restart |= window.Html.Contains ("Connection to server lost");  			//INFORMATION  			restart |= window.Html.Contains ("Local cache is corrupt");  			restart |= window.Html.Contains ("Local session information is corrupt");  			restart |= window.Html.Contains ("The client's local session");  			// information is corrupt");  			restart |= window.Html.Contains ("restart the client prior to logging in");  			//Logging.Log("[Startup] (2) close is: " + close);  			//Logging.Log("[Startup] (1) window.Html is: " + window.Html);  			_pulsedelay = 60;  		}  		if (restart) {  			Logging.Log ("Startup: Restarting eve...");  			Logging.Log ("Startup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  			_directEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			continue;  		}  		if (close) {  			Logging.Log ("Questor: Closing modal window...");  			Logging.Log ("Questor: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  			window.Close ();  			continue;  		}  	}  	if (string.IsNullOrEmpty (window.Html))  		continue;  	if (window.Name == "telecom")  		continue;  	Logging.Log ("[Startup] We've got an unexpected window' auto login halted.");  	Logging.Log ("[Startup] window.Name is: " + window.Name);  	Logging.Log ("[Startup] window.Caption is: " + window.Caption);  	Logging.Log ("[Startup] window.ID is: " + window.Id);  	Logging.Log ("[Startup] window.Html is: " + window.Html);  	_done = true;  	return;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (window.Name == "modal") {  	bool close = false;  	bool restart = false;  	if (!string.IsNullOrEmpty (window.Html)) {  		// Server going down  		//Logging.Log("[Startup] (1) close is: " + close);  		close |= window.Html.Contains ("Please make sure your characters are out of harms way");  		close |= window.Html.Contains ("The socket was closed");  		close |= window.Html.Contains ("accepting connections");  		close |= window.Html.Contains ("Could not connect");  		close |= window.Html.Contains ("The connection to the server was closed");  		close |= window.Html.Contains ("server was closed");  		close |= window.Html.Contains ("Unable to connect to the selected server. Please check the address and try again.");  		close |= window.Html.Contains ("make sure your characters are out of harm");  		close |= window.Html.Contains ("Connection to server lost");  		close |= window.Html.Contains ("The socket was closed");  		close |= window.Html.Contains ("The specified proxy or server node");  		close |= window.Html.Contains ("Starting up");  		close |= window.Html.Contains ("Unable to connect to the selected server");  		close |= window.Html.Contains ("Could not connect to the specified address");  		close |= window.Html.Contains ("Connection Timeout");  		close |= window.Html.Contains ("The cluster is not currently accepting connections");  		close |= window.Html.Contains ("Your character is located within");  		close |= window.Html.Contains ("The transport has not yet been connected");  		close |= window.Html.Contains ("The user's connection has been usurped");  		close |= window.Html.Contains ("The EVE cluster has reached its maximum user limit");  		close |= window.Html.Contains ("The connection to the server was closed");  		close |= window.Html.Contains ("client is already connecting to the server");  		//close |= window.Html.Contains("A client update is available and will now be installed");  		//  		// eventually it would be nice to hit ok on this one and let it update  		//  		close |= window.Html.Contains ("client update is available and will now be installed");  		close |= window.Html.Contains ("You are on a <b>14 day trial</b>.");  		//  		// these windows require a quit of eve all together  		//  		restart |= window.Html.Contains ("The connection was closed");  		restart |= window.Html.Contains ("Connection to server lost.");  		//INFORMATION  		restart |= window.Html.Contains ("Connection to server lost");  		//INFORMATION  		restart |= window.Html.Contains ("Local cache is corrupt");  		restart |= window.Html.Contains ("Local session information is corrupt");  		restart |= window.Html.Contains ("The client's local session");  		// information is corrupt");  		restart |= window.Html.Contains ("restart the client prior to logging in");  		//Logging.Log("[Startup] (2) close is: " + close);  		//Logging.Log("[Startup] (1) window.Html is: " + window.Html);  		_pulsedelay = 60;  	}  	if (restart) {  		Logging.Log ("Startup: Restarting eve...");  		Logging.Log ("Startup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  		_directEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		continue;  	}  	if (close) {  		Logging.Log ("Questor: Closing modal window...");  		Logging.Log ("Questor: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace ("\n"' "").Replace ("\r"' "") + "]");  		window.Close ();  		continue;  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (!string.IsNullOrEmpty (window.Html)) {  	// Server going down  	//Logging.Log("[Startup] (1) close is: " + close);  	close |= window.Html.Contains ("Please make sure your characters are out of harms way");  	close |= window.Html.Contains ("The socket was closed");  	close |= window.Html.Contains ("accepting connections");  	close |= window.Html.Contains ("Could not connect");  	close |= window.Html.Contains ("The connection to the server was closed");  	close |= window.Html.Contains ("server was closed");  	close |= window.Html.Contains ("Unable to connect to the selected server. Please check the address and try again.");  	close |= window.Html.Contains ("make sure your characters are out of harm");  	close |= window.Html.Contains ("Connection to server lost");  	close |= window.Html.Contains ("The socket was closed");  	close |= window.Html.Contains ("The specified proxy or server node");  	close |= window.Html.Contains ("Starting up");  	close |= window.Html.Contains ("Unable to connect to the selected server");  	close |= window.Html.Contains ("Could not connect to the specified address");  	close |= window.Html.Contains ("Connection Timeout");  	close |= window.Html.Contains ("The cluster is not currently accepting connections");  	close |= window.Html.Contains ("Your character is located within");  	close |= window.Html.Contains ("The transport has not yet been connected");  	close |= window.Html.Contains ("The user's connection has been usurped");  	close |= window.Html.Contains ("The EVE cluster has reached its maximum user limit");  	close |= window.Html.Contains ("The connection to the server was closed");  	close |= window.Html.Contains ("client is already connecting to the server");  	//close |= window.Html.Contains("A client update is available and will now be installed");  	//  	// eventually it would be nice to hit ok on this one and let it update  	//  	close |= window.Html.Contains ("client update is available and will now be installed");  	close |= window.Html.Contains ("You are on a <b>14 day trial</b>.");  	//  	// these windows require a quit of eve all together  	//  	restart |= window.Html.Contains ("The connection was closed");  	restart |= window.Html.Contains ("Connection to server lost.");  	//INFORMATION  	restart |= window.Html.Contains ("Connection to server lost");  	//INFORMATION  	restart |= window.Html.Contains ("Local cache is corrupt");  	restart |= window.Html.Contains ("Local session information is corrupt");  	restart |= window.Html.Contains ("The client's local session");  	// information is corrupt");  	restart |= window.Html.Contains ("restart the client prior to logging in");  	//Logging.Log("[Startup] (2) close is: " + close);  	//Logging.Log("[Startup] (1) window.Html is: " + window.Html);  	_pulsedelay = 60;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: _pulsedelay = 60;  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (_directEve.Login.AtLogin) {  	if (DateTime.Now.Subtract (AppStarted).TotalSeconds > 60) {  		Logging.Log ("[Startup] Login account [" + _username + "]");  		_directEve.Login.Login (_username' _password);  		Logging.Log ("[Startup] Waiting for Character Selection Screen");  		_pulsedelay = (int)Time.QuestorBeforeLoginPulseDelay_milliseconds;  		return;  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (AppStarted).TotalSeconds > 60) {  	Logging.Log ("[Startup] Login account [" + _username + "]");  	_directEve.Login.Login (_username' _password);  	Logging.Log ("[Startup] Waiting for Character Selection Screen");  	_pulsedelay = (int)Time.QuestorBeforeLoginPulseDelay_milliseconds;  	return;  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (_directEve.Login.AtCharacterSelection && _directEve.Login.IsCharacterSelectionReady) {  	if (DateTime.Now.Subtract (AppStarted).TotalSeconds > 90) {  		foreach (var slot in _directEve.Login.CharacterSlots) {  			if (slot.CharId.ToString () != _character && string.Compare (slot.CharName' _character' true) != 0)  				continue;  			Logging.Log ("[Startup] Activating character [" + slot.CharName + "]");  			slot.Activate ();  			return;  		}  		Logging.Log ("[Startup] Character id/name [" + _character + "] not found' retrying in 10 seconds");  	}  }  
Magic Number,Questor,Program,F:\newReposMay17\Da-Teach_Questor\Questor\Program.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (AppStarted).TotalSeconds > 90) {  	foreach (var slot in _directEve.Login.CharacterSlots) {  		if (slot.CharId.ToString () != _character && string.Compare (slot.CharName' _character' true) != 0)  			continue;  		Logging.Log ("[Startup] Activating character [" + slot.CharName + "]");  		slot.Activate ();  		return;  	}  	Logging.Log ("[Startup] Character id/name [" + _character + "] not found' retrying in 10 seconds");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,ValidateSettings,The following statement contains a magic number: if (Settings.Instance.Ammo.Select (a => a.DamageType).Distinct ().Count () != 4) {  	if (!Settings.Instance.Ammo.Any (a => a.DamageType == DamageType.EM))  		Logging.Log ("Settings: Missing EM damage type!");  	if (!Settings.Instance.Ammo.Any (a => a.DamageType == DamageType.Thermal))  		Logging.Log ("Settings: Missing Thermal damage type!");  	if (!Settings.Instance.Ammo.Any (a => a.DamageType == DamageType.Kinetic))  		Logging.Log ("Settings: Missing Kinetic damage type!");  	if (!Settings.Instance.Ammo.Any (a => a.DamageType == DamageType.Explosive))  		Logging.Log ("Settings: Missing Explosive damage type!");  	Logging.Log ("Settings: You are required to specify all 4 damage types in your settings xml file!");  	ValidSettings = false;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastDockedorJumping).TotalSeconds < 6)  	return;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) {  	if (Cache.Instance.QuestorJustStarted) {  		Cache.Instance.QuestorJustStarted = false;  		Cache.Instance.SessionState = "Starting Up";  		// get the current process  		Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  		// get the physical mem usage  		Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.SessionIskGenerated = 0;  		Cache.Instance.SessionLootGenerated = 0;  		Cache.Instance.SessionLPGenerated = 0;  		if (Settings.Instance.SessionsLog) {  			if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  			 {  				//  				// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  				//  				// Get the path  				if (!Directory.Exists (Settings.Instance.SessionsLogPath))  					Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  				// Write the header  				if (!File.Exists (Settings.Instance.SessionsLogFile))  					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  				// Build the line  				var line = DateTime.Now + ";";  				//Date  				line += "0" + ";";  				//RunningTime  				line += Cache.Instance.SessionState + ";";  				//SessionState  				line += "" + ";";  				//LastMission  				line += Cache.Instance.DirectEve.Me.Wealth + ";";  				//WalletBalance  				line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  				//MemoryUsage  				line += "Starting" + ";";  				//Reason  				line += ";";  				//IskGenerated  				line += ";";  				//LootGenerated  				line += ";";  				//LPGenerated  				line += ";";  				//Isk/Hr  				line += ";";  				//Loot/Hr  				line += ";";  				//LP/HR  				line += ";\r\n";  				//Total/HR  				// The mission is finished  				File.AppendAllText (Settings.Instance.SessionsLogFile' line);  				Cache.Instance.SessionState = "";  				Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) {  	if (Cache.Instance.QuestorJustStarted) {  		Cache.Instance.QuestorJustStarted = false;  		Cache.Instance.SessionState = "Starting Up";  		// get the current process  		Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  		// get the physical mem usage  		Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.SessionIskGenerated = 0;  		Cache.Instance.SessionLootGenerated = 0;  		Cache.Instance.SessionLPGenerated = 0;  		if (Settings.Instance.SessionsLog) {  			if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  			 {  				//  				// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  				//  				// Get the path  				if (!Directory.Exists (Settings.Instance.SessionsLogPath))  					Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  				// Write the header  				if (!File.Exists (Settings.Instance.SessionsLogFile))  					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  				// Build the line  				var line = DateTime.Now + ";";  				//Date  				line += "0" + ";";  				//RunningTime  				line += Cache.Instance.SessionState + ";";  				//SessionState  				line += "" + ";";  				//LastMission  				line += Cache.Instance.DirectEve.Me.Wealth + ";";  				//WalletBalance  				line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  				//MemoryUsage  				line += "Starting" + ";";  				//Reason  				line += ";";  				//IskGenerated  				line += ";";  				//LootGenerated  				line += ";";  				//LPGenerated  				line += ";";  				//Isk/Hr  				line += ";";  				//Loot/Hr  				line += ";";  				//LP/HR  				line += ";\r\n";  				//Total/HR  				// The mission is finished  				File.AppendAllText (Settings.Instance.SessionsLogFile' line);  				Cache.Instance.SessionState = "";  				Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) {  	if (Cache.Instance.QuestorJustStarted) {  		Cache.Instance.QuestorJustStarted = false;  		Cache.Instance.SessionState = "Starting Up";  		// get the current process  		Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  		// get the physical mem usage  		Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.SessionIskGenerated = 0;  		Cache.Instance.SessionLootGenerated = 0;  		Cache.Instance.SessionLPGenerated = 0;  		if (Settings.Instance.SessionsLog) {  			if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  			 {  				//  				// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  				//  				// Get the path  				if (!Directory.Exists (Settings.Instance.SessionsLogPath))  					Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  				// Write the header  				if (!File.Exists (Settings.Instance.SessionsLogFile))  					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  				// Build the line  				var line = DateTime.Now + ";";  				//Date  				line += "0" + ";";  				//RunningTime  				line += Cache.Instance.SessionState + ";";  				//SessionState  				line += "" + ";";  				//LastMission  				line += Cache.Instance.DirectEve.Me.Wealth + ";";  				//WalletBalance  				line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  				//MemoryUsage  				line += "Starting" + ";";  				//Reason  				line += ";";  				//IskGenerated  				line += ";";  				//LootGenerated  				line += ";";  				//LPGenerated  				line += ";";  				//Isk/Hr  				line += ";";  				//Loot/Hr  				line += ";";  				//LP/HR  				line += ";\r\n";  				//Total/HR  				// The mission is finished  				File.AppendAllText (Settings.Instance.SessionsLogFile' line);  				Cache.Instance.SessionState = "";  				Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) {  	if (Cache.Instance.QuestorJustStarted) {  		Cache.Instance.QuestorJustStarted = false;  		Cache.Instance.SessionState = "Starting Up";  		// get the current process  		Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  		// get the physical mem usage  		Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.SessionIskGenerated = 0;  		Cache.Instance.SessionLootGenerated = 0;  		Cache.Instance.SessionLPGenerated = 0;  		if (Settings.Instance.SessionsLog) {  			if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  			 {  				//  				// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  				//  				// Get the path  				if (!Directory.Exists (Settings.Instance.SessionsLogPath))  					Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  				// Write the header  				if (!File.Exists (Settings.Instance.SessionsLogFile))  					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  				// Build the line  				var line = DateTime.Now + ";";  				//Date  				line += "0" + ";";  				//RunningTime  				line += Cache.Instance.SessionState + ";";  				//SessionState  				line += "" + ";";  				//LastMission  				line += Cache.Instance.DirectEve.Me.Wealth + ";";  				//WalletBalance  				line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  				//MemoryUsage  				line += "Starting" + ";";  				//Reason  				line += ";";  				//IskGenerated  				line += ";";  				//LootGenerated  				line += ";";  				//LPGenerated  				line += ";";  				//Isk/Hr  				line += ";";  				//Loot/Hr  				line += ";";  				//LP/HR  				line += ";\r\n";  				//Total/HR  				// The mission is finished  				File.AppendAllText (Settings.Instance.SessionsLogFile' line);  				Cache.Instance.SessionState = "";  				Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_questorStarted).TotalSeconds > 10) && (DateTime.Now.Subtract (_questorStarted).TotalSeconds < 60)) {  	if (Cache.Instance.QuestorJustStarted) {  		Cache.Instance.QuestorJustStarted = false;  		Cache.Instance.SessionState = "Starting Up";  		// get the current process  		Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  		// get the physical mem usage  		Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  		Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.SessionIskGenerated = 0;  		Cache.Instance.SessionLootGenerated = 0;  		Cache.Instance.SessionLPGenerated = 0;  		if (Settings.Instance.SessionsLog) {  			if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  			 {  				//  				// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  				//  				// Get the path  				if (!Directory.Exists (Settings.Instance.SessionsLogPath))  					Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  				// Write the header  				if (!File.Exists (Settings.Instance.SessionsLogFile))  					File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  				// Build the line  				var line = DateTime.Now + ";";  				//Date  				line += "0" + ";";  				//RunningTime  				line += Cache.Instance.SessionState + ";";  				//SessionState  				line += "" + ";";  				//LastMission  				line += Cache.Instance.DirectEve.Me.Wealth + ";";  				//WalletBalance  				line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  				//MemoryUsage  				line += "Starting" + ";";  				//Reason  				line += ";";  				//IskGenerated  				line += ";";  				//LootGenerated  				line += ";";  				//LPGenerated  				line += ";";  				//Isk/Hr  				line += ";";  				//Loot/Hr  				line += ";";  				//LP/HR  				line += ";\r\n";  				//Total/HR  				// The mission is finished  				File.AppendAllText (Settings.Instance.SessionsLogFile' line);  				Cache.Instance.SessionState = "";  				Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.QuestorJustStarted) {  	Cache.Instance.QuestorJustStarted = false;  	Cache.Instance.SessionState = "Starting Up";  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	Cache.Instance.SessionIskGenerated = 0;  	Cache.Instance.SessionLootGenerated = 0;  	Cache.Instance.SessionLPGenerated = 0;  	if (Settings.Instance.SessionsLog) {  		if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			//Date  			line += "0" + ";";  			//RunningTime  			line += Cache.Instance.SessionState + ";";  			//SessionState  			line += "" + ";";  			//LastMission  			line += Cache.Instance.DirectEve.Me.Wealth + ";";  			//WalletBalance  			line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  			//MemoryUsage  			line += "Starting" + ";";  			//Reason  			line += ";";  			//IskGenerated  			line += ";";  			//LootGenerated  			line += ";";  			//LPGenerated  			line += ";";  			//Isk/Hr  			line += ";";  			//Loot/Hr  			line += ";";  			//LP/HR  			line += ";\r\n";  			//Total/HR  			// The mission is finished  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Cache.Instance.SessionState = "";  			Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.QuestorJustStarted) {  	Cache.Instance.QuestorJustStarted = false;  	Cache.Instance.SessionState = "Starting Up";  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	Cache.Instance.SessionIskGenerated = 0;  	Cache.Instance.SessionLootGenerated = 0;  	Cache.Instance.SessionLPGenerated = 0;  	if (Settings.Instance.SessionsLog) {  		if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			//Date  			line += "0" + ";";  			//RunningTime  			line += Cache.Instance.SessionState + ";";  			//SessionState  			line += "" + ";";  			//LastMission  			line += Cache.Instance.DirectEve.Me.Wealth + ";";  			//WalletBalance  			line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  			//MemoryUsage  			line += "Starting" + ";";  			//Reason  			line += ";";  			//IskGenerated  			line += ";";  			//LootGenerated  			line += ";";  			//LPGenerated  			line += ";";  			//Isk/Hr  			line += ";";  			//Loot/Hr  			line += ";";  			//LP/HR  			line += ";\r\n";  			//Total/HR  			// The mission is finished  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Cache.Instance.SessionState = "";  			Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.QuestorJustStarted) {  	Cache.Instance.QuestorJustStarted = false;  	Cache.Instance.SessionState = "Starting Up";  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	Cache.Instance.SessionIskGenerated = 0;  	Cache.Instance.SessionLootGenerated = 0;  	Cache.Instance.SessionLPGenerated = 0;  	if (Settings.Instance.SessionsLog) {  		if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			//Date  			line += "0" + ";";  			//RunningTime  			line += Cache.Instance.SessionState + ";";  			//SessionState  			line += "" + ";";  			//LastMission  			line += Cache.Instance.DirectEve.Me.Wealth + ";";  			//WalletBalance  			line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  			//MemoryUsage  			line += "Starting" + ";";  			//Reason  			line += ";";  			//IskGenerated  			line += ";";  			//LootGenerated  			line += ";";  			//LPGenerated  			line += ";";  			//Isk/Hr  			line += ";";  			//Loot/Hr  			line += ";";  			//LP/HR  			line += ";\r\n";  			//Total/HR  			// The mission is finished  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Cache.Instance.SessionState = "";  			Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.SessionsLog) {  	if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		//Date  		line += "0" + ";";  		//RunningTime  		line += Cache.Instance.SessionState + ";";  		//SessionState  		line += "" + ";";  		//LastMission  		line += Cache.Instance.DirectEve.Me.Wealth + ";";  		//WalletBalance  		line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  		//MemoryUsage  		line += "Starting" + ";";  		//Reason  		line += ";";  		//IskGenerated  		line += ";";  		//LootGenerated  		line += ";";  		//LPGenerated  		line += ";";  		//Isk/Hr  		line += ";";  		//Loot/Hr  		line += ";";  		//LP/HR  		line += ";\r\n";  		//Total/HR  		// The mission is finished  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Cache.Instance.SessionState = "";  		Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.DirectEve.Me.Wealth != 0 || Cache.Instance.DirectEve.Me.Wealth != -2147483648)// this hopefully resolves having negative maxint in the session logs occasionally   {  	//  	// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  	//  	// Get the path  	if (!Directory.Exists (Settings.Instance.SessionsLogPath))  		Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  	// Write the header  	if (!File.Exists (Settings.Instance.SessionsLogFile))  		File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  	// Build the line  	var line = DateTime.Now + ";";  	//Date  	line += "0" + ";";  	//RunningTime  	line += Cache.Instance.SessionState + ";";  	//SessionState  	line += "" + ";";  	//LastMission  	line += Cache.Instance.DirectEve.Me.Wealth + ";";  	//WalletBalance  	line += Cache.Instance.totalMegaBytesOfMemoryUsed + ";";  	//MemoryUsage  	line += "Starting" + ";";  	//Reason  	line += ";";  	//IskGenerated  	line += ";";  	//LootGenerated  	line += ";";  	//LPGenerated  	line += ";";  	//Isk/Hr  	line += ";";  	//Loot/Hr  	line += ";";  	//LP/HR  	line += ";\r\n";  	//Total/HR  	// The mission is finished  	File.AppendAllText (Settings.Instance.SessionsLogFile' line);  	Cache.Instance.SessionState = "";  	Logging.Log ("Questor: Writing session data to [ " + Settings.Instance.SessionsLogFile);  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  	_lastTimeCheckAction = DateTime.Now;  	if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  		// quit questor  		Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  		Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  		Settings.Instance.AutoStart = false;  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.Idle) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  	if (Cache.Instance.StopTimeSpecified) {  		if (DateTime.Now >= Cache.Instance.StopTime) {  			Logging.Log ("Questor: Time to stop.  Quitting game.");  			Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (ExitWhenIdle && !Settings.Instance.AutoStart) {  		Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.AutoStart = false;  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.Idle) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	// Don't start missions hour before downtime  	if (DateTime.UtcNow.Hour == 10)  		break;  	// Don't start missions in downtime  	if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  		break;  	if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  		_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedStart;  		}  		Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  		return;  	} else {  		if (State == QuestorState.Idle) {  			State = QuestorState.Cleanup;  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	// Don't start missions hour before downtime  	if (DateTime.UtcNow.Hour == 10)  		break;  	// Don't start missions in downtime  	if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  		break;  	if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  		_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedStart;  		}  		Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  		return;  	} else {  		if (State == QuestorState.Idle) {  			State = QuestorState.Cleanup;  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	// Don't start missions hour before downtime  	if (DateTime.UtcNow.Hour == 10)  		break;  	// Don't start missions in downtime  	if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  		break;  	if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  		_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedStart;  		}  		Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  		return;  	} else {  		if (State == QuestorState.Idle) {  			State = QuestorState.Cleanup;  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.UtcNow.Hour == 10)  	break;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  	break;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  	break;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  	Statistics.Instance.MissionLoggingCompleted = true;  	//not technically true but if we waited this long it isn't going to happen  	Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  	if (State == QuestorState.MissionStatistics) {  		State = QuestorState.Idle;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.CharacterMode == "salvage") {  		if (State == QuestorState.Start) {  			State = QuestorState.BeginAfterMissionSalvaging;  		}  		break;  	}  	if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  		Logging.Log ("Questor: Storyline detected' doing storyline.");  		_storyline.Reset ();  		if (State == QuestorState.Start) {  			State = QuestorState.Storyline;  		}  		break;  	}  	Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  	// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  	Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  	Statistics.Instance.LootValue = 0;  	Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  	Statistics.Instance.StartedMission = DateTime.Now;  	//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  	Statistics.Instance.FinishedMission = DateTime.MinValue;  	Cache.Instance.MissionName = string.Empty;  	Statistics.Instance.LostDrones = 0;  	Statistics.Instance.AmmoConsumption = 0;  	Statistics.Instance.AmmoValue = 0;  	Statistics.Instance.MissionLoggingCompleted = false;  	Cache.Instance.DroneStatsWritten = false;  	Cache.Instance.panic_attempts_this_mission = 0;  	Cache.Instance.lowest_shield_percentage_this_mission = 101;  	Cache.Instance.lowest_armor_percentage_this_mission = 101;  	Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  	Cache.Instance.repair_cycle_time_this_mission = 0;  	Cache.Instance.TimeSpentReloading_seconds = 0;  	// this will need to be added to whenever we reload or switch ammo  	Cache.Instance.TimeSpentInMission_seconds = 0;  	// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  	Cache.Instance.TimeSpentInMissionInRange = 0;  	// time spent totally out of range' no targets  	Cache.Instance.TimeSpentInMissionOutOfRange = 0;  	// time spent in range - with targets to kill (or no targets?!)  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.CharacterMode == "salvage") {  		if (State == QuestorState.Start) {  			State = QuestorState.BeginAfterMissionSalvaging;  		}  		break;  	}  	if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  		Logging.Log ("Questor: Storyline detected' doing storyline.");  		_storyline.Reset ();  		if (State == QuestorState.Start) {  			State = QuestorState.Storyline;  		}  		break;  	}  	Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  	// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  	Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  	Statistics.Instance.LootValue = 0;  	Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  	Statistics.Instance.StartedMission = DateTime.Now;  	//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  	Statistics.Instance.FinishedMission = DateTime.MinValue;  	Cache.Instance.MissionName = string.Empty;  	Statistics.Instance.LostDrones = 0;  	Statistics.Instance.AmmoConsumption = 0;  	Statistics.Instance.AmmoValue = 0;  	Statistics.Instance.MissionLoggingCompleted = false;  	Cache.Instance.DroneStatsWritten = false;  	Cache.Instance.panic_attempts_this_mission = 0;  	Cache.Instance.lowest_shield_percentage_this_mission = 101;  	Cache.Instance.lowest_armor_percentage_this_mission = 101;  	Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  	Cache.Instance.repair_cycle_time_this_mission = 0;  	Cache.Instance.TimeSpentReloading_seconds = 0;  	// this will need to be added to whenever we reload or switch ammo  	Cache.Instance.TimeSpentInMission_seconds = 0;  	// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  	Cache.Instance.TimeSpentInMissionInRange = 0;  	// time spent totally out of range' no targets  	Cache.Instance.TimeSpentInMissionOutOfRange = 0;  	// time spent in range - with targets to kill (or no targets?!)  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.CharacterMode == "salvage") {  		if (State == QuestorState.Start) {  			State = QuestorState.BeginAfterMissionSalvaging;  		}  		break;  	}  	if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  		Logging.Log ("Questor: Storyline detected' doing storyline.");  		_storyline.Reset ();  		if (State == QuestorState.Start) {  			State = QuestorState.Storyline;  		}  		break;  	}  	Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  	// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  	Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  	Statistics.Instance.LootValue = 0;  	Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  	Statistics.Instance.StartedMission = DateTime.Now;  	//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  	Statistics.Instance.FinishedMission = DateTime.MinValue;  	Cache.Instance.MissionName = string.Empty;  	Statistics.Instance.LostDrones = 0;  	Statistics.Instance.AmmoConsumption = 0;  	Statistics.Instance.AmmoValue = 0;  	Statistics.Instance.MissionLoggingCompleted = false;  	Cache.Instance.DroneStatsWritten = false;  	Cache.Instance.panic_attempts_this_mission = 0;  	Cache.Instance.lowest_shield_percentage_this_mission = 101;  	Cache.Instance.lowest_armor_percentage_this_mission = 101;  	Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  	Cache.Instance.repair_cycle_time_this_mission = 0;  	Cache.Instance.TimeSpentReloading_seconds = 0;  	// this will need to be added to whenever we reload or switch ammo  	Cache.Instance.TimeSpentInMission_seconds = 0;  	// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  	Cache.Instance.TimeSpentInMissionInRange = 0;  	// time spent totally out of range' no targets  	Cache.Instance.TimeSpentInMissionOutOfRange = 0;  	// time spent in range - with targets to kill (or no targets?!)  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.lowest_shield_percentage_this_mission = 101;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.lowest_armor_percentage_this_mission = 101;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)   {  	_combat.ProcessState ();  	_drones.ProcessState ();  } else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp   {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  		_lastOrbit = DateTime.Now;  	}  } else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out    {  	var baseDestination = _traveler.Destination as StationDestination;  	if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  	 {  		Logging.Log ("GotoBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	} else {  		if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  			Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  			// Tell the drones module to retract drones  			Cache.Instance.IsMissionPocketDone = true;  			_lastDroneRecall = DateTime.Now;  		}  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		Cache.Instance.GotoBaseNow = false;  		//we are there - turn off the 'forced' gotobase  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_missionController.State == MissionControllerState.Error) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.Error;  			}  		} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.CompleteMission;  			}  		} else {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.UnloadLoot;  			}  		}  		_traveler.Destination = null;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)   {  	_combat.ProcessState ();  	_drones.ProcessState ();  } else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp   {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  		_lastOrbit = DateTime.Now;  	}  } else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out    {  	var baseDestination = _traveler.Destination as StationDestination;  	if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  	 {  		Logging.Log ("GotoBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	} else {  		if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  			Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  			// Tell the drones module to retract drones  			Cache.Instance.IsMissionPocketDone = true;  			_lastDroneRecall = DateTime.Now;  		}  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		Cache.Instance.GotoBaseNow = false;  		//we are there - turn off the 'forced' gotobase  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_missionController.State == MissionControllerState.Error) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.Error;  			}  		} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.CompleteMission;  			}  		} else {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.UnloadLoot;  			}  		}  		_traveler.Destination = null;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp   {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  		_lastOrbit = DateTime.Now;  	}  } else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out    {  	var baseDestination = _traveler.Destination as StationDestination;  	if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  	 {  		Logging.Log ("GotoBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	} else {  		if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  			Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  			// Tell the drones module to retract drones  			Cache.Instance.IsMissionPocketDone = true;  			_lastDroneRecall = DateTime.Now;  		}  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		Cache.Instance.GotoBaseNow = false;  		//we are there - turn off the 'forced' gotobase  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_missionController.State == MissionControllerState.Error) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.Error;  			}  		} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.CompleteMission;  			}  		} else {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.UnloadLoot;  			}  		}  		_traveler.Destination = null;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp   {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  		_lastOrbit = DateTime.Now;  	}  } else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out    {  	var baseDestination = _traveler.Destination as StationDestination;  	if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  	 {  		Logging.Log ("GotoBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	} else {  		if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  			Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  			// Tell the drones module to retract drones  			Cache.Instance.IsMissionPocketDone = true;  			_lastDroneRecall = DateTime.Now;  		}  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		Cache.Instance.GotoBaseNow = false;  		//we are there - turn off the 'forced' gotobase  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_missionController.State == MissionControllerState.Error) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.Error;  			}  		} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.CompleteMission;  			}  		} else {  			if (State == QuestorState.GotoBase) {  				State = QuestorState.UnloadLoot;  			}  		}  		_traveler.Destination = null;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  	structure.Orbit ((int)Distance.SafeDistancefromStructure);  	Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  	_lastOrbit = DateTime.Now;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second   {  	Logging.Log ("GotoBase: Priority targets found' engaging!");  	_combat.ProcessState ();  } else {  	if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  		Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  		// Tell the drones module to retract drones  		Cache.Instance.IsMissionPocketDone = true;  		_lastDroneRecall = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  	Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  	// Tell the drones module to retract drones  	Cache.Instance.IsMissionPocketDone = true;  	_lastDroneRecall = DateTime.Now;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once   {  	CloseQuestorflag = false;  	//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  	Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  	Logging.Log (Cache.Instance.ReasonToStopQuestor);  	Cache.Instance.CloseQuestorCMDLogoff = false;  	Cache.Instance.CloseQuestorCMDExitGame = true;  	Cache.Instance.SessionState = "Exiting";  	if (State == QuestorState.CheckEVEStatus) {  		State = QuestorState.CloseQuestor;  	}  	return;  } else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  	Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  	if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  		Cache.Instance.CloseQuestorCMDLogoff = true;  		Cache.Instance.CloseQuestorCMDExitGame = false;  		Cache.Instance.SessionState = "LoggingOff";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  	if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  	Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  	return;  } else {  	Cache.Instance.SessionState = "Running";  	if (State == QuestorState.CheckEVEStatus) {  		State = QuestorState.Start;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  	Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  	if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  		Cache.Instance.CloseQuestorCMDLogoff = true;  		Cache.Instance.CloseQuestorCMDExitGame = false;  		Cache.Instance.SessionState = "LoggingOff";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  	if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	}  	Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  	return;  } else {  	Cache.Instance.SessionState = "Running";  	if (State == QuestorState.CheckEVEStatus) {  		State = QuestorState.Start;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  	_combat.ProcessState ();  	_drones.ProcessState ();  } else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure2.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  		_lastOrbit = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  	if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  		structure2.Orbit ((int)Distance.SafeDistancefromStructure);  		Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  		_lastOrbit = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  	structure2.Orbit ((int)Distance.SafeDistancefromStructure);  	Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  	_lastOrbit = DateTime.Now;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_traveler.State == TravelerState.AtDestination) {  	//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  	if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  	 {  		//  		// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  		//  		// Get the path  		if (!Directory.Exists (Settings.Instance.SessionsLogPath))  			Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  		Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  		Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  		Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  		// Write the header  		if (!File.Exists (Settings.Instance.SessionsLogFile))  			File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  		// Build the line  		var line = DateTime.Now + ";";  		// Date  		line += Cache.Instance.SessionRunningTime + ";";  		// RunningTime  		line += Cache.Instance.SessionState + ";";  		// SessionState  		line += Cache.Instance.MissionName + ";";  		// LastMission  		line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  		// WalletBalance  		line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  		// MemoryUsage  		line += Cache.Instance.ReasonToStopQuestor + ";";  		// Reason to Stop Questor  		line += Cache.Instance.SessionIskGenerated + ";";  		// Isk Generated This Session  		line += Cache.Instance.SessionLootGenerated + ";";  		// Loot Generated This Session  		line += Cache.Instance.SessionLPGenerated + ";";  		// LP Generated This Session  		line += Cache.Instance.SessionIskPerHrGenerated + ";";  		// Isk Generated per hour this session  		line += Cache.Instance.SessionLootPerHrGenerated + ";";  		// Loot Generated per hour This Session  		line += Cache.Instance.SessionLPPerHrGenerated + ";";  		// LP Generated per hour This Session  		line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  		// Total Per Hour This Session  		// The mission is finished  		Logging.Log (line);  		File.AppendAllText (Settings.Instance.SessionsLogFile' line);  		Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  		Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  		Settings.Instance.SessionsLog = false;  		//so we don't write the sessionlog more than once per session  	}  	if (Settings.Instance.AutoStart) {  		if (Cache.Instance.CloseQuestorCMDLogoff) {  			if (CloseQuestorflag) {  				Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  				LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  				Logging.Log ("Questor: Logging Off eve in 15 seconds.");  				CloseQuestorflag = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve in 10 seconds");  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			}  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  			break;  		}  		if (Cache.Instance.CloseQuestorCMDExitGame) {  			//Logging.Log("Questor: We are in station: Exit option has been configured.");  			if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  				Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  			} else {  				if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  						LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  						Logging.Log ("Questor: Exiting eve in 15 seconds.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  				 {  					//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  					if (CloseQuestorCMDUplink) {  						Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  						LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  						Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  						Logging.Log ("Questor: We are in station: Exiting eve.");  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  					Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  					if (CloseQuestorCMDUplink) {  						CloseQuestorCMDUplink = false;  						_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  					}  					if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  						CloseQuestor10SecWarningDone = true;  						Logging.Log ("Questor: Exiting eve in 10 seconds");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					if (_CloseQuestorDelay < DateTime.Now) {  						Logging.Log ("Questor: Exiting eve now.");  						Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  					}  					return;  				}  			}  		}  	}  	Logging.Log ("Autostart is false: Stopping EVE with quit command");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once   {  	//  	// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  	//  	// Get the path  	if (!Directory.Exists (Settings.Instance.SessionsLogPath))  		Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  	Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  	Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  	// Write the header  	if (!File.Exists (Settings.Instance.SessionsLogFile))  		File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  	// Build the line  	var line = DateTime.Now + ";";  	// Date  	line += Cache.Instance.SessionRunningTime + ";";  	// RunningTime  	line += Cache.Instance.SessionState + ";";  	// SessionState  	line += Cache.Instance.MissionName + ";";  	// LastMission  	line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  	// WalletBalance  	line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  	// MemoryUsage  	line += Cache.Instance.ReasonToStopQuestor + ";";  	// Reason to Stop Questor  	line += Cache.Instance.SessionIskGenerated + ";";  	// Isk Generated This Session  	line += Cache.Instance.SessionLootGenerated + ";";  	// Loot Generated This Session  	line += Cache.Instance.SessionLPGenerated + ";";  	// LP Generated This Session  	line += Cache.Instance.SessionIskPerHrGenerated + ";";  	// Isk Generated per hour this session  	line += Cache.Instance.SessionLootPerHrGenerated + ";";  	// Loot Generated per hour This Session  	line += Cache.Instance.SessionLPPerHrGenerated + ";";  	// LP Generated per hour This Session  	line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  	// Total Per Hour This Session  	// The mission is finished  	Logging.Log (line);  	File.AppendAllText (Settings.Instance.SessionsLogFile' line);  	Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  	Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  	Settings.Instance.SessionsLog = false;  	//so we don't write the sessionlog more than once per session  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once   {  	//  	// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  	//  	// Get the path  	if (!Directory.Exists (Settings.Instance.SessionsLogPath))  		Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  	Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  	Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  	// Write the header  	if (!File.Exists (Settings.Instance.SessionsLogFile))  		File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  	// Build the line  	var line = DateTime.Now + ";";  	// Date  	line += Cache.Instance.SessionRunningTime + ";";  	// RunningTime  	line += Cache.Instance.SessionState + ";";  	// SessionState  	line += Cache.Instance.MissionName + ";";  	// LastMission  	line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  	// WalletBalance  	line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  	// MemoryUsage  	line += Cache.Instance.ReasonToStopQuestor + ";";  	// Reason to Stop Questor  	line += Cache.Instance.SessionIskGenerated + ";";  	// Isk Generated This Session  	line += Cache.Instance.SessionLootGenerated + ";";  	// Loot Generated This Session  	line += Cache.Instance.SessionLPGenerated + ";";  	// LP Generated This Session  	line += Cache.Instance.SessionIskPerHrGenerated + ";";  	// Isk Generated per hour this session  	line += Cache.Instance.SessionLootPerHrGenerated + ";";  	// Loot Generated per hour This Session  	line += Cache.Instance.SessionLPPerHrGenerated + ";";  	// LP Generated per hour This Session  	line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  	// Total Per Hour This Session  	// The mission is finished  	Logging.Log (line);  	File.AppendAllText (Settings.Instance.SessionsLogFile' line);  	Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  	Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  	Settings.Instance.SessionsLog = false;  	//so we don't write the sessionlog more than once per session  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once   {  	//  	// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  	//  	// Get the path  	if (!Directory.Exists (Settings.Instance.SessionsLogPath))  		Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  	Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  	Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  	Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  	// Write the header  	if (!File.Exists (Settings.Instance.SessionsLogFile))  		File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  	// Build the line  	var line = DateTime.Now + ";";  	// Date  	line += Cache.Instance.SessionRunningTime + ";";  	// RunningTime  	line += Cache.Instance.SessionState + ";";  	// SessionState  	line += Cache.Instance.MissionName + ";";  	// LastMission  	line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  	// WalletBalance  	line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  	// MemoryUsage  	line += Cache.Instance.ReasonToStopQuestor + ";";  	// Reason to Stop Questor  	line += Cache.Instance.SessionIskGenerated + ";";  	// Isk Generated This Session  	line += Cache.Instance.SessionLootGenerated + ";";  	// Loot Generated This Session  	line += Cache.Instance.SessionLPGenerated + ";";  	// LP Generated This Session  	line += Cache.Instance.SessionIskPerHrGenerated + ";";  	// Isk Generated per hour this session  	line += Cache.Instance.SessionLootPerHrGenerated + ";";  	// Loot Generated per hour This Session  	line += Cache.Instance.SessionLPPerHrGenerated + ";";  	// LP Generated per hour This Session  	line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  	// Total Per Hour This Session  	// The mission is finished  	Logging.Log (line);  	File.AppendAllText (Settings.Instance.SessionsLogFile' line);  	Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  	Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  	Settings.Instance.SessionsLog = false;  	//so we don't write the sessionlog more than once per session  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	if (Cache.Instance.CloseQuestorCMDLogoff) {  		if (CloseQuestorflag) {  			Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  			LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  			Logging.Log ("Questor: Logging Off eve in 15 seconds.");  			CloseQuestorflag = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve in 10 seconds");  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		}  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		break;  	}  	if (Cache.Instance.CloseQuestorCMDExitGame) {  		//Logging.Log("Questor: We are in station: Exit option has been configured.");  		if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  			Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  		} else {  			if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  					LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  					Logging.Log ("Questor: Exiting eve in 15 seconds.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  					LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  					Logging.Log ("Questor: We are in station: Exiting eve.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  				Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  				if (CloseQuestorCMDUplink) {  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	if (Cache.Instance.CloseQuestorCMDLogoff) {  		if (CloseQuestorflag) {  			Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  			LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  			Logging.Log ("Questor: Logging Off eve in 15 seconds.");  			CloseQuestorflag = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve in 10 seconds");  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		}  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		break;  	}  	if (Cache.Instance.CloseQuestorCMDExitGame) {  		//Logging.Log("Questor: We are in station: Exit option has been configured.");  		if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  			Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  		} else {  			if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  					LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  					Logging.Log ("Questor: Exiting eve in 15 seconds.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  					LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  					Logging.Log ("Questor: We are in station: Exiting eve.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  				Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  				if (CloseQuestorCMDUplink) {  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	if (Cache.Instance.CloseQuestorCMDLogoff) {  		if (CloseQuestorflag) {  			Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  			LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  			Logging.Log ("Questor: Logging Off eve in 15 seconds.");  			CloseQuestorflag = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve in 10 seconds");  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		}  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		break;  	}  	if (Cache.Instance.CloseQuestorCMDExitGame) {  		//Logging.Log("Questor: We are in station: Exit option has been configured.");  		if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  			Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  		} else {  			if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  					LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  					Logging.Log ("Questor: Exiting eve in 15 seconds.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  					LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  					Logging.Log ("Questor: We are in station: Exiting eve.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  				Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  				if (CloseQuestorCMDUplink) {  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.AutoStart) {  	if (Cache.Instance.CloseQuestorCMDLogoff) {  		if (CloseQuestorflag) {  			Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  			LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  			Logging.Log ("Questor: Logging Off eve in 15 seconds.");  			CloseQuestorflag = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve in 10 seconds");  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		}  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  		break;  	}  	if (Cache.Instance.CloseQuestorCMDExitGame) {  		//Logging.Log("Questor: We are in station: Exit option has been configured.");  		if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  			Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  		} else {  			if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  					LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  					Logging.Log ("Questor: Exiting eve in 15 seconds.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  			 {  				//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  				if (CloseQuestorCMDUplink) {  					Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  					LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  					Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  					Logging.Log ("Questor: We are in station: Exiting eve.");  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  				Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  				if (CloseQuestorCMDUplink) {  					CloseQuestorCMDUplink = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  					CloseQuestor10SecWarningDone = true;  					Logging.Log ("Questor: Exiting eve in 10 seconds");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  				}  				return;  			}  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.CloseQuestorCMDLogoff) {  	if (CloseQuestorflag) {  		Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  		LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  		Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  		Logging.Log ("Questor: Logging Off eve in 15 seconds.");  		CloseQuestorflag = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve in 10 seconds");  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  	}  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  	Logging.Log ("Questor: Exiting eve in 10 seconds");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.CloseQuestorCMDExitGame) {  	//Logging.Log("Questor: We are in station: Exit option has been configured.");  	if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  		Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  	} else {  		if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  				LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  				Logging.Log ("Questor: Exiting eve in 15 seconds.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  				LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  				Logging.Log ("Questor: We are in station: Exiting eve.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  			Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  			if (CloseQuestorCMDUplink) {  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.CloseQuestorCMDExitGame) {  	//Logging.Log("Questor: We are in station: Exit option has been configured.");  	if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  		Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  	} else {  		if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  				LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  				Logging.Log ("Questor: Exiting eve in 15 seconds.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  				LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  				Logging.Log ("Questor: We are in station: Exiting eve.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  			Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  			if (CloseQuestorCMDUplink) {  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.CloseQuestorCMDExitGame) {  	//Logging.Log("Questor: We are in station: Exit option has been configured.");  	if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  		Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  	} else {  		if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  				LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  				Logging.Log ("Questor: Exiting eve in 15 seconds.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  		 {  			//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  			if (CloseQuestorCMDUplink) {  				Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  				LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  				Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  				Logging.Log ("Questor: We are in station: Exiting eve.");  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  			Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  			if (CloseQuestorCMDUplink) {  				CloseQuestorCMDUplink = false;  				_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  			}  			if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  				CloseQuestor10SecWarningDone = true;  				Logging.Log ("Questor: Exiting eve in 10 seconds");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			if (_CloseQuestorDelay < DateTime.Now) {  				Logging.Log ("Questor: Exiting eve now.");  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  			}  			return;  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  	Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  } else {  	if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  			LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  			Logging.Log ("Questor: Exiting eve in 15 seconds.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  			LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  			Logging.Log ("Questor: We are in station: Exiting eve.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  		Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  		if (CloseQuestorCMDUplink) {  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  	Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  } else {  	if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  			LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  			Logging.Log ("Questor: Exiting eve in 15 seconds.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  			LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  			Logging.Log ("Questor: We are in station: Exiting eve.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  		Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  		if (CloseQuestorCMDUplink) {  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  	Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  } else {  	if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  			LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  			Logging.Log ("Questor: Exiting eve in 15 seconds.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  	 {  		//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  		if (CloseQuestorCMDUplink) {  			Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  			LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  			Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  			Logging.Log ("Questor: We are in station: Exiting eve.");  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  		Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  		if (CloseQuestorCMDUplink) {  			CloseQuestorCMDUplink = false;  			_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  		}  		if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  			CloseQuestor10SecWarningDone = true;  			Logging.Log ("Questor: Exiting eve in 10 seconds");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		if (_CloseQuestorDelay < DateTime.Now) {  			Logging.Log ("Questor: Exiting eve now.");  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		}  		return;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  		LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  		Logging.Log ("Questor: Exiting eve in 15 seconds.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  		LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  		Logging.Log ("Questor: We are in station: Exiting eve.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  		LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  		Logging.Log ("Questor: Exiting eve in 15 seconds.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  		LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  		Logging.Log ("Questor: We are in station: Exiting eve.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  		LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  		Logging.Log ("Questor: Exiting eve in 15 seconds.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  		LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  		Logging.Log ("Questor: We are in station: Exiting eve.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  	CloseQuestor10SecWarningDone = true;  	Logging.Log ("Questor: Exiting eve in 10 seconds");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  		LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  		Logging.Log ("Questor: We are in station: Exiting eve.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session   {  	//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  	if (CloseQuestorCMDUplink) {  		Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  		LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  		Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  		Logging.Log ("Questor: We are in station: Exiting eve.");  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  } else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  	CloseQuestor10SecWarningDone = true;  	Logging.Log ("Questor: Exiting eve in 10 seconds");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  	Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  	if (CloseQuestorCMDUplink) {  		CloseQuestorCMDUplink = false;  		_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  	}  	if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  		CloseQuestor10SecWarningDone = true;  		Logging.Log ("Questor: Exiting eve in 10 seconds");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	if (_CloseQuestorDelay < DateTime.Now) {  		Logging.Log ("Questor: Exiting eve now.");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  	CloseQuestor10SecWarningDone = true;  	Logging.Log ("Questor: Exiting eve in 10 seconds");  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.DroneStatsLog) {  		// Lost drone statistics  		// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  		if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  			var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  			if (droneBay.Window == null) {  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  				break;  			}  			if (!droneBay.IsReady)  				break;  			if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  				var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  				Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  				Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  				if (!File.Exists (Settings.Instance.DroneStatslogFile))  					File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  				var droneline = Cache.Instance.MissionName + ";";  				droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  				File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  				Cache.Instance.DroneStatsWritten = true;  			} else {  				Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  			}  		}  	}  	// Lost drone statistics stuff ends here  	// Ammo Consumption statistics  	// Is cargo open?  	var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  	if (cargoship.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (!cargoship.IsReady)  		break;  	var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  	var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  	foreach (var item in AmmoCargo) {  		var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  		var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  		Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  		Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  	}  	Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.DroneStatsLog) {  		// Lost drone statistics  		// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  		if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  			var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  			if (droneBay.Window == null) {  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  				break;  			}  			if (!droneBay.IsReady)  				break;  			if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  				var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  				Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  				Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  				if (!File.Exists (Settings.Instance.DroneStatslogFile))  					File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  				var droneline = Cache.Instance.MissionName + ";";  				droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  				File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  				Cache.Instance.DroneStatsWritten = true;  			} else {  				Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  			}  		}  	}  	// Lost drone statistics stuff ends here  	// Ammo Consumption statistics  	// Is cargo open?  	var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  	if (cargoship.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (!cargoship.IsReady)  		break;  	var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  	var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  	foreach (var item in AmmoCargo) {  		var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  		var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  		Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  		Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  	}  	Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (_agentInteraction.State == AgentInteractionState.Idle) {  	if (Settings.Instance.DroneStatsLog) {  		// Lost drone statistics  		// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  		if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  			var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  			if (droneBay.Window == null) {  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  				break;  			}  			if (!droneBay.IsReady)  				break;  			if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  				var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  				Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  				Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  				if (!File.Exists (Settings.Instance.DroneStatslogFile))  					File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  				var droneline = Cache.Instance.MissionName + ";";  				droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  				File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  				Cache.Instance.DroneStatsWritten = true;  			} else {  				Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  			}  		}  	}  	// Lost drone statistics stuff ends here  	// Ammo Consumption statistics  	// Is cargo open?  	var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  	if (cargoship.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (!cargoship.IsReady)  		break;  	var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  	var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  	foreach (var item in AmmoCargo) {  		var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  		var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  		Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  		Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  	}  	Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  	_agentInteraction.State = AgentInteractionState.StartConversation;  	_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.DroneStatsLog) {  	// Lost drone statistics  	// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  	if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  		var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  		if (droneBay.Window == null) {  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  			break;  		}  		if (!droneBay.IsReady)  			break;  		if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  			var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  			Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  			Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  			if (!File.Exists (Settings.Instance.DroneStatslogFile))  				File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  			var droneline = Cache.Instance.MissionName + ";";  			droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  			File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  			Cache.Instance.DroneStatsWritten = true;  		} else {  			Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.DroneStatsLog) {  	// Lost drone statistics  	// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  	if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  		var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  		if (droneBay.Window == null) {  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  			break;  		}  		if (!droneBay.IsReady)  			break;  		if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  			var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  			Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  			Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  			if (!File.Exists (Settings.Instance.DroneStatslogFile))  				File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  			var droneline = Cache.Instance.MissionName + ";";  			droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  			File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  			Cache.Instance.DroneStatsWritten = true;  		} else {  			Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.DroneStatsLog) {  	// Lost drone statistics  	// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  	if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  		var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  		if (droneBay.Window == null) {  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  			break;  		}  		if (!droneBay.IsReady)  			break;  		if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  			var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  			Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  			Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  			if (!File.Exists (Settings.Instance.DroneStatslogFile))  				File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  			var droneline = Cache.Instance.MissionName + ";";  			droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  			File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  			Cache.Instance.DroneStatsWritten = true;  		} else {  			Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  		}  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  	var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  	if (droneBay.Window == null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  		break;  	}  	if (!droneBay.IsReady)  		break;  	if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  		var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  		Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  		Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  		if (!File.Exists (Settings.Instance.DroneStatslogFile))  			File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  		var droneline = Cache.Instance.MissionName + ";";  		droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  		File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  		Cache.Instance.DroneStatsWritten = true;  	} else {  		Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  	var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  	if (droneBay.Window == null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  		break;  	}  	if (!droneBay.IsReady)  		break;  	if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  		var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  		Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  		Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  		if (!File.Exists (Settings.Instance.DroneStatslogFile))  			File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  		var droneline = Cache.Instance.MissionName + ";";  		droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  		File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  		Cache.Instance.DroneStatsWritten = true;  	} else {  		Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  	var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  	if (droneBay.Window == null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  		break;  	}  	if (!droneBay.IsReady)  		break;  	if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  		var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  		Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  		Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  		if (!File.Exists (Settings.Instance.DroneStatslogFile))  			File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  		var droneline = Cache.Instance.MissionName + ";";  		droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  		File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  		Cache.Instance.DroneStatsWritten = true;  	} else {  		Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  	Logging.Log ("Salvage: We are full' go to base to unload");  	if (State == QuestorState.Salvage) {  		State = QuestorState.GotoBase;  	}  	break;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  	if (closestWreck.Distance > (int)Distance.WarptoDistance) {  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  			closestWreck.WarpTo ();  		}  	} else  		closestWreck.Approach ();  } else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  	Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  	if (closestWreck.Distance > (int)Distance.WarptoDistance) {  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  			closestWreck.WarpTo ();  		}  	} else  		closestWreck.Approach ();  } else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  	Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.WarptoDistance) {  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  		closestWreck.WarpTo ();  	}  } else  	closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.WarptoDistance) {  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  		closestWreck.WarpTo ();  	}  } else  	closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  	closestWreck.WarpTo ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  	closestWreck.WarpTo ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: try {  	// Overwrite settings' as the 'normal' settings do not apply  	_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  	_salvage.ReserveCargoCapacity = 80;  	_salvage.LootEverything = true;  	_salvage.ProcessState ();  	//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  	//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  	//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  } finally {  	ApplySettings ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: _salvage.ReserveCargoCapacity = 80;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.DecloakRange) {  	Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  	// Activate it and move to the next Pocket  	closest.Activate ();  	// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  	Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  	if (State == QuestorState.SalvageUseGate) {  		State = QuestorState.SalvageNextPocket;  	}  	_lastPulse = DateTime.Now;  	return;  } else if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.DecloakRange) {  	Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  	// Activate it and move to the next Pocket  	closest.Activate ();  	// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  	Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  	if (State == QuestorState.SalvageUseGate) {  		State = QuestorState.SalvageNextPocket;  	}  	_lastPulse = DateTime.Now;  	return;  } else if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.DecloakRange) {  	Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  	// Activate it and move to the next Pocket  	closest.Activate ();  	// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  	Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  	if (State == QuestorState.SalvageUseGate) {  		State = QuestorState.SalvageNextPocket;  	}  	_lastPulse = DateTime.Now;  	return;  } else if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closest.Distance < (int)Distance.WarptoDistance) {  	// Move to the target  	if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  		Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.Approach ();  	}  } else {  	// Probably never happens  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  		closest.WarpTo ();  		_lastWarpTo = DateTime.Now;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  	Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  	closest.Approach ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  	closest.WarpTo ();  	_lastWarpTo = DateTime.Now;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  	closest.WarpTo ();  	_lastWarpTo = DateTime.Now;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: _lastPulse = DateTime.Now.AddSeconds (10);  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (distance > (int)Distance.NextPocketDistance) {  	//we know we are connected here...  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  	if (State == QuestorState.SalvageUseGate) {  		State = QuestorState.Salvage;  	}  	return;  } else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  	Logging.Log ("Salvage: We've timed out' retry last action");  	// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.SalvageUseGate;  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (distance > (int)Distance.NextPocketDistance) {  	//we know we are connected here...  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  	if (State == QuestorState.SalvageUseGate) {  		State = QuestorState.Salvage;  	}  	return;  } else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  	Logging.Log ("Salvage: We've timed out' retry last action");  	// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.SalvageUseGate;  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  	Logging.Log ("Salvage: We've timed out' retry last action");  	// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.SalvageUseGate;  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  	if (closestWreck.Distance > (int)Distance.WarptoDistance)  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  			closestWreck.WarpTo ();  			_lastWarpTo = DateTime.Now;  		} else  			closestWreck.Approach ();  } else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  	Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.WarptoDistance)  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  		closestWreck.WarpTo ();  		_lastWarpTo = DateTime.Now;  	} else  		closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  	closestWreck.WarpTo ();  	_lastWarpTo = DateTime.Now;  } else  	closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: try {  	// Overwrite settings' as the 'normal' settings do not apply  	_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  	_salvage.ReserveCargoCapacity = 80;  	_salvage.LootEverything = true;  	_salvage.ProcessState ();  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  } finally {  	ApplySettings ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: _salvage.ReserveCargoCapacity = 80;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  	Logging.Log ("Salvage: We are full");  	if (State == QuestorState.SalvageOnlyBookmarks) {  		State = QuestorState.Error;  	}  	return;  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  	if (closestWreck.Distance > (int)Distance.WarptoDistance)  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  			closestWreck.WarpTo ();  			_lastWarpTo = DateTime.Now;  		} else  			closestWreck.Approach ();  } else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  	Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  	if (closestWreck.Distance > (int)Distance.WarptoDistance)  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  			closestWreck.WarpTo ();  			_lastWarpTo = DateTime.Now;  		} else  			closestWreck.Approach ();  } else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  	Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.WarptoDistance)  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  		closestWreck.WarpTo ();  		_lastWarpTo = DateTime.Now;  	} else  		closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (closestWreck.Distance > (int)Distance.WarptoDistance)  	if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  		Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  		closestWreck.WarpTo ();  		_lastWarpTo = DateTime.Now;  	} else  		closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  	closestWreck.WarpTo ();  	_lastWarpTo = DateTime.Now;  } else  	closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  	Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  	closestWreck.WarpTo ();  	_lastWarpTo = DateTime.Now;  } else  	closestWreck.Approach ();  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: try {  	// Overwrite settings' as the 'normal' settings do not apply  	_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  	_salvage.ReserveCargoCapacity = 80;  	_salvage.LootEverything = true;  	_salvage.ProcessState ();  } finally {  	ApplySettings ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: _salvage.ReserveCargoCapacity = 80;  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station != null) {  	if (station.Distance > (int)Distance.WarptoDistance) {  		station.WarpToAndDock ();  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Salvage;  		}  		break;  	} else {  		if (station.Distance < 1900) {  			if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  				station.Dock ();  				_lastDock = DateTime.Now;  			}  		} else {  			if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  				if (Cache.Instance.Approaching.Id != station.Id)  					station.Approach ();  			} else  				station.Approach ();  		}  	}  } else {  	if (State == QuestorState.GotoNearestStation) {  		State = QuestorState.Error;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station != null) {  	if (station.Distance > (int)Distance.WarptoDistance) {  		station.WarpToAndDock ();  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Salvage;  		}  		break;  	} else {  		if (station.Distance < 1900) {  			if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  				station.Dock ();  				_lastDock = DateTime.Now;  			}  		} else {  			if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  				if (Cache.Instance.Approaching.Id != station.Id)  					station.Approach ();  			} else  				station.Approach ();  		}  	}  } else {  	if (State == QuestorState.GotoNearestStation) {  		State = QuestorState.Error;  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station.Distance > (int)Distance.WarptoDistance) {  	station.WarpToAndDock ();  	if (State == QuestorState.GotoNearestStation) {  		State = QuestorState.Salvage;  	}  	break;  } else {  	if (station.Distance < 1900) {  		if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  			station.Dock ();  			_lastDock = DateTime.Now;  		}  	} else {  		if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  			if (Cache.Instance.Approaching.Id != station.Id)  				station.Approach ();  		} else  			station.Approach ();  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station.Distance > (int)Distance.WarptoDistance) {  	station.WarpToAndDock ();  	if (State == QuestorState.GotoNearestStation) {  		State = QuestorState.Salvage;  	}  	break;  } else {  	if (station.Distance < 1900) {  		if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  			station.Dock ();  			_lastDock = DateTime.Now;  		}  	} else {  		if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  			if (Cache.Instance.Approaching.Id != station.Id)  				station.Approach ();  		} else  			station.Approach ();  	}  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station.Distance < 1900) {  	if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  		station.Dock ();  		_lastDock = DateTime.Now;  	}  } else {  	if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  		if (Cache.Instance.Approaching.Id != station.Id)  			station.Approach ();  	} else  		station.Approach ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (station.Distance < 1900) {  	if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  		station.Dock ();  		_lastDock = DateTime.Now;  	}  } else {  	if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  		if (Cache.Instance.Approaching.Id != station.Id)  			station.Approach ();  	} else  		station.Approach ();  }  
Magic Number,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following statement contains a magic number: if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  	station.Dock ();  	_lastDock = DateTime.Now;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (ArgumentSource s in sources) {  	string[] names = s.GetNames ();  	if (names == null || names.Length == 0)  		continue;  	int written = 0;  	Write (o' ref written' "  ");  	Write (o' ref written' names [0]);  	for (int i = 1; i < names.Length; ++i) {  		Write (o' ref written' "' ");  		Write (o' ref written' names [i]);  	}  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,Arm,The following statement contains a magic number: if (directEve.ActiveShip.GroupId == 31)  	return StorylineState.GotoAgent;  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,Arm,The following statement contains a magic number: if (ships.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("MaterialsForWarPreparation: Opening ship hangar");  	// No' command it to open  	Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenShipHangar);  	return StorylineState.Arm;  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,Arm,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,Arm,The following statement contains a magic number: if (item != null) {  	Logging.Log ("MaterialsForWarPreparation: Switching to shuttle");  	_nextAction = DateTime.Now.AddSeconds (10);  	item.ActivateShip ();  	return StorylineState.Arm;  } else {  	Logging.Log ("MaterialsForWarPreparation: No shuttle found' going in active ship");  	return StorylineState.GotoAgent;  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,Arm,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: if (hangar.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("MaterialsForWarPreparation: Opening hangar floor");  	directEve.ExecuteCommand (DirectCmd.OpenHangarFloor);  	return StorylineState.PreAcceptMission;  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: if (marketWindow == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("MaterialsForWarPreparation: Opening market window");  	directEve.ExecuteCommand (DirectCmd.OpenMarket);  	return StorylineState.PreAcceptMission;  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: if (marketWindow.DetailTypeId != oreid) {  	// No' load the ore orders  	marketWindow.LoadTypeId (oreid);  	Logging.Log ("MaterialsForWarPreparation: Loading market window");  	_nextAction = DateTime.Now.AddSeconds (5);  	return StorylineState.PreAcceptMission;  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (5);  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: if (neededQuantity > 0) {  	// Get the first order  	var order = orders.OrderBy (o => o.Price).FirstOrDefault ();  	if (order != null) {  		// Calculate how much ore we still need  		var remaining = Math.Min (neededQuantity' order.VolumeRemaining);  		order.Buy (remaining' DirectOrderRange.Station);  		Logging.Log ("MaterialsForWarPreparation: Buying [" + remaining + "] ore");  		// Wait for the order to go through  		_nextAction = DateTime.Now.AddSeconds (10);  	}  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: if (order != null) {  	// Calculate how much ore we still need  	var remaining = Math.Min (neededQuantity' order.VolumeRemaining);  	order.Buy (remaining' DirectOrderRange.Station);  	Logging.Log ("MaterialsForWarPreparation: Buying [" + remaining + "] ore");  	// Wait for the order to go through  	_nextAction = DateTime.Now.AddSeconds (10);  }  
Magic Number,Questor.Storylines,MaterialsForWarPreparation,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\MaterialsForWarPreparation.cs,PreAcceptMission,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (hangar.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("MaterialsForWarPreparation: Opening hangar floor");  	directEve.ExecuteCommand (DirectCmd.OpenHangarFloor);  	return;  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (!hangar.Items.Any (i => i.GroupId >= 738 && i.GroupId <= 750)) {  	State = StorylineState.Done;  	return;  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (!hangar.Items.Any (i => i.GroupId >= 738 && i.GroupId <= 750)) {  	State = StorylineState.Done;  	return;  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (cargo.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("MaterialsForWarPreparation: Opening cargo");  	directEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  	return;  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (Cache.Instance.DirectEve.GetLockedItems ().Count == 0) {  	// Move all the implants to the cargo bay  	foreach (var item in hangar.Items.Where (i => i.GroupId >= 738 && i.GroupId <= 750)) {  		if (cargo.Capacity - cargo.UsedCapacity - (item.Volume * item.Quantity) < 0) {  			Logging.Log ("Storyline: We are full' not moving anything else");  			State = StorylineState.Done;  			return;  		}  		Logging.Log ("Storyline: Moving [" + item.TypeName + "][" + item.ItemId + "] to cargo");  		cargo.Add (item' item.Quantity);  	}  	_nextAction = DateTime.Now.AddSeconds (10);  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (Cache.Instance.DirectEve.GetLockedItems ().Count == 0) {  	// Move all the implants to the cargo bay  	foreach (var item in hangar.Items.Where (i => i.GroupId >= 738 && i.GroupId <= 750)) {  		if (cargo.Capacity - cargo.UsedCapacity - (item.Volume * item.Quantity) < 0) {  			Logging.Log ("Storyline: We are full' not moving anything else");  			State = StorylineState.Done;  			return;  		}  		Logging.Log ("Storyline: Moving [" + item.TypeName + "][" + item.ItemId + "] to cargo");  		cargo.Add (item' item.Quantity);  	}  	_nextAction = DateTime.Now.AddSeconds (10);  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: if (Cache.Instance.DirectEve.GetLockedItems ().Count == 0) {  	// Move all the implants to the cargo bay  	foreach (var item in hangar.Items.Where (i => i.GroupId >= 738 && i.GroupId <= 750)) {  		if (cargo.Capacity - cargo.UsedCapacity - (item.Volume * item.Quantity) < 0) {  			Logging.Log ("Storyline: We are full' not moving anything else");  			State = StorylineState.Done;  			return;  		}  		Logging.Log ("Storyline: Moving [" + item.TypeName + "][" + item.ItemId + "] to cargo");  		cargo.Add (item' item.Quantity);  	}  	_nextAction = DateTime.Now.AddSeconds (10);  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: foreach (var item in hangar.Items.Where (i => i.GroupId >= 738 && i.GroupId <= 750)) {  	if (cargo.Capacity - cargo.UsedCapacity - (item.Volume * item.Quantity) < 0) {  		Logging.Log ("Storyline: We are full' not moving anything else");  		State = StorylineState.Done;  		return;  	}  	Logging.Log ("Storyline: Moving [" + item.TypeName + "][" + item.ItemId + "] to cargo");  	cargo.Add (item' item.Quantity);  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: foreach (var item in hangar.Items.Where (i => i.GroupId >= 738 && i.GroupId <= 750)) {  	if (cargo.Capacity - cargo.UsedCapacity - (item.Volume * item.Quantity) < 0) {  		Logging.Log ("Storyline: We are full' not moving anything else");  		State = StorylineState.Done;  		return;  	}  	Logging.Log ("Storyline: Moving [" + item.TypeName + "][" + item.ItemId + "] to cargo");  	cargo.Add (item' item.Quantity);  }  
Magic Number,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,BringSpoilsOfWar,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,Arm,The following statement contains a magic number: if (directEve.ActiveShip.GroupId == 31)  	return StorylineState.GotoAgent;  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,Arm,The following statement contains a magic number: if (ships.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("TransactionDataDelivery: Opening ship hangar");  	// No' command it to open  	directEve.ExecuteCommand (DirectCmd.OpenShipHangar);  	return StorylineState.Arm;  }  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,Arm,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,Arm,The following statement contains a magic number: if (item != null) {  	Logging.Log ("TransactionDataDelivery: Switching to shuttle");  	_nextAction = DateTime.Now.AddSeconds (10);  	item.ActivateShip ();  	return StorylineState.Arm;  } else {  	Logging.Log ("TransactionDataDelivery: No shuttle found' going in active ship");  	return StorylineState.GotoAgent;  }  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,Arm,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The following statement contains a magic number: if (hangar.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("TransactionDataDelivery: Opening hangar floor");  	directEve.ExecuteCommand (DirectCmd.OpenHangarFloor);  	return false;  }  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The following statement contains a magic number: if (cargo.Window == null) {  	_nextAction = DateTime.Now.AddSeconds (10);  	Logging.Log ("TransactionDataDelivery: Opening cargo");  	directEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  	return false;  }  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Magic Number,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,MoveItem,The following statement contains a magic number: _nextAction = DateTime.Now.AddSeconds (10);  
Missing Default,Questor,Questor,F:\newReposMay17\Da-Teach_Questor\Questor\Questor.cs,OnFrame,The following switch statement is missing a default case: switch (State) {  case QuestorState.Idle:  	// Every 5 min of idle check and make sure we aren't supposed to stop...   	if (Math.Round (DateTime.Now.Subtract (_lastTimeCheckAction).TotalMinutes) > 5) {  		_lastTimeCheckAction = DateTime.Now;  		if (DateTime.Now.Subtract (_questorStarted).TotalMinutes > Cache.Instance.MaxRuntime) {  			// quit questor  			Logging.Log ("Questor: Maximum runtime exceeded.  Quiting...");  			Cache.Instance.ReasonToStopQuestor = "Maximum runtime specified and reached.";  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Cache.Instance.StopTimeSpecified) {  			if (DateTime.Now >= Cache.Instance.StopTime) {  				Logging.Log ("Questor: Time to stop.  Quitting game.");  				Cache.Instance.ReasonToStopQuestor = "StopTimeSpecified and reached.";  				Settings.Instance.AutoStart = false;  				Cache.Instance.CloseQuestorCMDLogoff = false;  				Cache.Instance.CloseQuestorCMDExitGame = true;  				Cache.Instance.SessionState = "Exiting";  				if (State == QuestorState.Idle) {  					State = QuestorState.CloseQuestor;  				}  				return;  			}  		}  		if (ExitWhenIdle && !Settings.Instance.AutoStart) {  			Cache.Instance.ReasonToStopQuestor = "Settings: ExitWhenIdle is true' and we are idle... exiting";  			Logging.Log (Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.AutoStart = false;  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.Idle) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  	}  	if (Cache.Instance.InSpace) {  		// Questor does not handle in space starts very well' head back to base to try again  		Logging.Log ("Questor: Started questor while in space' heading back to base in 15 seconds");  		_lastAction = DateTime.Now;  		if (State == QuestorState.Idle) {  			State = QuestorState.DelayedGotoBase;  		}  		break;  	}  	// only attempt to write the mission statistics logs if one of the mission stats logs is enabled in settings  	if (Settings.Instance.MissionStats1Log || Settings.Instance.MissionStats3Log || Settings.Instance.MissionStats3Log) {  		if (!Statistics.Instance.MissionLoggingCompleted) {  			Statistics.Instance.MissionLoggingStarted = false;  			if (State == QuestorState.Idle) {  				State = QuestorState.MissionStatistics;  			}  			break;  		}  	}  	if (Settings.Instance.AutoStart) {  		// Don't start missions hour before downtime  		if (DateTime.UtcNow.Hour == 10)  			break;  		// Don't start missions in downtime  		if (DateTime.UtcNow.Hour == 11 && DateTime.UtcNow.Minute < 15)  			break;  		if (Settings.Instance.RandomDelay > 0 || Settings.Instance.MinimumDelay > 0) {  			_randomDelay = (Settings.Instance.RandomDelay > 0 ? _random.Next (Settings.Instance.RandomDelay) : 0) + Settings.Instance.MinimumDelay;  			_lastAction = DateTime.Now;  			if (State == QuestorState.Idle) {  				State = QuestorState.DelayedStart;  			}  			Logging.Log ("Questor: Random mission start delay of [" + _randomDelay + "] seconds");  			return;  		} else {  			if (State == QuestorState.Idle) {  				State = QuestorState.Cleanup;  			}  			return;  		}  	}  	break;  case QuestorState.DelayedStart:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < _randomDelay)  		break;  	_storyline.Reset ();  	if (State == QuestorState.DelayedStart) {  		State = QuestorState.Cleanup;  	}  	break;  case QuestorState.MissionStatistics:  	// Start _statistics.ProcessState  	// Description: Writes the mission log(s)' when necessary.   	//  	watch.Reset ();  	watch.Start ();  	_statistics.State = StatisticsState.MissionLog;  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	_statistics.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates | Statistics.Instance.DebugMissionStatistics)  		Logging.Log ("statistics.State = " + _statistics.State);  	// Done  	// Statistics State: ProcessState  	if (DateTime.Now.Subtract (Statistics.Instance.MissionLoggingStartedTimestamp).TotalSeconds > 30) {  		Statistics.Instance.MissionLoggingCompleted = true;  		//not technically true but if we waited this long it isn't going to happen  		Logging.Log ("Questor: statistics: Mission Logging took too long to complete' over [ " + "30" + " ] seconds: aborting logging.");  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	if (Statistics.Instance.MissionLoggingCompleted) {  		if (State == QuestorState.MissionStatistics) {  			State = QuestorState.Idle;  		}  	}  	break;  case QuestorState.DelayedGotoBase:  	if (DateTime.Now.Subtract (_lastAction).TotalSeconds < (int)Time.DelayedGotoBase_seconds)  		break;  	Logging.Log ("Questor: Heading back to base");  	if (State == QuestorState.DelayedGotoBase) {  		State = QuestorState.GotoBase;  	}  	break;  case QuestorState.Cleanup:  	//  	// this state is needed because forced disconnects   	// and crashes can leave "extra" cargo in the   	// cargo hold that is undesirable and causes  	// problems loading the correct ammo on occasion  	//  	if (Cache.Instance.LootAlreadyUnloaded == false) {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.GotoBase;  		}  		break;  	} else {  		if (State == QuestorState.Cleanup) {  			State = QuestorState.CheckEVEStatus;  		}  		break;  	}  case QuestorState.Start:  	if (first_start && Settings.Instance.MultiAgentSupport) {  		//if you are in wrong station and is not first agent  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		first_start = false;  		break;  	}  	Cache.Instance.OpenWrecks = false;  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.CharacterMode == "salvage") {  			if (State == QuestorState.Start) {  				State = QuestorState.BeginAfterMissionSalvaging;  			}  			break;  		}  		if (Settings.Instance.EnableStorylines && _storyline.HasStoryline ()) {  			Logging.Log ("Questor: Storyline detected' doing storyline.");  			_storyline.Reset ();  			if (State == QuestorState.Start) {  				State = QuestorState.Storyline;  			}  			break;  		}  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		// Update statistic values - these should be cleared in statistics.cs!!!!!!!!!!!!  		Cache.Instance.Wealth = Cache.Instance.DirectEve.Me.Wealth;  		Statistics.Instance.LootValue = 0;  		Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  		Statistics.Instance.StartedMission = DateTime.Now;  		//this especially should be moved to statistics.cs as currently it resets the mission timer even if we could not and did not finish the mission  		Statistics.Instance.FinishedMission = DateTime.MinValue;  		Cache.Instance.MissionName = string.Empty;  		Statistics.Instance.LostDrones = 0;  		Statistics.Instance.AmmoConsumption = 0;  		Statistics.Instance.AmmoValue = 0;  		Statistics.Instance.MissionLoggingCompleted = false;  		Cache.Instance.DroneStatsWritten = false;  		Cache.Instance.panic_attempts_this_mission = 0;  		Cache.Instance.lowest_shield_percentage_this_mission = 101;  		Cache.Instance.lowest_armor_percentage_this_mission = 101;  		Cache.Instance.lowest_capacitor_percentage_this_mission = 101;  		Cache.Instance.repair_cycle_time_this_mission = 0;  		Cache.Instance.TimeSpentReloading_seconds = 0;  		// this will need to be added to whenever we reload or switch ammo  		Cache.Instance.TimeSpentInMission_seconds = 0;  		// from landing on grid (loading mission actions) to going to base (changing to gotobase state)  		Cache.Instance.TimeSpentInMissionInRange = 0;  		// time spent totally out of range' no targets  		Cache.Instance.TimeSpentInMissionOutOfRange = 0;  		// time spent in range - with targets to kill (or no targets?!)  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (Cache.Instance.mission != null) {  			// Update loyalty points again (the first time might return -1)  			Statistics.Instance.LoyaltyPoints = Cache.Instance.Agent.LoyaltyPoints;  			Cache.Instance.MissionName = Cache.Instance.mission.Name;  		}  		_agentInteraction.State = AgentInteractionState.Idle;  		if (State == QuestorState.Start) {  			State = QuestorState.Arm;  		}  		return;  	}  	if (_agentInteraction.State == AgentInteractionState.ChangeAgent) {  		_agentInteraction.State = AgentInteractionState.Idle;  		ValidateSettings ();  		if (State == QuestorState.Start) {  			State = QuestorState.Switch;  		}  		break;  	}  	break;  case QuestorState.Switch:  	if (_switch.State == SwitchShipState.Idle) {  		Logging.Log ("Switch: Begin");  		_switch.State = SwitchShipState.Begin;  	}  	_switch.ProcessState ();  	if (_switch.State == SwitchShipState.Done) {  		_switch.State = SwitchShipState.Idle;  		if (State == QuestorState.Switch) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Arm:  	if (_arm.State == ArmState.Idle) {  		if (Cache.Instance.CourierMission)  			_arm.State = ArmState.SwitchToTransportShip;  		else {  			Logging.Log ("Arm: Begin");  			_arm.State = ArmState.Begin;  			// Load right ammo based on mission  			_arm.AmmoToLoad.Clear ();  			_arm.AmmoToLoad.AddRange (_agentInteraction.AmmoToLoad);  		}  	}  	_arm.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Arm.State = " + _arm.State);  	if (_arm.State == ArmState.NotEnoughAmmo) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughAmmo");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.NotEnoughDrones) {  		// we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		// we may be out of drones/ammo but disconnecting/reconnecting will not fix that so update the timestamp  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Arm: Armstate.NotEnoughDrones");  		_arm.State = ArmState.Idle;  		if (State == QuestorState.Arm) {  			State = QuestorState.Error;  		}  	}  	if (_arm.State == ArmState.Done) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		_arm.State = ArmState.Idle;  		_drones.State = DroneState.WaitingForTargets;  		if (Cache.Instance.CourierMission) {  			if (State == QuestorState.Arm) {  				State = QuestorState.CourierMission;  			}  		} else {  			if (State == QuestorState.Arm) {  				State = QuestorState.LocalWatch;  			}  		}  	}  	break;  case QuestorState.LocalWatch:  	if (Settings.Instance.UseLocalWatch) {  		_lastLocalWatchAction = DateTime.Now;  		if (Cache.Instance.Local_safe (Settings.Instance.LocalBadStandingPilotsToTolerate' Settings.Instance.LocalBadStandingLevelToConsiderBad)) {  			Logging.Log ("Questor.LocalWatch: local is clear");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WarpOutStation;  			}  		} else {  			Logging.Log ("Questor.LocalWatch: Bad standings pilots in local: We will stay 5 minutes in the station and then we will check if it is clear again");  			if (State == QuestorState.LocalWatch) {  				State = QuestorState.WaitingforBadGuytoGoAway;  			}  			Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  			Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		}  	} else {  		if (State == QuestorState.LocalWatch) {  			State = QuestorState.WarpOutStation;  		}  	}  	break;  case QuestorState.WaitingforBadGuytoGoAway:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	if (DateTime.Now.Subtract (_lastLocalWatchAction).TotalMinutes < (int)Time.WaitforBadGuytoGoAway_minutes)  		break;  	if (State == QuestorState.WaitingforBadGuytoGoAway) {  		State = QuestorState.LocalWatch;  	}  	break;  case QuestorState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	//var _bookmark = Cache.Instance.BookmarksByLabel(Settings.Instance.bookmarkWarpOut + "-" + Cache.Instance.CurrentAgent ?? "").OrderBy(b => b.CreatedOn).FirstOrDefault();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (State == QuestorState.WarpOutStation) {  				State = QuestorState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (State == QuestorState.WarpOutStation) {  			State = QuestorState.GotoMission;  		}  	}  	break;  case QuestorState.GotoMission:  	Statistics.Instance.MissionLoggingCompleted = false;  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != Cache.Instance.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (Cache.Instance.AgentId' "Encounter"));  	//if (missionDestination == null)  	//{  	//    Logging.Log("Invalid bookmark loop! Mission Controller: Error");  	//    State = QuestorState.Error;  	//}  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GotoMission: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoMission) {  			State = QuestorState.ExecuteMission;  		}  		// Seeing as we just warped to the mission' start the mission controller  		_missionController.State = MissionControllerState.Start;  		_combat.State = CombatState.CheckTargets;  		_traveler.Destination = null;  	}  	break;  case QuestorState.CombatHelper:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	break;  case QuestorState.Scanning:  	_localwatch.ProcessState ();  	_scanInteraction.ProcessState ();  	if (_scanInteraction.State == ScanInteractionState.Idle)  		_scanInteraction.State = ScanInteractionState.Scan;  	/*                     if(_scanInteraction.State == ScanInteractionState.Done)                         State = QuestorState.CombatHelper_anomaly;                     */break;  case QuestorState.CombatHelper_anomaly:  	Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  	Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_localwatch.ProcessState ();  	break;  case QuestorState.ExecuteMission:  	watch.Reset ();  	watch.Start ();  	_combat.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Combat.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Combat.State = " + _combat.State);  	watch.Reset ();  	watch.Start ();  	_drones.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Drones.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Drones.State = " + _drones.State);  	watch.Reset ();  	watch.Start ();  	_salvage.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("Salvage.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("Salvage.State = " + _salvage.State);  	watch.Reset ();  	watch.Start ();  	_missionController.ProcessState ();  	watch.Stop ();  	if (Settings.Instance.DebugPerformance)  		Logging.Log ("MissionController.ProcessState took " + watch.ElapsedMilliseconds + "ms");  	if (Settings.Instance.DebugStates)  		Logging.Log ("MissionController.State = " + _missionController.State);  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		Logging.Log ("Combat: Out of Ammo!");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	if (_missionController.State == MissionControllerState.Done) {  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		Logging.Log ("MissionController: Error");  		if (State == QuestorState.ExecuteMission) {  			State = QuestorState.GotoBase;  		}  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  	}  	break;  case QuestorState.GotoBase:  	// anti bump  	var structure = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure).OrderBy (t => t.Distance).FirstOrDefault ();  	if (Cache.Instance.InSpace && Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe))//Clear Warp Scramblers (if any)  	 {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (Cache.Instance.InSpace && structure != null && structure.Distance < (int)Distance.TooCloseToStructure)//orbit structures if they are too close' so we have a better chance of not bumping into them at warp  	 {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: We are too close! Initiating Orbit of [" + structure.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "] so that we don't get stuck on it");  			_lastOrbit = DateTime.Now;  		}  	} else//if any scramblers have been cleared and we aren't too close to any structures' set destination and warp out   	 {  		var baseDestination = _traveler.Destination as StationDestination;  		if (baseDestination == null || baseDestination.StationId != Cache.Instance.Agent.StationId)  			_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  		if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid))//fail safe just in case something scrambles you at the last second  		 {  			Logging.Log ("GotoBase: Priority targets found' engaging!");  			_combat.ProcessState ();  		} else {  			if (Cache.Instance.InSpace && Cache.Instance.ActiveDrones.Count () > 0 && DateTime.Now.Subtract (_lastDroneRecall).TotalSeconds > 30) {  				Logging.Log ("GotoBase: We are not scrambled and will be warping soon: pulling drones");  				// Tell the drones module to retract drones  				Cache.Instance.IsMissionPocketDone = true;  				_lastDroneRecall = DateTime.Now;  			}  		}  		_traveler.ProcessState ();  		if (Settings.Instance.DebugStates) {  			Logging.Log ("Traveler.State = " + _traveler.State);  		}  		if (_traveler.State == TravelerState.AtDestination) {  			Cache.Instance.GotoBaseNow = false;  			//we are there - turn off the 'forced' gotobase  			Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  			if (_missionController.State == MissionControllerState.Error) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.Error;  				}  			} else if (_combat.State != CombatState.OutOfAmmo && Cache.Instance.mission != null && Cache.Instance.mission.State == (int)MissionState.Accepted) {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.CompleteMission;  				}  			} else {  				if (State == QuestorState.GotoBase) {  					State = QuestorState.UnloadLoot;  				}  			}  			_traveler.Destination = null;  		}  	}  	break;  case QuestorState.CheckEVEStatus:  	// get the current process  	Process currentProcess = System.Diagnostics.Process.GetCurrentProcess ();  	// get the physical mem usage (this only runs between missions)  	Cache.Instance.totalMegaBytesOfMemoryUsed = ((currentProcess.WorkingSet64 / 1024) / 1024);  	Logging.Log ("Questor: EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  	// If Questor window not visible' schedule a restart of questor in the uplink so that the GUI will start normally  	if (!m_Parent.Visible && CloseQuestorflag)//GUI isn't visible and CloseQuestorflag is true' so that his code block only runs once  	 {  		CloseQuestorflag = false;  		//m_Parent.Visible = true; //this does not work for some reason - innerspace bug?  		Cache.Instance.ReasonToStopQuestor = "The Questor GUI is not visible: did EVE get restarted due to a crash or lag?";  		Logging.Log (Cache.Instance.ReasonToStopQuestor);  		Cache.Instance.CloseQuestorCMDLogoff = false;  		Cache.Instance.CloseQuestorCMDExitGame = true;  		Cache.Instance.SessionState = "Exiting";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.CloseQuestor;  		}  		return;  	} else if (Cache.Instance.totalMegaBytesOfMemoryUsed > (Settings.Instance.EVEProcessMemoryCeiling - 50) && Settings.Instance.EVEProcessMemoryCeilingLogofforExit != "") {  		Logging.Log ("Questor: Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB");  		Cache.Instance.ReasonToStopQuestor = "Memory usage is above the EVEProcessMemoryCeiling threshold. EVE instance: totalMegaBytesOfMemoryUsed - " + Cache.Instance.totalMegaBytesOfMemoryUsed + " MB";  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "logoff") {  			Cache.Instance.CloseQuestorCMDLogoff = true;  			Cache.Instance.CloseQuestorCMDExitGame = false;  			Cache.Instance.SessionState = "LoggingOff";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		if (Settings.Instance.EVEProcessMemoryCeilingLogofforExit == "exit") {  			Cache.Instance.CloseQuestorCMDLogoff = false;  			Cache.Instance.CloseQuestorCMDExitGame = true;  			Cache.Instance.SessionState = "Exiting";  			if (State == QuestorState.CheckEVEStatus) {  				State = QuestorState.CloseQuestor;  			}  			return;  		}  		Logging.Log ("Questor: EVEProcessMemoryCeilingLogofforExit was not set to exit or logoff - doing nothing ");  		return;  	} else {  		Cache.Instance.SessionState = "Running";  		if (State == QuestorState.CheckEVEStatus) {  			State = QuestorState.Start;  		}  	}  	break;  case QuestorState.CloseQuestor:  	if (!Cache.Instance.CloseQuestorCMDLogoff && !Cache.Instance.CloseQuestorCMDExitGame) {  		Cache.Instance.CloseQuestorCMDExitGame = true;  	}  	if (_traveler.State == TravelerState.Idle) {  		Logging.Log ("QuestorState.CloseQuestor: Entered Traveler - making sure we will be docked at Home Station");  	}  	// anti bump  	var structure2 = Cache.Instance.Entities.Where (i => i.GroupId == (int)Group.LargeCollidableStructure || i.GroupId == (int)Group.SpawnContainer).FirstOrDefault ();  	if (Cache.Instance.TargetedBy.Any (t => t.IsWarpScramblingMe)) {  		_combat.ProcessState ();  		_drones.ProcessState ();  	} else if (structure2 != null && structure2.Distance < (int)Distance.TooCloseToStructure) {  		if ((DateTime.Now.Subtract (_lastOrbit).TotalSeconds > 15)) {  			structure2.Orbit ((int)Distance.SafeDistancefromStructure);  			Logging.Log ("Questor: GotoBase: initiating Orbit of [" + structure2.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");  			_lastOrbit = DateTime.Now;  		}  	}  	var baseDestination2 = _traveler.Destination as StationDestination;  	if (baseDestination2 == null || baseDestination2.StationId != Cache.Instance.Agent.StationId)  		_traveler.Destination = new StationDestination (Cache.Instance.Agent.SolarSystemId' Cache.Instance.Agent.StationId' Cache.Instance.DirectEve.GetLocationName (Cache.Instance.Agent.StationId));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("QuestorState.CloseQuestor: GoToBase: Priority targets found' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (Settings.Instance.DebugStates) {  		Logging.Log ("Traveler.State = " + _traveler.State);  	}  	if (_traveler.State == TravelerState.AtDestination) {  		//Logging.Log("QuestorState.CloseQuestor: At Station: Docked");  		if (Settings.Instance.SessionsLog)// if false we do not write a sessionlog' doubles as a flag so we don't write the sessionlog more than once  		 {  			//  			// prepare the Questor Session Log - keeps track of starts' restarts and exits' and hopefully the reasons  			//  			// Get the path  			if (!Directory.Exists (Settings.Instance.SessionsLogPath))  				Directory.CreateDirectory (Settings.Instance.SessionsLogPath);  			Cache.Instance.SessionIskPerHrGenerated = ((int)Cache.Instance.SessionIskGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLootPerHrGenerated = ((int)Cache.Instance.SessionLootGenerated / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionLPPerHrGenerated = (((int)Cache.Instance.SessionLPGenerated * (int)Settings.Instance.IskPerLP) / (DateTime.Now.Subtract (_questorStarted).TotalMinutes / 60));  			Cache.Instance.SessionTotalPerHrGenerated = ((int)Cache.Instance.SessionIskPerHrGenerated + (int)Cache.Instance.SessionLootPerHrGenerated + (int)Cache.Instance.SessionLPPerHrGenerated);  			Logging.Log ("QuestorState.CloseQuestor: Writing Session Data [1]");  			// Write the header  			if (!File.Exists (Settings.Instance.SessionsLogFile))  				File.AppendAllText (Settings.Instance.SessionsLogFile' "Date;RunningTime;SessionState;LastMission;WalletBalance;MemoryUsage;Reason;IskGenerated;LootGenerated;LPGenerated;Isk/Hr;Loot/Hr;LP/HR;Total/HR;\r\n");  			// Build the line  			var line = DateTime.Now + ";";  			// Date  			line += Cache.Instance.SessionRunningTime + ";";  			// RunningTime  			line += Cache.Instance.SessionState + ";";  			// SessionState  			line += Cache.Instance.MissionName + ";";  			// LastMission  			line += ((int)Cache.Instance.DirectEve.Me.Wealth + ";");  			// WalletBalance  			line += ((int)Cache.Instance.totalMegaBytesOfMemoryUsed + ";");  			// MemoryUsage  			line += Cache.Instance.ReasonToStopQuestor + ";";  			// Reason to Stop Questor  			line += Cache.Instance.SessionIskGenerated + ";";  			// Isk Generated This Session  			line += Cache.Instance.SessionLootGenerated + ";";  			// Loot Generated This Session  			line += Cache.Instance.SessionLPGenerated + ";";  			// LP Generated This Session  			line += Cache.Instance.SessionIskPerHrGenerated + ";";  			// Isk Generated per hour this session  			line += Cache.Instance.SessionLootPerHrGenerated + ";";  			// Loot Generated per hour This Session  			line += Cache.Instance.SessionLPPerHrGenerated + ";";  			// LP Generated per hour This Session  			line += Cache.Instance.SessionTotalPerHrGenerated + ";\r\n";  			// Total Per Hour This Session  			// The mission is finished  			Logging.Log (line);  			File.AppendAllText (Settings.Instance.SessionsLogFile' line);  			Logging.Log ("Questor: Writing to session log [ " + Settings.Instance.SessionsLogFile);  			Logging.Log ("Questor is stopping because: " + Cache.Instance.ReasonToStopQuestor);  			Settings.Instance.SessionsLog = false;  			//so we don't write the sessionlog more than once per session  		}  		if (Settings.Instance.AutoStart) {  			if (Cache.Instance.CloseQuestorCMDLogoff) {  				if (CloseQuestorflag) {  					Logging.Log ("Questor: We are in station: Logging off EVE: In theory eve and questor will restart on their own when the client comes back up");  					LavishScript.ExecuteCommand ("uplink echo Logging off EVE:  \\\"${Game}\\\" \\\"${Profile}\\\"");  					Logging.Log ("Questor: you can change this option by setting the wallet and eveprocessmemoryceiling options to use exit instead of logoff: see the settings.xml file");  					Logging.Log ("Questor: Logging Off eve in 15 seconds.");  					CloseQuestorflag = false;  					_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  				}  				if (_CloseQuestorDelay.AddSeconds (-10) < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve in 10 seconds");  				}  				if (_CloseQuestorDelay < DateTime.Now) {  					Logging.Log ("Questor: Exiting eve now.");  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				}  				Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdLogOff);  				break;  			}  			if (Cache.Instance.CloseQuestorCMDExitGame) {  				//Logging.Log("Questor: We are in station: Exit option has been configured.");  				if ((Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) && (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)) {  					Logging.Log ("Questor: We are in station: Don't be silly you cant use both the CloseQuestorCMDUplinkIsboxerProfile and the CloseQuestorCMDUplinkIsboxerProfile setting' choose one");  				} else {  					if (Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile)//if configured as true we will use the innerspace profile to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkInnerspaceProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this innerspace profile session");  							LavishScript.ExecuteCommand ("uplink exec timedcommand 350 open \\\"${Game}\\\" \\\"${Profile}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new innerspace session can take over");  							Logging.Log ("Questor: Exiting eve in 15 seconds.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet)//if configured as true we will use isboxer to restart this session  					 {  						//Logging.Log("Questor: We are in station: CloseQuestorCMDUplinkIsboxerProfile is true");  						if (CloseQuestorCMDUplink) {  							Logging.Log ("Questor: We are in station: Starting a timer in the innerspace uplink to restart this isboxer character set");  							LavishScript.ExecuteCommand ("uplink timedcommand 350 runscript isboxer -launch \\\"${ISBoxerCharacterSet}\\\"");  							Logging.Log ("Questor: Done: quitting this session so the new isboxer session can take over");  							Logging.Log ("Questor: We are in station: Exiting eve.");  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					} else if (!Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile && !Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet) {  						Logging.Log ("Questor: CloseQuestorCMDUplinkInnerspaceProfile and CloseQuestorCMDUplinkIsboxerProfile both false");  						if (CloseQuestorCMDUplink) {  							CloseQuestorCMDUplink = false;  							_CloseQuestorDelay = DateTime.Now.AddSeconds ((int)Time.CloseQuestorDelayBeforeExit_seconds);  						}  						if ((_CloseQuestorDelay.AddSeconds (-10) == DateTime.Now) && (!CloseQuestor10SecWarningDone)) {  							CloseQuestor10SecWarningDone = true;  							Logging.Log ("Questor: Exiting eve in 10 seconds");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						if (_CloseQuestorDelay < DateTime.Now) {  							Logging.Log ("Questor: Exiting eve now.");  							Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  						}  						return;  					}  				}  			}  		}  		Logging.Log ("Autostart is false: Stopping EVE with quit command");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdQuitGame);  		break;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		if (Settings.Instance.DroneStatsLog) {  			// Lost drone statistics  			// (inelegantly located here so as to avoid the necessity to switch to a combat ship after salvaging)  			if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) {  				var droneBay = Cache.Instance.DirectEve.GetShipsDroneBay ();  				if (droneBay.Window == null) {  					Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenDroneBayOfActiveShip);  					break;  				}  				if (!droneBay.IsReady)  					break;  				if (Cache.Instance.InvTypesById.ContainsKey (Settings.Instance.DroneTypeId)) {  					var drone = Cache.Instance.InvTypesById [Settings.Instance.DroneTypeId];  					Statistics.Instance.LostDrones = (int)Math.Floor ((droneBay.Capacity - droneBay.UsedCapacity) / drone.Volume);  					Logging.Log ("DroneStats: Logging the number of lost drones: " + Statistics.Instance.LostDrones.ToString ());  					if (!File.Exists (Settings.Instance.DroneStatslogFile))  						File.AppendAllText (Settings.Instance.DroneStatslogFile' "Mission;Number of lost drones\r\n");  					var droneline = Cache.Instance.MissionName + ";";  					droneline += ((int)Statistics.Instance.LostDrones) + ";\r\n";  					File.AppendAllText (Settings.Instance.DroneStatslogFile' droneline);  					Cache.Instance.DroneStatsWritten = true;  				} else {  					Logging.Log ("DroneStats: Couldn't find the drone TypeID specified in the settings.xml; this shouldn't happen!");  				}  			}  		}  		// Lost drone statistics stuff ends here  		// Ammo Consumption statistics  		// Is cargo open?  		var cargoship = Cache.Instance.DirectEve.GetShipsCargo ();  		if (cargoship.Window == null) {  			// No' command it to open  			Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  			break;  		}  		if (!cargoship.IsReady)  			break;  		var correctAmmo1 = Settings.Instance.Ammo.Where (a => a.DamageType == Cache.Instance.DamageType);  		var AmmoCargo = cargoship.Items.Where (i => correctAmmo1.Any (a => a.TypeId == i.TypeId));  		foreach (var item in AmmoCargo) {  			var Ammo1 = Settings.Instance.Ammo.Where (a => a.TypeId == item.TypeId).FirstOrDefault ();  			var AmmoType = Cache.Instance.InvTypesById [item.TypeId];  			Statistics.Instance.AmmoConsumption = (Ammo1.Quantity - item.Quantity);  			Statistics.Instance.AmmoValue = ((int?)AmmoType.MedianSell ?? 0) * (int)Statistics.Instance.AmmoConsumption;  		}  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		// Cache.Instance.MissionName = String.Empty;  // Do Not clear the 'current' mission name until after we have done the mission logging  		_agentInteraction.State = AgentInteractionState.Idle;  		if (Cache.Instance.CourierMission) {  			Cache.Instance.CourierMission = false;  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.Idle;  			}  		} else {  			if (State == QuestorState.CompleteMission) {  				State = QuestorState.UnloadLoot;  			}  		}  		return;  	}  	break;  case QuestorState.UnloadLoot:  	if (_unloadLoot.State == UnloadLootState.Idle) {  		Logging.Log ("UnloadLoot: Begin");  		_unloadLoot.State = UnloadLootState.Begin;  	}  	_unloadLoot.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("UnloadLoot.State = " + _unloadLoot.State);  	if (_unloadLoot.State == UnloadLootState.Done) {  		Logging.Log ("UnloadLoot: Done");  		Cache.Instance.LootAlreadyUnloaded = true;  		_unloadLoot.State = UnloadLootState.Idle;  		// Update total loot value  		Statistics.Instance.LootValue += (int)_unloadLoot.LootValue;  		Cache.Instance.mission = Cache.Instance.GetAgentMission (Cache.Instance.AgentId);  		if (_combat.State != CombatState.OutOfAmmo && Settings.Instance.AfterMissionSalvaging && Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").Count > 0 && (Cache.Instance.mission == null || Cache.Instance.mission.State == (int)MissionState.Offered)) {  			Statistics.Instance.FinishedMission = DateTime.Now;  			if (Settings.Instance.SalvageMultpleMissionsinOnePass)// Salvage only after multiple missions have been completed  			 {  				//if we can still complete another mission before the Wrecks disappear and still have time to salvage  				if (DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes > ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes)) {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are after mission salvaging again because it has been at least [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.BeginAfterMissionSalvaging;  					}  				} else {  					Logging.Log ("Questor: UnloadLoot: The last after mission salvaging session was [" + DateTime.Now.Subtract (Statistics.Instance.FinishedSalvaging).TotalMinutes + "] ago ");  					Logging.Log ("Questor: UnloadLoot: we are going to the next mission because it has not been [" + ((int)Time.WrecksDisappearAfter_minutes - (int)Time.AverageTimeToCompleteAMission_minutes - (int)Time.AverageTimetoSalvageMultipleMissions_minutes) + "] min since the last session. ");  					Statistics.Instance.FinishedMission = DateTime.Now;  					if (State == QuestorState.UnloadLoot) {  						State = QuestorState.Idle;  					}  				}  			} else// Normal Salvaging  			 {  				if (State == QuestorState.UnloadLoot) {  					State = QuestorState.BeginAfterMissionSalvaging;  				}  			}  			return;  		} else if (_combat.State == CombatState.OutOfAmmo) {  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Start;  			}  			return;  		} else//If we aren't after mission salvaging and we aren't out of ammo we must be done.   		 {  			Statistics.Instance.FinishedMission = DateTime.Now;  			Statistics.Instance.StartedSalvaging = DateTime.Now;  			Statistics.Instance.FinishedSalvaging = DateTime.Now;  			if (State == QuestorState.UnloadLoot) {  				State = QuestorState.Idle;  			}  			return;  		}  	}  	break;  case QuestorState.BeginAfterMissionSalvaging:  	Statistics.Instance.StartedSalvaging = DateTime.Now;  	_GatesPresent = false;  	Cache.Instance.OpenWrecks = true;  	if (_arm.State == ArmState.Idle)  		_arm.State = ArmState.SwitchToSalvageShip;  	_arm.ProcessState ();  	if (_arm.State == ArmState.Done) {  		_arm.State = ArmState.Idle;  		var bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ").OrderBy (b => b.CreatedOn).FirstOrDefault ();  		if (bookmark == null) {  			if (State == QuestorState.BeginAfterMissionSalvaging) {  				State = QuestorState.Idle;  			}  			return;  		}  		if (State == QuestorState.BeginAfterMissionSalvaging) {  			State = QuestorState.GotoSalvageBookmark;  		}  		_traveler.Destination = new BookmarkDestination (bookmark);  		return;  	}  	break;  case QuestorState.GotoSalvageBookmark:  	_traveler.ProcessState ();  	string target = "Acceleration Gate";  	var targets = Cache.Instance.EntitiesByName (target);  	if (_traveler.State == TravelerState.AtDestination || GateInSalvage ()) {  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (State == QuestorState.GotoSalvageBookmark) {  			State = QuestorState.Salvage;  		}  		_traveler.Destination = null;  		return;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.Salvage:  	var SalvageCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	Cache.Instance.SalvageAll = true;  	Cache.Instance.OpenWrecks = true;  	// Is our cargo window open?  	if (SalvageCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageCargo.IsReady && (SalvageCargo.Capacity - SalvageCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full' go to base to unload");  		if (State == QuestorState.Salvage) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		bool GatesInRoom = GateInSalvage ();  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (!GatesInRoom && _GatesPresent)  				// if there were gates' but we've gone through them all' delete all bookmarks  				bookmark = bookmarks.FirstOrDefault ();  			else if (GatesInRoom)  				break;  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0 && !GatesInRoom) {  			Logging.Log ("Salvage: We have salvaged all bookmarks' go to base");  			Cache.Instance.SalvageAll = false;  			if (State == QuestorState.Salvage) {  				Statistics.Instance.FinishedSalvaging = DateTime.Now;  				State = QuestorState.GotoBase;  			}  			return;  		} else {  			if (!GatesInRoom) {  				Logging.Log ("Salvage: Go to the next salvage bookmark");  				if (State == QuestorState.Salvage) {  					State = QuestorState.GotoSalvageBookmark;  				}  				_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			} else if (Settings.Instance.UseGatesInSalvage) {  				Logging.Log ("Salvage: Acceleration gate found - moving to next pocket");  				if (State == QuestorState.Salvage) {  					State = QuestorState.SalvageUseGate;  				}  			} else {  				Logging.Log ("Salvage: Acceleration gate found' useGatesInSalvage set to false - Returning to base");  				if (State == QuestorState.Salvage) {  					Statistics.Instance.FinishedSalvaging = DateTime.Now;  					State = QuestorState.GotoBase;  				}  				_traveler.Destination = null;  			}  		}  		break;  	}  	var closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (Math.Round (closestWreck.Distance' 0) > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance) {  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  			}  		} else  			closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: Salvage: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		//Logging.Log("number of max cache ship: " + Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets);  		//Logging.Log("number of max cache me: " + Cache.Instance.DirectEve.Me.MaxLockedTargets);  		//Logging.Log("number of max math.min: " + _salvage.MaximumWreckTargets);  	} finally {  		ApplySettings ();  	}  	break;  //case QuestorState.ScoopStep1SetupBookmarkLocation:  //    //if (_arm.State == ArmState.Idle)  //    //    _arm.State = ArmState.SwitchToLootWrecksShip;  //    //_arm.ProcessState();  //    //if (_arm.State == ArmState.Done)  //    //{  //    _arm.State = ArmState.Idle;  //    var Scoopbookmark = Cache.Instance.BookmarksByLabel("ScoopSpot").OrderBy(b => b.CreatedOn).FirstOrDefault();  //    if (Scoopbookmark == null)  //    {  //        Logging.Log("Bookmark named [ ScoopSpot ] not found");  //        State = QuestorState.Idle;  //        break;  //    }  //  //    State = QuestorState.ScoopStep2GotoScoopBookmark;  //    _traveler.Destination = new BookmarkDestination(Scoopbookmark);  //  //    //}  //    break;  //case QuestorState.ScoopStep2GotoScoopBookmark:  //  //  //    _traveler.ProcessState();  //    if (_traveler.State == TravelerState.AtDestination)  //    {  //        State = QuestorState.ScoopStep3WaitForWrecks;  //        _scoop.State = ScoopState.LootHostileWrecks;  //        _traveler.Destination = null;  //    }  //  //    if (Settings.Instance.DebugStates)  //        Logging.Log("Traveler.State = " + _traveler.State);  //    break;  //  //case QuestorState.ScoopStep3WaitForWrecks:  //    // We are not in space yet' wait...  //    if (!Cache.Instance.InSpace)  //        break;  //  //    //  //    // Loot All wrecks on grid of 'here'  //    //  //    var MyScoopshipCargo = Cache.Instance.DirectEve.GetShipsCargo();  //  //    // Is our cargo window open?  //    if (MyScoopshipCargo.Window == null)  //    {  //        // No' command it to open  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);  //        break;  //    }  //  //    //if (MyScoopshipCargo.IsReady && (MyScoopshipCargo.Capacity - MyScoopshipCargo.UsedCapacity) < 3500)  //    //{  //    //Logging.Log("Salvage: We are full' go to base to unload");  //    //this needs to be changed to dock at the closest station  //    //State = QuestorState . DockAtNearestStation;  //    //    break;  //    //}  //  //    if (Cache.Instance.UnlootedContainers.Count() == 0)  //    {  //        break;  //    }  //    var closestWreck2 = Cache.Instance.UnlootedWrecksAndSecureCans.First();  //    if (closestWreck2.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck2.Id))  //    {  //        if (closestWreck2.Distance > (int)Distance.WarptoDistance)  //        {  //            closestWreck2.WarpTo();  //            break;  //        }  //        else  //            closestWreck2.Approach();  //    }  //    else if (closestWreck2.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null)  //        Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);  //        Logging.Log("Questor: ScoopStep3WaitForWrecks: Stop ship' ClosestWreck [" + closestWreck2.Distance + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  //  //    try  //    {  //        // Overwrite settings' as the 'normal' settings do not apply  //        _scoop.MaximumWreckTargets = Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  //        _scoop.ReserveCargoCapacity = 5;  //        _scoop.ProcessState();  //    }  //    finally  //    {  //        ApplySettings();  //    }  //    break;  case QuestorState.SalvageUseGate:  	Cache.Instance.OpenWrecks = true;  	target = "Acceleration Gate";  	targets = Cache.Instance.EntitiesByName (target);  	if (targets == null || targets.Count () == 0) {  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.GotoSalvageBookmark;  		}  		return;  	}  	_lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;  	_lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;  	_lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;  	var closest = targets.OrderBy (t => t.Distance).First ();  	if (closest.Distance < (int)Distance.DecloakRange) {  		Logging.Log ("Salvage: Acceleration gate found - GroupID=" + closest.GroupId);  		// Activate it and move to the next Pocket  		closest.Activate ();  		// Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action  		Logging.Log ("Salvage: Activate [" + closest.Name + "] and change state to 'NextPocket'");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.SalvageNextPocket;  		}  		_lastPulse = DateTime.Now;  		return;  	} else if (closest.Distance < (int)Distance.WarptoDistance) {  		// Move to the target  		if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id) {  			Logging.Log ("Salvage: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.Approach ();  		}  	} else {  		// Probably never happens  		if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  			Logging.Log ("Salvage: Warping to [" + closest.Name + "] which is [" + Math.Round (closest.Distance / 1000' 0) + "k away]");  			closest.WarpTo ();  			_lastWarpTo = DateTime.Now;  		}  	}  	_lastPulse = DateTime.Now.AddSeconds (10);  	break;  case QuestorState.SalvageNextPocket:  	Cache.Instance.OpenWrecks = true;  	var distance = Cache.Instance.DistanceFromMe (_lastX' _lastY' _lastZ);  	if (distance > (int)Distance.NextPocketDistance) {  		//we know we are connected here...  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		Logging.Log ("Salvage: We've moved to the next Pocket [" + Math.Round (distance / 1000' 0) + "k away]");  		if (State == QuestorState.SalvageUseGate) {  			State = QuestorState.Salvage;  		}  		return;  	} else if (DateTime.Now.Subtract (_lastPulse).TotalMinutes > 2) {  		Logging.Log ("Salvage: We've timed out' retry last action");  		// We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.SalvageUseGate;  		}  		return;  	}  	break;  case QuestorState.Storyline:  	_storyline.ProcessState ();  	if (_storyline.State == StorylineState.Done) {  		Logging.Log ("Questor: We have completed the storyline' returning to base");  		if (State == QuestorState.Storyline) {  			State = QuestorState.GotoBase;  		}  		break;  	}  	break;  case QuestorState.CourierMission:  	if (_courier.State == CourierMissionState.Idle)  		_courier.State = CourierMissionState.GotoPickupLocation;  	_courier.ProcessState ();  	if (_courier.State == CourierMissionState.Done) {  		_courier.State = CourierMissionState.Idle;  		Cache.Instance.CourierMission = false;  		if (State == QuestorState.SalvageNextPocket) {  			State = QuestorState.GotoBase;  		}  	}  	break;  case QuestorState.Debug_CloseQuestor:  	//Logging.Log("ISBoxerCharacterSet: " + Settings.Instance.Lavish_ISBoxerCharacterSet);  	//Logging.Log("Profile: " + Settings.Instance.Lavish_InnerspaceProfile);  	//Logging.Log("Game: " + Settings.Instance.Lavish_Game);  	Logging.Log ("CloseQuestorCMDUplinkInnerspaceProfile: " + Settings.Instance.CloseQuestorCMDUplinkInnerspaceProfile);  	Logging.Log ("CloseQuestorCMDUplinkISboxerCharacterSet: " + Settings.Instance.CloseQuestorCMDUplinkIsboxerCharacterSet);  	Logging.Log ("walletbalancechangelogoffdelay: " + Settings.Instance.walletbalancechangelogoffdelay);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("walletbalancechangelogoffdelayLogofforExit: " + Settings.Instance.walletbalancechangelogoffdelayLogofforExit);  	Logging.Log ("EVEProcessMemoryCeiling: " + Settings.Instance.EVEProcessMemoryCeiling);  	Logging.Log ("EVEProcessMemoryCielingLogofforExit: " + Settings.Instance.EVEProcessMemoryCeilingLogofforExit);  	if (State == QuestorState.SalvageNextPocket) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.Debug_Windows:  	var windows = Cache.Instance.Windows;  	foreach (var window in windows) {  		Logging.Log ("Debug_Questor_WindowNames: [" + window.Name + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_Windowcaptions: [" + window.Name + window.Caption + "]");  	}  	foreach (var window in windows) {  		Logging.Log ("Debug_WindowTypes: [" + window.Name + window.Type + "]");  	}  	if (State == QuestorState.Debug_Windows) {  		State = QuestorState.Error;  	}  	return;  case QuestorState.SalvageOnly:  	Cache.Instance.OpenWrecks = true;  	var SalvageOnlyCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	// Is our cargo window open?  	if (SalvageOnlyCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		Logging.Log ("Salvage: We have salvaged all bookmarks' waiting.");  		if (State == QuestorState.SalvageOnly) {  			State = QuestorState.Idle;  		}  		Settings.Instance.AutoStart = false;  		Paused = true;  		return;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance' 0) + "] meters away");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnly: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.GotoSalvageOnlyBookmark:  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		if (State == QuestorState.GotoSalvageOnlyBookmark) {  			State = QuestorState.SalvageOnlyBookmarks;  		}  		_traveler.Destination = null;  	}  	if (Settings.Instance.DebugStates)  		Logging.Log ("Traveler.State = " + _traveler.State);  	break;  case QuestorState.SalvageOnlyBookmarks:  	var SalvageOnlyBookmarksCargo = Cache.Instance.DirectEve.GetShipsCargo ();  	if (Cache.Instance.InStation) {  		// We are in a station'  		Logging.Log ("SalvageOnlyBookmarks: We're docked' undocking");  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdExitStation);  	}  	// Is our cargo window open?  	if (SalvageOnlyBookmarksCargo.Window == null) {  		// No' command it to open  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.OpenCargoHoldOfActiveShip);  		break;  	}  	if (Settings.Instance.UnloadLootAtStation && SalvageOnlyBookmarksCargo.IsReady && (SalvageOnlyBookmarksCargo.Capacity - SalvageOnlyBookmarksCargo.UsedCapacity) < 100) {  		Logging.Log ("Salvage: We are full");  		if (State == QuestorState.SalvageOnlyBookmarks) {  			State = QuestorState.Error;  		}  		return;  	}  	if (Cache.Instance.UnlootedContainers.Count () == 0) {  		Logging.Log ("Salvage: Finished salvaging the room");  		var bookmarks = Cache.Instance.BookmarksByLabel (Settings.Instance.BookmarkPrefix + " ");  		do {  			// Remove all bookmarks from address book  			var bookmark = bookmarks.FirstOrDefault (b => Cache.Instance.DistanceFromMe (b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe);  			if (bookmark == null)  				break;  			bookmark.Delete ();  			bookmarks.Remove (bookmark);  		} while (true);  		if (bookmarks.Count == 0) {  			Logging.Log ("Salvage: We have salvaged all bookmarks. Going to nearest station. ");  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoNearestStation;  			}  		} else {  			Logging.Log ("Salvage: Go to the next salvage bookmark");  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  			if (State == QuestorState.SalvageOnlyBookmarks) {  				State = QuestorState.GotoSalvageOnlyBookmark;  			}  			return;  		}  		break;  	}  	closestWreck = Cache.Instance.UnlootedContainers.First ();  	if (closestWreck.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closestWreck.Id)) {  		if (closestWreck.Distance > (int)Distance.WarptoDistance)  			if (DateTime.Now.Subtract (_lastWarpTo).TotalSeconds > 10) {  				Logging.Log ("Salvage: Warping to [" + closestWreck.Name + "] which is [" + Math.Round (closestWreck.Distance / 1000' 0) + "k away]");  				closestWreck.WarpTo ();  				_lastWarpTo = DateTime.Now;  			} else  				closestWreck.Approach ();  	} else if (closestWreck.Distance <= (int)Distance.SafeScoopRange && Cache.Instance.Approaching != null) {  		Cache.Instance.DirectEve.ExecuteCommand (DirectCmd.CmdStopShip);  		Logging.Log ("Questor: SalvageOnlyBookmarks: Stop ship' ClosestWreck [" + Math.Round (closestWreck.Distance' 0) + "] is in scooprange + [" + (int)Distance.SafeScoopRange + "] and we were approaching");  	}  	try {  		// Overwrite settings' as the 'normal' settings do not apply  		_salvage.MaximumWreckTargets = Math.Min (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets);  		_salvage.ReserveCargoCapacity = 80;  		_salvage.LootEverything = true;  		_salvage.ProcessState ();  	} finally {  		ApplySettings ();  	}  	break;  case QuestorState.Traveler:  	Cache.Instance.OpenWrecks = false;  	var destination = Cache.Instance.DirectEve.Navigation.GetDestinationPath ();  	if (destination == null || destination.Count == 0) {  		// should never happen' but still...  		Logging.Log ("QuestorState.Traveler: No destination?");  		if (State == QuestorState.Traveler) {  			State = QuestorState.Error;  		}  		return;  	} else if (destination.Count == 1 && destination.First () == 0)  		destination [0] = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_traveler.Destination == null || _traveler.Destination.SolarSystemId != destination.Last ()) {  		var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where (b => b.LocationId == destination.Last ());  		if (bookmarks != null && bookmarks.Count () > 0)  			_traveler.Destination = new BookmarkDestination (bookmarks.OrderBy (b => b.CreatedOn).First ());  		else {  			Logging.Log ("QuestorState.Traveler: Destination: [" + Cache.Instance.DirectEve.Navigation.GetLocation (destination.Last ()).Name + "]");  			_traveler.Destination = new SolarSystemDestination (destination.Last ());  		}  	} else {  		_traveler.ProcessState ();  		//we know we are connected if we were able to arm the ship - update the lastknownGoodConnectedTime  		//we also assume you are connected during a manual set of questor into travel mode (safe assumption considering someone is at the kb)  		Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;  		Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;  		if (_traveler.State == TravelerState.AtDestination) {  			if (_missionController.State == MissionControllerState.Error) {  				Logging.Log ("QuestorState.Traveler: an error has occurred");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else if (Cache.Instance.InSpace) {  				Logging.Log ("QuestorState.Traveler: Arrived at destination (in space' Questor stopped)");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Error;  				}  				return;  			} else {  				Logging.Log ("QuestorState.Traveler: Arrived at destination");  				if (State == QuestorState.Traveler) {  					State = QuestorState.Idle;  				}  				return;  			}  		}  	}  	break;  case QuestorState.GotoNearestStation:  	var station = Cache.Instance.Stations.OrderBy (x => x.Distance).FirstOrDefault ();  	if (station != null) {  		if (station.Distance > (int)Distance.WarptoDistance) {  			station.WarpToAndDock ();  			if (State == QuestorState.GotoNearestStation) {  				State = QuestorState.Salvage;  			}  			break;  		} else {  			if (station.Distance < 1900) {  				if (DateTime.Now.Subtract (_lastDock).TotalSeconds > 5) {  					station.Dock ();  					_lastDock = DateTime.Now;  				}  			} else {  				if (Cache.Instance.DirectEve.ActiveShip.Entity.Mode == 1) {  					if (Cache.Instance.Approaching.Id != station.Id)  						station.Approach ();  				} else  					station.Approach ();  			}  		}  	} else {  		if (State == QuestorState.GotoNearestStation) {  			State = QuestorState.Error;  		}  	}  	break;  }  
Missing Default,Mono.Options,OptionSet,F:\newReposMay17\Da-Teach_Questor\Questor\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  case OptionValueType.None:  	c.OptionValues.Add (n);  	c.Option.Invoke (c);  	break;  case OptionValueType.Optional:  case OptionValueType.Required:  	ParseValue (v' c);  	break;  }  
Missing Default,Questor.Storylines,GenericCombatStoryline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\GenericCombatStoryline.cs,ExecuteMission,The following switch statement is missing a default case: switch (_state) {  case GenericCombatStorylineState.WarpOutStation:  	var _bookmark = Cache.Instance.BookmarksByLabel (Settings.Instance.bookmarkWarpOut ?? "").OrderByDescending (b => b.CreatedOn).Where (b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).FirstOrDefault ();  	var _solarid = Cache.Instance.DirectEve.Session.SolarSystemId ?? -1;  	if (_bookmark == null) {  		Logging.Log ("WarpOut: No Bookmark");  		if (_state == GenericCombatStorylineState.WarpOutStation) {  			_state = GenericCombatStorylineState.GotoMission;  		}  	} else if (_bookmark.LocationId == _solarid) {  		if (_traveler.Destination == null) {  			Logging.Log ("WarpOut: Warp at " + _bookmark.Title);  			_traveler.Destination = new BookmarkDestination (_bookmark);  			Cache.Instance.DoNotBreakInvul = true;  		}  		_traveler.ProcessState ();  		if (_traveler.State == TravelerState.AtDestination) {  			Logging.Log ("WarpOut: Safe!");  			Cache.Instance.DoNotBreakInvul = false;  			if (_state == GenericCombatStorylineState.WarpOutStation) {  				_state = GenericCombatStorylineState.GotoMission;  			}  			_traveler.Destination = null;  		}  	} else {  		Logging.Log ("WarpOut: No Bookmark in System");  		if (_state == GenericCombatStorylineState.WarpOutStation) {  			_state = GenericCombatStorylineState.GotoMission;  		}  	}  	break;  case GenericCombatStorylineState.GotoMission:  	var missionDestination = _traveler.Destination as MissionBookmarkDestination;  	if (missionDestination == null || missionDestination.AgentId != storyline.AgentId)  		// We assume that this will always work "correctly" (tm)  		_traveler.Destination = new MissionBookmarkDestination (Cache.Instance.GetMissionBookmark (storyline.AgentId' "Encounter"));  	if (Cache.Instance.PriorityTargets.Any (pt => pt != null && pt.IsValid)) {  		Logging.Log ("GenericCombatStoryline: Priority targets found while traveling' engaging!");  		_combat.ProcessState ();  	}  	_traveler.ProcessState ();  	if (_traveler.State == TravelerState.AtDestination) {  		_state = GenericCombatStorylineState.ExecuteMission;  		_traveler.Destination = null;  	}  	break;  case GenericCombatStorylineState.ExecuteMission:  	_combat.ProcessState ();  	_drones.ProcessState ();  	_salvage.ProcessState ();  	_missionController.ProcessState ();  	// If we are out of ammo' return to base' the mission will fail to complete and the bot will reload the ship  	// and try the mission again  	if (_combat.State == CombatState.OutOfAmmo) {  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  		Logging.Log ("GenericCombatStoryline: Out of Ammo!");  		return StorylineState.ReturnToAgent;  	}  	if (_missionController.State == MissionControllerState.Done) {  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  		return StorylineState.ReturnToAgent;  	}  	// If in error state' just go home and stop the bot  	if (_missionController.State == MissionControllerState.Error) {  		// Clear looted containers  		Cache.Instance.LootedContainers.Clear ();  		Logging.Log ("MissionController: Error");  		return StorylineState.ReturnToAgent;  	}  	break;  }  
Missing Default,Questor.Storylines,Storyline,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\Storyline.cs,ProcessState,The following switch statement is missing a default case: switch (State) {  case StorylineState.Idle:  	IdleState ();  	break;  case StorylineState.Arm:  	State = _storyline.Arm (this);  	break;  case StorylineState.GotoAgent:  	GotoAgent (StorylineState.PreAcceptMission);  	break;  case StorylineState.PreAcceptMission:  	State = _storyline.PreAcceptMission (this);  	break;  case StorylineState.AcceptMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		Logging.Log ("AgentInteraction: Start conversation [Start Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.StartMission;  		_agentInteraction.AgentId = AgentId;  		_agentInteraction.ForceAccept = true;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		_agentInteraction.State = AgentInteractionState.Idle;  		// If theres no mission anymore then we're done (we declined it)  		State = Mission == null ? StorylineState.Done : StorylineState.ExecuteMission;  	}  	break;  case StorylineState.ExecuteMission:  	State = _storyline.ExecuteMission (this);  	break;  case StorylineState.ReturnToAgent:  	GotoAgent (StorylineState.CompleteMission);  	break;  case StorylineState.CompleteMission:  	if (_agentInteraction.State == AgentInteractionState.Idle) {  		Logging.Log ("AgentInteraction: Start Conversation [Complete Mission]");  		_agentInteraction.State = AgentInteractionState.StartConversation;  		_agentInteraction.Purpose = AgentInteractionPurpose.CompleteMission;  	}  	_agentInteraction.ProcessState ();  	if (Settings.Instance.DebugStates)  		Logging.Log ("AgentInteraction.State = " + _agentInteraction.State);  	if (_agentInteraction.State == AgentInteractionState.Done) {  		_agentInteraction.State = AgentInteractionState.Idle;  		State = StorylineState.BringSpoilsOfWar;  	}  	break;  case StorylineState.BringSpoilsOfWar:  	BringSpoilsOfWar ();  	break;  case StorylineState.BlacklistAgent:  	_agentBlacklist.Add (AgentId);  	State = StorylineState.Done;  	break;  case StorylineState.Done:  	break;  }  
Missing Default,Questor.Storylines,TransactionDataDelivery,F:\newReposMay17\Da-Teach_Questor\Questor\Storylines\TransactionDataDelivery.cs,ExecuteMission,The following switch statement is missing a default case: switch (_state) {  case TransactionDataDeliveryState.GotoPickupLocation:  	if (GotoMissionBookmark (storyline.AgentId' "Objective (Pick Up)"))  		_state = TransactionDataDeliveryState.PickupItem;  	break;  case TransactionDataDeliveryState.PickupItem:  	if (MoveItem (true))  		_state = TransactionDataDeliveryState.GotoDropOffLocation;  	break;  case TransactionDataDeliveryState.GotoDropOffLocation:  	if (GotoMissionBookmark (storyline.AgentId' "Objective (Drop Off)"))  		_state = TransactionDataDeliveryState.DropOffItem;  	break;  case TransactionDataDeliveryState.DropOffItem:  	if (MoveItem (false))  		return StorylineState.ReturnToAgent;  	break;  }  
