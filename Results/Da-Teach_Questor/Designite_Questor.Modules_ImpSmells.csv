Implementation smell,Namespace,Class,File,Method,Description
Long Method,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The method has 143 lines of code.
Long Method,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The method has 516 lines of code.
Long Method,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ProcessState,The method has 108 lines of code.
Long Method,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The method has 146 lines of code.
Long Method,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The method has 178 lines of code.
Long Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The method has 127 lines of code.
Long Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The method has 146 lines of code.
Long Method,Questor.Modules,SwitchShip,C:\repos\Da-Teach_Questor\Questor.Modules\SwitchShip.cs,ProcessState,The method has 115 lines of code.
Long Method,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The method has 223 lines of code.
Long Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The method has 103 lines of code.
Long Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The method has 125 lines of code.
Long Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The method has 133 lines of code.
Long Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The method has 102 lines of code.
Long Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ProcessState,The method has 134 lines of code.
Long Method,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The method has 207 lines of code.
Long Method,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The method has 167 lines of code.
Long Method,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The method has 200 lines of code.
Long Method,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The method has 332 lines of code.
Long Method,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The method has 254 lines of code.
Complex Method,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,Cyclomatic complexity of the method is 25
Complex Method,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,AcceptMission,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,Cyclomatic complexity of the method is 14
Complex Method,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,LoadMissionActions,Cyclomatic complexity of the method is 11
Complex Method,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,Cyclomatic complexity of the method is 9
Complex Method,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,Cyclomatic complexity of the method is 13
Complex Method,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ReloadAll,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ActivateAction,Cyclomatic complexity of the method is 9
Complex Method,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,Cyclomatic complexity of the method is 11
Complex Method,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,Cyclomatic complexity of the method is 12
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,Cyclomatic complexity of the method is 11
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadAll,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,Cyclomatic complexity of the method is 26
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateStasisWeb,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,Cyclomatic complexity of the method is 20
Complex Method,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,MoveItem,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,Cyclomatic complexity of the method is 10
Complex Method,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,Cyclomatic complexity of the method is 9
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ReloadAll,Cyclomatic complexity of the method is 9
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,Cyclomatic complexity of the method is 11
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,Cyclomatic complexity of the method is 19
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,Cyclomatic complexity of the method is 15
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,Cyclomatic complexity of the method is 23
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,Cyclomatic complexity of the method is 14
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,Cyclomatic complexity of the method is 14
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,Cyclomatic complexity of the method is 8
Complex Method,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,ActivateTractorBeams,Cyclomatic complexity of the method is 10
Complex Method,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,TargetHostileWrecks,Cyclomatic complexity of the method is 17
Complex Method,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,Cyclomatic complexity of the method is 31
Complex Method,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,ActivateTractorBeams,Cyclomatic complexity of the method is 9
Complex Method,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,Cyclomatic complexity of the method is 24
Complex Method,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,Cyclomatic complexity of the method is 33
Complex Method,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,Cyclomatic complexity of the method is 25
Complex Method,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,Cyclomatic complexity of the method is 10
Complex Method,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,Cyclomatic complexity of the method is 14
Long Identifier,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,,The length of the parameter PocketStatsUseIndividualFilesPerPocket is 38.
Long Identifier,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the parameter CommonMissionCompletionItemHangar is 33.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,GetMissionDamageType,The length of the statement  "                var xml = XDocument.Load(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)' "Factions.xml")); " is 120.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The length of the statement  "                        Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh- journalwindows was null: restarting EVE Session"; " is 153.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The length of the statement  "                        Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh - mission was null: restarting EVE Session"; " is 147.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The length of the statement  "                if ((missionName != "Enemies Abound (2 of 5)") || (missionName == "Enemies Abound (2 of 5)" && !Settings.Instance.LowSecMissions)) " is 130.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The length of the statement  "                if (mission.State == (int)MissionState.Offered && (mission.Type == "Mining" || mission.Type == "Trade" || (mission.Type == "Courier" && missionName != "Enemies Abound (2 of 5)"))) " is 179.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The length of the statement  "                        var damageTypes = missionXml.XPathSelectElements("//damagetype").Select(e => (DamageType)Enum.Parse(typeof(DamageType)' (string)e' true)); " is 138.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,AcceptMission,The length of the statement  "                        Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 132.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The length of the statement  "                        Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings); " is 136.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The length of the statement  "                        Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again."); " is 140.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,CheckFaction,The length of the statement  "                var xml = XDocument.Load(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)' "Factions.xml")); " is 120.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,CheckFaction,The length of the statement  "                    if (Settings.Instance.UseFittingManager && Settings.Instance.FactionFitting.Any(m => m.Faction.ToLower() == factionName.ToLower())) " is 131.
Long Statement,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,CheckFaction,The length of the statement  "                        var FactionFitting = Settings.Instance.FactionFitting.FirstOrDefault(m => m.Faction.ToLower() == factionName.ToLower()); " is 120.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName)) " is 123.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName)) " is 123.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if ((State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip) " is 138.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if (Settings.Instance.CombatShipName.ToLower() == shipName) // if the mission specific ship is our default combat ship' no need to do anything special " is 150.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                                Logging.Log("Arm: Unable to find the ship specified in the missionfitting.  Using default combat ship and default fitting."); " is 125.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)) " is 194.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    else if ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))) " is 138.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    else Logging.Log("Arm: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastArmAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count); " is 191.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                    if (neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))) " is 156.
Long Statement,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The length of the statement  "                        var missionItem = (corpHangar ?? itemHangar).Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem); " is 124.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Local_safe,The length of the statement  "                float[] alliance = {DirectEve.Standings.GetPersonalRelationship(LocalMember.AllianceId)' DirectEve.Standings.GetCorporationRelationship(LocalMember.AllianceId)' DirectEve.Standings.GetAllianceRelationship(LocalMember.AllianceId)}; " is 230.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Local_safe,The length of the statement  "                float[] corporation = {DirectEve.Standings.GetPersonalRelationship(LocalMember.CorporationId)' DirectEve.Standings.GetCorporationRelationship(LocalMember.CorporationId)' DirectEve.Standings.GetAllianceRelationship(LocalMember.CorporationId)}; " is 242.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Local_safe,The length of the statement  "                float[] personal = {DirectEve.Standings.GetPersonalRelationship(LocalMember.CharacterId)' DirectEve.Standings.GetCorporationRelationship(LocalMember.CharacterId)' DirectEve.Standings.GetAllianceRelationship(LocalMember.CharacterId)}; " is 233.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Local_safe,The length of the statement  "                    Logging.Log("Cache.WatchLocal: Bad Standing Pilot Detected: [ " + LocalMember.Name + "] " + " [ " + number + " ] so far... of [ " + max_bad + " ] allowed"); " is 156.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                if (Settings.Instance.MissionFitting.Any(m => m.Mission.ToLower() == mission.Name.ToLower())) //priority goes to mission-specific fittings " is 138.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                    if (Settings.Instance.MissionFitting.Any(m => m.Faction.ToLower() == factionName.ToLower() && (m.Mission.ToLower() == mission.Name.ToLower()))) " is 143.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                        _missionFitting = Settings.Instance.MissionFitting.FirstOrDefault(m => m.Faction.ToLower() == factionName.ToLower() && (m.Mission.ToLower() == mission.Name.ToLower())); " is 168.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                    if (!(_missionFit == "" && !(_missionShip == ""))) // if we've both specified a mission specific ship and a fitting' then apply that fitting to the ship " is 152.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                    Logging.Log("Cache: Mission: " + _missionFitting.Mission + " - Faction: " + factionName + " - Fitting: " + _missionFit + " - Ship: " + _missionShip + " - ChangeMissionShipFittings: " + ChangeMissionShipFittings); " is 212.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,RefreshMissionItems,The length of the statement  "                var items = ((IEnumerable)xdoc.XPathEvaluate("//action[(translate(@name' 'LOT'' 'lot')='loot') or (translate(@name' 'LOTIEM'' 'lotiem')='lootitem')]/parameter[translate(@name' 'TIEM'' 'tiem')='item']/@value")).Cast<XAttribute>().Select(a => ((string)a ?? string.Empty).ToLower()); " is 280.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            if (currentTarget != null && PriorityTargets.Any(pt => pt.Id == currentTarget.Id && pt.IsWarpScramblingMe && pt.IsTarget)) " is 122.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            var target = PriorityTargets.OrderBy(OrderByLowestHealth()).ThenBy(t => t.Distance).FirstOrDefault(pt => pt.Distance < distance && pt.IsWarpScramblingMe && pt.IsTarget); " is 169.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            target = PriorityTargets.OrderBy(OrderByLowestHealth()).ThenBy(t => t.Distance).FirstOrDefault(pt => pt.Distance < distance && pt.IsTarget); " is 140.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            var targets = Targets.Where(e => e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure); " is 154.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            var highValueTarget = targets.Where(t => t.TargetValue.HasValue && t.Distance < distance).OrderByDescending(t => t.TargetValue.Value).ThenBy(OrderByLowestHealth()).ThenBy(t => t.Distance).FirstOrDefault(); " is 205.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "            var lowValueTarget = targets.Where(t => !t.TargetValue.HasValue && t.Distance < distance).OrderBy(OrderByLowestHealth()).ThenBy(t => t.Distance).FirstOrDefault(); " is 162.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "                    if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates) " is 130.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "                        return targets.Where(t => !t.TargetValue.HasValue && t.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && t.Distance < distance).OrderByDescending(t => t.Distance).FirstOrDefault(); " is 200.
Long Statement,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The length of the statement  "                    if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance < (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates) " is 130.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ReloadAll,The length of the statement  "            Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds; " is 136.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ReloadAll,The length of the statement  "                    Logging.Log("AnomalyController: Reloading All [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]"); " is 134.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,BookmarkPocketForSalvaging,The length of the statement  "                    Logging.Log("AnomalyController: No bookmark created because the pocket has [" + Cache.Instance.Containers.Count() + "] wrecks/containers and the minimum is [" + Settings.Instance.MinimumWreckCount + "]"); " is 204.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,BookmarkPocketForSalvaging,The length of the statement  "                    Logging.Log("AnomalyController: No bookmark created because the pocket has [" + Cache.Instance.UnlootedContainers.Count() + "] wrecks/containers and the minimum is [" + Settings.Instance.MinimumWreckCount + "]"); " is 212.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,BookmarkPocketForSalvaging,The length of the statement  "            var bookmark = bookmarks.FirstOrDefault(b => Cache.Instance.DistanceFromMe(b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe); " is 144.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ActivateAction,The length of the statement  "                        Logging.Log("AnomolyController: Activate: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 138.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The length of the statement  "            var target = Cache.Instance.PriorityTargets.OrderBy(t => t.Distance).Where(t => (!Cache.Instance.IgnoreTargets.Contains(t.Name.Trim()) || Cache.Instance.TargetedBy.Any(w => w.IsWarpScramblingMe))).FirstOrDefault(); " is 214.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The length of the statement  "            target = target ?? Cache.Instance.TargetedBy.Where(t => !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim()) || Cache.Instance.TargetedBy.Any(w => w.IsWarpScramblingMe)).OrderBy(t => t.Distance).FirstOrDefault(); " is 351.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The length of the statement  "            target = target ?? Cache.Instance.Entities.Where(t => !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim()) || Cache.Instance.TargetedBy.Any(w => w.IsWarpScramblingMe)).OrderBy(t => t.Distance).FirstOrDefault(); " is 349.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The length of the statement  "                            Logging.Log("AnomalyController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]"); " is 151.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The length of the statement  "                            Logging.Log("AnomolyController: Clearpocket: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 140.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,The length of the statement  "                Logging.Log("AnomalyController.Kill: All targets killed " + targetNames.Aggregate((current' next) => current + "[" + next + "]")); " is 130.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,The length of the statement  "                    Logging.Log("AnomalyController.Kill: Unlocking [" + target.Name + "][ID: " + target.Id + "] due to kill order being put on hold"); " is 130.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,The length of the statement  "                            Logging.Log("AnomalyController: Kill: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 134.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,The length of the statement  "                            Logging.Log("AnomalyController: Kill: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 134.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,LootItemAction,The length of the statement  "            var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance); " is 128.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,LootItemAction,The length of the statement  "            if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)) " is 139.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,LootAction,The length of the statement  "            var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance); " is 128.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,LootAction,The length of the statement  "            if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)) " is 139.
Long Statement,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,IgnoreAction,The length of the statement  "                Logging.Log("AnomalyController.Ignore: Currently ignoring: " + Cache.Instance.IgnoreTargets.Aggregate((current' next) => current + "[" + next + "]")); " is 150.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                            Logging.Log("Cleanup: Content of telecom window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 134.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                    Logging.Log("Cleanup: This window indicates we are disconnected: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 175.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                restart |= window.Html.Contains("The transport has not yet been connected' or authentication was not successful"); 	//CONNECTION LOST " is 133.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 132.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 132.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 132.
Long Statement,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The length of the statement  "                                Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]"); " is 132.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    if (!Statistics.Instance.MissionLoggingStarted) //this makes sure we only set the timestamp once (keep in mind this will potentially run many times before completing) " is 166.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        if (Statistics.Instance.DebugMissionStatistics) Logging.Log("MissionLoggingStarted is" + Statistics.Instance.MissionLoggingStartedTimestamp); " is 141.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    //Logging.Log("StatisticsState: MissionLogCompleted is false: we still need to create the mission logs for this last mission"); " is 127.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    //if (Cache.Instance.Agent.LoyaltyPoints == -1) //if this agent has no loyalty points associated then you didn't complete a mission yet. " is 136.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    if (DateTime.Now.Subtract(Statistics.Instance.FinishedSalvaging).TotalMinutes > 10 || DateTime.Now.Subtract(Cache.Instance.StartTime).TotalMinutes < 5) //FinishedSalvaging is the later of the 2 timestamps (FinishedMission and FinishedSalvaging)' if you aren't after mission salvaging this timestamp is the same as FinishedMission " is 329.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        Statistics.Instance.MissionLoggingCompleted = true; //if the mission was completed more than 10 min ago assume the logging has been done already. " is 145.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        //Logging.Log("Statistics: it has not been more than 10 minutes since the last mission was finished. The Mission log should be written.");                             " is 138.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    if (Statistics.Instance.DebugMissionStatistics) // we only need to see the following wall of comments if debugging mission statistics " is 133.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        Logging.Log("1)  we must have loyalty points with the current agent (disabled at the moment)"); //which we already verified if we got this far " is 142.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                                    Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm " is 134.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                                Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm " is 134.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm " is 134.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                    if (!string.IsNullOrEmpty(Cache.Instance.MissionName) && (Cache.Instance.mission == null || (Cache.Instance.mission.State != (int)MissionState.Accepted))) " is 154.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        if (Statistics.Instance.DebugMissionStatistics) Logging.Log("We jumped through all the hoops: now do the mission logging"); " is 123.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        Cache.Instance.SessionIskGenerated = (Cache.Instance.SessionIskGenerated + (Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)); " is 137.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                        Cache.Instance.SessionLPGenerated = (Cache.Instance.SessionLPGenerated + (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints)); " is 127.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                                File.AppendAllText(Settings.Instance.MissionStats1LogFile' "Date;Mission;TimeMission;TimeSalvage;TotalTime;Isk;Loot;LP;\r\n"); " is 126.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line += ((int)DateTime.Now.Subtract(Statistics.Instance.FinishedMission).TotalMinutes) + ";";           // Time Doing After Mission Salvaging " is 141.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line += ((int)DateTime.Now.Subtract(Statistics.Instance.StartedMission).TotalMinutes) + ";";            // Total Time doing Mission " is 131.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line += ((int)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                      // Isk (balance difference from start and finish of mission: is not accurate as the wallet ticks from bounty kills are every x minuts) " is 238.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                                File.AppendAllText(Settings.Instance.MissionStats2LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue\r\n"); " is 133.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line2 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                              // Ammo Consumption " is 123.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                                File.AppendAllText(Settings.Instance.MissionStats3LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue;Panics;LowestShield;LowestArmor;LowestCap;RepairCycles\r\n"); " is 188.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                               // Ammo Consumption " is 124.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Cache.Instance.lowest_shield_percentage_this_mission) + ";";                              // Lowest Shield % " is 123.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Cache.Instance.lowest_armor_percentage_this_mission) + ";";                               // Lowest Armor % " is 122.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Cache.Instance.lowest_capacitor_percentage_this_mission) + ";";                           // Lowest Capacitor % " is 126.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Cache.Instance.repair_cycle_time_this_mission) + ";";                                     // repair Cycle Time " is 125.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ";"; // After Mission Salvaging Time " is 152.
Long Statement,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The length of the statement  "                            line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ((int)FinishedMission.Subtract(StartedMission).TotalMinutes) + ";\r\n"; // Total Time' Mission + After Mission Salvaging (if any) " is 245.
Long Statement,Questor.Modules,LocalWatch,C:\repos\Da-Teach_Questor\Questor.Modules\LocalWatch.cs,ProcessState,The length of the statement  "                    Cache.Instance.Local_safe(Settings.Instance.LocalBadStandingPilotsToTolerate'Settings.Instance.LocalBadStandingLevelToConsiderBad); " is 131.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "            correctAmmo = correctAmmo.Where(a => cargo.Items.Any(i => i.TypeId == a.TypeId && i.Quantity >= Settings.Instance.MinimumAmmoCharges)); " is 135.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "            correctAmmo = correctAmmo.Where(a => cargo.Items.Any(i => i.TypeId == a.TypeId && i.Quantity >= Settings.Instance.MinimumAmmoCharges)); " is 135.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "            if (weapon.Charge != null && weapon.Charge.TypeId == ammo.TypeId && weapon.CurrentCharges >= Settings.Instance.MinimumAmmoCharges) " is 130.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "            var charge = cargo.Items.FirstOrDefault(i => i.TypeId == ammo.TypeId && i.Quantity >= Settings.Instance.MinimumAmmoCharges); " is 124.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "            if (_lastWeaponReload.ContainsKey(weapon.ItemId) && DateTime.Now < _lastWeaponReload[weapon.ItemId].AddSeconds((int)Time.ReloadWeaponDelayBeforeUsable_seconds)) " is 160.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "                    Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds; " is 136.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The length of the statement  "                    Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds; " is 136.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadAll,The length of the statement  "            Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds; " is 136.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadAll,The length of the statement  "                    Logging.Log("Combat: ReloadingAll [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]"); " is 122.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "            if (!DontMoveMyShip) //why would we want the ship to move if we aren't speed tanking and the mission XML isn't telling us to move? " is 130.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!! " is 151.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                        if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)) " is 175.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                            Logging.Log("Combat.ActivateWeapons:: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "]"); " is 125.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                            Logging.Log("Combat.ActivateWeapons: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "]"); " is 124.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons) //this defaults to false and needs to be changed in your characters settings xml file if you want to enable this option " is 182.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                    if (Settings.Instance.WeaponGroupId == 55 || Settings.Instance.WeaponGroupId == 508 || Settings.Instance.WeaponGroupId == 506) " is 126.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                    if (target.Distance <= (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && !target.TargetValue.HasValue && target.GroupId != (int)Group.LargeCollidableStructure) " is 168.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The length of the statement  "                    Logging.Log("Combat: Activating weapon [" + weapon.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]"); " is 163.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateTargetPainters,The length of the statement  "                    Logging.Log("Combat: Activating painter [" + painter.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]"); " is 165.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,The length of the statement  "                //Logging.Log("Combat: Distances Target[ " + Math.Round(target.Distance'0) + " Optimal[" + nos.OptimalRange.ToString()+"]"); " is 124.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,The length of the statement  "                    Logging.Log("Combat: Nos  [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]"); " is 147.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,The length of the statement  "                    Logging.Log("Combat: Cannot Activate Nos [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 165.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var combatTargets = targets.Where(e => e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure).ToList(); " is 169.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                    Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] out of range [" + Math.Round(target.Distance/1000'0) + "k away]"); " is 139.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                    Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] on ignore list [" + Math.Round(target.Distance/1000'0) + "k away]"); " is 141.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var highValueTargets = combatTargets.Where(t => t.TargetValue.HasValue || Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).ToList(); " is 140.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var lowValueTargets = combatTargets.Where(t => !t.TargetValue.HasValue && !Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).ToList(); " is 141.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var targetingMe = Cache.Instance.TargetedBy.Where(t => t.IsNpc && t.CategoryId == (int)CategoryID.Entity && !t.IsContainer && t.Distance < maxRange && !targets.Any(c => c.Id == t.Id) && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).ToList(); " is 250.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var highValueTargetingMe = targetingMe.Where(t => t.TargetValue.HasValue).OrderByDescending(t => t.TargetValue.Value).ThenBy(t => t.Distance).ToList(); " is 151.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var maxHighValueTarget = (lowValueTargetingMe.Count + lowValueTargets.Count) == 0 ? Settings.Instance.MaximumLowValueTargets + Settings.Instance.MaximumHighValueTargets : Settings.Instance.MaximumHighValueTargets; " is 213.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var maxLowValueTarget = (highValueTargetingMe.Count + highValueTargets.Count) == 0 ? Settings.Instance.MaximumLowValueTargets + Settings.Instance.MaximumHighValueTargets : Settings.Instance.MaximumLowValueTargets; " is 213.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            while (highValueTargets.Where(t => !Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).Count() > Math.Max(maxHighValueTarget - Cache.Instance.PriorityTargets.Count()' 0)) " is 176.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                var target = highValueTargets.OrderByDescending(t => t.Distance).Where(t => !Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).FirstOrDefault(); " is 151.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                Logging.Log("Combat: unlocking high value target [" + target.Name + "][ID:" + target.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(target.Distance/1000'0) + "k away]"); " is 178.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                Logging.Log("Combat: unlocking low value target [" + target.Name + "][ID:" + target.Id + "]{" + lowValueTargets.Count + "} [" + Math.Round(target.Distance/1000'0) + "k away]"); " is 176.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "            var priority = Cache.Instance.PriorityTargets.Where(t => t.Distance < maxRange && !targets.Any(c => c.Id == t.Id) && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())); " is 172.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                    Logging.Log("Combat: Targeting priority target [" + entity.Name + "][ID:" + entity.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]"); " is 176.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                    Logging.Log("Combat: Targeting high value target [" + entity.Name + "][ID:" + entity.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]"); " is 178.
Long Statement,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The length of the statement  "                    Logging.Log("Combat: Targeting low value target [" + entity.Name + "][ID:" + entity.Id + "]{" + lowValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]"); " is 176.
Long Statement,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,MoveItem,The length of the statement  "                Logging.Log("CourierMissionState: Moving [" + item.TypeName + "][" + item.ItemId + "] to " + (pickup ? "cargo" : "hangar")); " is 124.
Long Statement,Questor.Modules,SwitchShip,C:\repos\Da-Teach_Questor\Questor.Modules\SwitchShip.cs,ProcessState,The length of the statement  "                    else Logging.Log("SwitchShip: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastSwitchShipAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count); " is 205.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The length of the statement  "                    if (module.TypeId != 11578)  //11578 Covert Ops Cloaking Device - if you don't have a covert ops cloak try the next module " is 122.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The length of the statement  "                    var StuffThatMayDecloakMe = Cache.Instance.Entities.Where(t => t.Name != Cache.Instance.DirectEve.Me.Name || t.IsBadIdea || t.IsContainer || t.IsNpc || t.IsPlayer).OrderBy(t => t.Distance).FirstOrDefault(); " is 206.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The length of the statement  "                    if (StuffThatMayDecloakMe != null || StuffThatMayDecloakMe.Distance <= (int)Distance.SafeToCloakDistance) //if their is anything within 2300m do not attempt to cloak " is 165.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The length of the statement  "                // at this point the module should be active but isn't: activate it' set the delay and return. The process will resume on the next tick " is 135.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The length of the statement  "                Logging.Log("Defense: Defensive module activated: [ " + module.ItemId + "] next Activation delayed until [" + _nextActivateAction.ToString("HH:mm:ss") + "]"); " is 158.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                if (!module.IsActive && ((inCombat && perc < Settings.Instance.ActivateRepairModules) || (!inCombat && perc < Settings.Instance.DeactivateRepairModules && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct))) " is 250.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                    Logging.Log("Defense: RepModule activated: [ " + module.ItemId + "] next Activation delayed until [" + _nextRepModuleAction.ToString("HH:mm:ss") + "]"); " is 152.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                    //Logging.Log("LowestCapacitorPercentage(mission) [ " + Cache.Instance.lowest_capacitor_percentage_this_mission + " ] "); " is 121.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                    Cache.Instance.repair_cycle_time_this_pocket = Cache.Instance.repair_cycle_time_this_pocket + ((int)DateTime.Now.Subtract(Cache.Instance.StartedBoosting).TotalSeconds); " is 168.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                    Cache.Instance.repair_cycle_time_this_mission = Cache.Instance.repair_cycle_time_this_mission + ((int)DateTime.Now.Subtract(Cache.Instance.StartedBoosting).TotalSeconds); " is 170.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The length of the statement  "                    //Cache.Instance.repair_cycle_time_this_mission = Cache.Instance.repair_cycle_time_this_mission + watch.Elapsed.TotalMinutes; " is 125.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateAfterburner,The length of the statement  "                //Logging.Log("Defense: Current Cap [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "]" + "Settings: minimumPropulsionModuleCapacitor [" + Settings.Instance.MinimumPropulsionModuleCapacitor + "]");               " is 212.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateAfterburner,The length of the statement  "                activate &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.MinimumPropulsionModuleCapacitor; " is 121.
Long Statement,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateAfterburner,The length of the statement  "                deactivate |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumPropulsionModuleCapacitor; " is 123.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,EngageTarget,The length of the statement  "                Logging.Log("Drones: Engaging drones on [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 139.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,EngageTarget,The length of the statement  "                Logging.Log("Drones: Making [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance/1000'0) + "k away] the active target for drone engagement."); " is 164.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                        launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;" is 239.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                    if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)" is 122.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                        Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");" is 165.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                        Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");" is 160.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                        Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");" is 172.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                        Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");" is 150.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                            Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");" is 160.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                            Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");" is 157.
Long Statement,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The length of the statement  "                            Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");" is 163.
Long Statement,Questor.Modules,EntityCache,C:\repos\Da-Teach_Questor\Questor.Modules\EntityCache.cs,LockTarget,The length of the statement  "                    Logging.Log("EntityCache: LockTarget is ignored for [" + Name + "][" + Id + "]' can retarget in [" + (45 - seconds) + "]"); " is 123.
Long Statement,Questor.Modules,Logging,C:\repos\Da-Teach_Questor\Questor.Modules\Logging.cs,Log,The length of the statement  "                            InnerSpace.Echo(string.Format("{0:HH:mm:ss} {1}"' DateTime.Now' "Logging: Unable to find (or create): " + Settings.Instance.ConsoleLogPath)); " is 141.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The length of the statement  "                        Settings.Instance.PocketStatisticsFile = Path.Combine(Settings.Instance.PocketStatisticsPath' Cache.Instance.FilterPath(Cache.Instance.DirectEve.Me.Name) + " - " + currentPocketName + " - " + _pocket + " - PocketStatistics.csv"); " is 229.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The length of the statement  "                    File.AppendAllText(Settings.Instance.PocketStatisticsFile' "Date and Time;Mission Name and Pocket;Time to complete;Isk;panics;LowestShields;LowestArmor;LowestCapacitor;RepairCycles\r\n"); " is 187.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The length of the statement  "                Logging.Log("MissionController: Writing pocket statistics to [ " + Settings.Instance.PocketStatisticsFile + "and clearing stats for next pocket"); " is 146.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ReloadAll,The length of the statement  "            Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds; " is 136.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ReloadAll,The length of the statement  "                if (_lastWeaponReload.ContainsKey(weapon.ItemId) && DateTime.Now < _lastWeaponReload[weapon.ItemId].AddSeconds((int)Time.ReloadWeaponDelayBeforeUsable_seconds)) " is 160.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ReloadAll,The length of the statement  "                    Logging.Log("MissionController: ReloadingAll [" + weapon.ItemId + "] with [" + charge.TypeName + "][ typeID:" + charge.TypeId + "]"); " is 133.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,BookmarkPocketForSalvaging,The length of the statement  "                        Logging.Log("MissionController: No bookmark created because the pocket has [" + Cache.Instance.Containers.Count() + "] wrecks/containers and the minimum is [" + Settings.Instance.MinimumWreckCount + "]"); " is 204.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,BookmarkPocketForSalvaging,The length of the statement  "                        Logging.Log("MissionController: No bookmark created because the pocket has [" + Cache.Instance.UnlootedContainers.Count() + "] wrecks/containers and the minimum is [" + Settings.Instance.MinimumWreckCount + "]"); " is 212.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,BookmarkPocketForSalvaging,The length of the statement  "                var bookmark = bookmarks.FirstOrDefault(b => Cache.Instance.DistanceFromMe(b.X ?? 0' b.Y ?? 0' b.Z ?? 0) < (int)Distance.BookmarksOnGridWithMe); " is 144.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,BookmarkPocketForSalvaging,The length of the statement  "                    //var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance); " is 130.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                    Logging.Log("MissionController.Activate: Can't find [" + target + "] to activate! Waiting 30 seconds before giving up"); " is 120.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                        Logging.Log("MissionController.Activate: After 30 seconds of waiting the gate is still not on grid: MissionControllerState.Error"); " is 131.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "            //if (closest.Distance <= (int)Distance.CloseToGateActivationRange) // if your distance is less than the 'close enough' range' default is 7000 meters " is 149.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object " is 126.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away " is 235.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it " is 138.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                    Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'"); " is 149.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "            else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach " is 166.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                        Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 163.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                    // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k) " is 122.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The length of the statement  "                    Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]"); " is 192.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "            var target = Cache.Instance.PriorityTargets.OrderBy(t => t.Distance).Where(t => !(Cache.Instance.IgnoreTargets.Contains(t.Name.Trim()) && !Cache.Instance.TargetedBy.Any(w => w.IsWarpScramblingMe || w.IsNeutralizingMe || w.IsWebbingMe))).FirstOrDefault(); " is 254.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "            target = target ?? Cache.Instance.TargetedBy.Where(t => !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).OrderBy(t => t.Distance).FirstOrDefault(); " is 291.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "            target = target ?? Cache.Instance.Entities.Where(t => !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int) CategoryID.Entity && t.GroupId != (int) Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).OrderBy(t => t.Distance).FirstOrDefault(); " is 291.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "            int targetedby = Cache.Instance.TargetedBy.Where(t => !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).Count(); " is 255.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                        Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]"); " is 168.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                            Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 154.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                        Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 209.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!! " is 151.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                        if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)) " is 175.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                                Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 184.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                            Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal"); " is 160.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The length of the statement  "                                Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 184.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The length of the statement  "            var target = Cache.Instance.PriorityTargets.OrderBy(t => t.Distance).Where(t => t.Distance < distancetoconsidertargets && !(Cache.Instance.IgnoreTargets.Contains(t.Name.Trim()) && !Cache.Instance.TargetedBy.Any(w => w.IsWarpScramblingMe || w.IsNeutralizingMe || w.IsWebbingMe))).FirstOrDefault(); " is 296.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The length of the statement  "            target = target ?? Cache.Instance.TargetedBy.Where(t => t.Distance < distancetoconsidertargets && !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).OrderBy(t => t.Distance).FirstOrDefault(); " is 333.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The length of the statement  "            target = target ?? Cache.Instance.Entities.Where(t => t.Distance < distancetoconsidertargets && !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).OrderBy(t => t.Distance).FirstOrDefault(); " is 331.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The length of the statement  "            int targetedby = Cache.Instance.TargetedBy.Where(t => t.Distance < distancetoconsidertargets && !t.IsSentry && !t.IsContainer && t.IsNpc && t.CategoryId == (int)CategoryID.Entity && t.GroupId != (int)Group.LargeCollidableStructure && !Cache.Instance.IgnoreTargets.Contains(t.Name.Trim())).Count(); " is 297.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The length of the statement  "                            Logging.Log("MissionController.ClearwithinWeaponsRange: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 166.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToBackgroundAction,The length of the statement  "            Logging.Log("MissionController.MoveToBackground: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 171.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The length of the statement  "                    Logging.Log("MissionController.MoveTo: Stop ship' we are [" + distancetoapp + "] from [ID: " + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 169.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The length of the statement  "                            Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 163.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The length of the statement  "                //    Logging.Log("MissionController.MoveTo: Approaching target [" + closest.Name + "][" + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away]"); " is 160.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,The length of the statement  "                Logging.Log("MissionController.AggroOnly: All targets gone " + targetNames.Aggregate((current' next) => current + "[" + next + "]")); " is 133.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,The length of the statement  "                    Logging.Log("MissionController.AggroOnly: Unlocking [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away] due to aggro being obtained"); " is 177.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,The length of the statement  "                Logging.Log("MissionController.AggroOnly: Adding [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away] as a priority target"); " is 170.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                Logging.Log("MissionController.Kill: All targets killed " + targetNames.Aggregate((current' next) => current + "[" + next + "]")); " is 130.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                    Logging.Log("MissionController.Kill: Unlocking [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away] due to kill order being put on hold"); " is 180.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "            if (Settings.Instance.OptimalRange > 0 && (closest.Distance < (Settings.Instance.OptimalRange * 0.8d)) && !Settings.Instance.SpeedTank) " is 135.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "            //if distance to target is more than weapons range and we haven't setup optimalrange OR we are inside optimalrange and optimalrange has been setup " is 146.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "            if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0) " is 199.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this... " is 188.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                    //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)"); " is 129.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                            Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away"); " is 228.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                            Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 205.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                            Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 205.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The length of the statement  "                    Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this... " is 182.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "            if (Cache.Instance.DirectEve.ActiveShip.Entity.Velocity > 9999999) //this concept with a relatively more realistic speed should be used in places to make sure speed tanks are moving " is 181.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "                //        Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => targetNames.Contains(e.Name)).OrderBy(t => t.Distance).First(); " is 146.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "                //        Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => targetNames.Contains(e.Name)).OrderByDescending(t => t.Distance).First(); " is 156.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "                        //Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => e.IsContainer && e.HaveLootRights || e.GroupId == (int) Group.Wreck)).OrderBy(e => e.Distance).ToList(); " is 179.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "                //var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance);  " is 130.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The length of the statement  "                //        target =   Cache.Instance.Entities.Where(e =>  Cache.Instance.CurrentCombatTargets.Contains(e.Id).Orderby(t => target.Distance).First(); " is 146.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "                    Logging.Log("MissionController.AttackClosestByName: Adding [" + target.Name + "][ID: " + target.Id + "] as a priority target"); " is 127.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "            if (Settings.Instance.OptimalRange > 0 && (target.Distance < (Settings.Instance.OptimalRange * 0.8d)) && !Settings.Instance.SpeedTank) " is 134.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "            //if distance to target is more than weapons range and we havent setup optimalrange OR we are inside optimalrange and optimalrange has been setup " is 145.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "            if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0) " is 197.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "                    Logging.Log("MissionController.AttackClosestByName: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 171.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "                            Logging.Log("MissionController: AttackClosestByName: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 148.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "                        Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 215.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The length of the statement  "                        Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 215.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "                    Logging.Log("MissionController.AttackClosest: Adding [" + target.Name + "][ID: " + target.Id + "] as a priority target"); " is 121.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "            if (Settings.Instance.OptimalRange > 0 && (target.Distance < (Settings.Instance.OptimalRange * 0.8d)) && !Settings.Instance.SpeedTank) " is 134.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "            //if distance to target is more than weapons range and we havent setup optimalrange OR we are inside optimalrange and optimalrange has been setup " is 145.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "            if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0) " is 197.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "                    Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]"); " is 165.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "                            Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]"); " is 142.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "                            Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 209.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The length of the statement  "                            Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]"); " is 212.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The length of the statement  "            var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance); " is 128.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The length of the statement  "            //var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Id); " is 124.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The length of the statement  "            //var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderByDescending(e => e.Id); " is 134.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The length of the statement  "            if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)) " is 139.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The length of the statement  "                    Logging.Log("MissionController.LootItem: Approaching target [" + closest.Name + "][ID: " + closest.Id + "] which is at [" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 176.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,The length of the statement  "            var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance); " is 128.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,The length of the statement  "            if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)) " is 139.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,The length of the statement  "                    Logging.Log("MissionController.Loot: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]"); " is 159.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,IgnoreAction,The length of the statement  "                Logging.Log("MissionController.Ignore: Currently ignoring: " + Cache.Instance.IgnoreTargets.Aggregate((current' next) => current + "[" + next + "]")); " is 150.
Long Statement,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ProcessState,The length of the statement  "                            Logging.Log("MissionController: Using default orbit distance: " + Cache.Instance.OrbitDistance + " (as the custom one was 0)"); " is 127.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                        else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31) " is 197.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]"); " is 171.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                        else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct) " is 125.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]"); " is 162.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                        else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct) " is 123.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]"); " is 159.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting); " is 127.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking  " is 128.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                    if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff) " is 169.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                                Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]"); " is 120.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so " is 120.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds " is 247.
Long Statement,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The length of the statement  "                            Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]"); " is 142.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,ActivateTractorBeams,The length of the statement  "            var wrecks = Cache.Instance.Targets.Where(t => (t.GroupId == (int) Group.Wreck || t.GroupId == (int) Group.CargoContainer) && t.Distance < tractorBeamRange).ToList(); " is 166.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,ActivateTractorBeams,The length of the statement  "                Logging.Log("Salvage: Activating tractorbeam [" + tractorBeam.ItemId + "] on [" + wreck.Name + "][ID: " + wreck.Id + "]"); " is 122.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,TargetHostileWrecks,The length of the statement  "            var wreckTargets = targets.Where(t => (t.GroupId == (int)Group.Wreck) && t.CategoryId == (int)CategoryID.Celestial).ToList(); " is 125.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,TargetHostileWrecks,The length of the statement  "                //    Logging.Log("Salvage: Cargo Container [" + wreck.Name + "][" + wreck.Id + "] within loot range' unlocking container."); " is 125.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,TargetHostileWrecks,The length of the statement  "                Logging.Log("Salvage: Locking [" + wreck.Name + "][ID:" + wreck.Id + "][" + Math.Round(wreck.Distance/1000'0) + "k away]"); " is 123.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "            var lootWindows = Cache.Instance.DirectEve.Windows.OfType<DirectContainerWindow>().Where(w => !string.IsNullOrEmpty(w.Name) && w.Name.StartsWith("loot_")); " is 155.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                if (containerEntity == null || containerEntity.Distance > (int)Distance.SafeScoopRange || Cache.Instance.LootedContainers.Contains(containerEntity.Id)) " is 151.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                                Logging.Log("Scoop: Not enough space for [" + item.Name + "] Need [" + item.TotalVolume + "]m3 - maximum available [" + (freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) + "]m3"); " is 187.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                        foreach (var wl in worthLess.OrderBy(wl => wl.IskPerM3.HasValue ? wl.IskPerM3.Value : double.MaxValue).ThenByDescending(wl => wl.TotalVolume)) " is 142.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                            Logging.Log("Scoop: Moving [" + moveTheseItems.Count + "] items into the cargo container to make room for the more valuable loot"); " is 131.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                    //Logging.Log("Scoop: Looting container [" + containerEntity.Name + "][" + containerEntity.Id + "]' [" + lootItems.Count + "] valuable items"); " is 143.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                    Logging.Log("Scoop: Container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "] contained no valuable items"); " is 123.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "            foreach (var containerEntity in Cache.Instance.UnlootedWrecksAndSecureCans.Where(e => e.Distance <= (int)Distance.SafeScoopRange)) " is 130.
Long Statement,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The length of the statement  "                if (_openedContainers.ContainsKey(containerEntity.Id) && DateTime.Now.Subtract(_openedContainers[containerEntity.Id]).TotalSeconds < 10) " is 136.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,ActivateTractorBeams,The length of the statement  "            var wrecks = Cache.Instance.Targets.Where(t => (t.GroupId == (int)Group.Wreck || t.GroupId == (int)Group.CargoContainer) && t.Distance < tractorBeamRange).ToList(); " is 164.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,ActivateTractorBeams,The length of the statement  "                Logging.Log("Salvage: Activating tractorbeam [" + tractorBeam.ItemId + "] on [" + wreck.Name + "][ID: " + wreck.Id + "]"); " is 122.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,ActivateSalvagers,The length of the statement  "            var wrecks = Cache.Instance.Targets.Where(t => t.GroupId == (int)Group.Wreck && t.Distance < salvagerRange && !Settings.Instance.WreckBlackList.Any(a => a == t.TypeId)).ToList(); " is 178.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "            var wreckTargets = targets.Where(t => (t.GroupId == (int)Group.Wreck || t.GroupId == (int)Group.CargoContainer) && t.CategoryId == (int)CategoryID.Celestial).ToList(); " is 167.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                    if(Settings.Instance.WreckBlackList.Any(a => a == wreck.TypeId) && (wreck.Distance < (int)Distance.SafeScoopRange || wreck.IsWreckEmpty)) " is 137.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                        Logging.Log("Salvage: Cargo Container [" + wreck.Name + "][ID: " + wreck.Id + "] within loot range'wreck is empty' or wreck is on our blacklist' unlocking container."); " is 168.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                    Logging.Log("Salvage: Cargo Container [" + wreck.Name + "][ID: " + wreck.Id + "] within loot range' unlocking container."); " is 123.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                if(wreckTargets.Count >= Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets)) " is 134.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                    if (Settings.Instance.WreckBlackList.Any(a => a == wreck.TypeId) && (wreck.IsWreckEmpty || wreck.Distance < (int)Distance.SafeScoopRange)) " is 138.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                Logging.Log("Salvage: Locking [" + wreck.Name + "][ID:" + wreck.Id + "][" + Math.Round(wreck.Distance / 1000' 0) + "k away]"); " is 126.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The length of the statement  "                    if(wreckTargets.Count >= Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets)) " is 134.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "            var lootWindows = Cache.Instance.DirectEve.Windows.OfType<DirectContainerWindow>().Where(w => w.Type == "form.LootCargoView"); " is 126.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                if (containerEntity == null || containerEntity.Distance > (int)Distance.SafeScoopRange || Cache.Instance.LootedContainers.Contains(containerEntity.Id)) " is 151.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                    File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "TIME: " + string.Format("{0:dd/MM/yyyy HH:mm:ss}"' DateTime.Now) + "\n"); " is 136.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                    if (freeCargoCapacity < 1000) //this should allow BSs to not pickup large low value items but haulers and noctus' to scoop everything " is 133.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                                Logging.Log("Salvage: Not enough space for mission item! Need [" + item.TotalVolume + "] maximum available [" + (freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) + "]"); " is 177.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                        foreach (var wl in worthLess.OrderBy(wl => wl.IskPerM3.HasValue ? wl.IskPerM3.Value : double.MaxValue).ThenByDescending(wl => wl.TotalVolume)) " is 142.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                            Logging.Log("Salvage: Moving [" + moveTheseItems.Count + "] items into the cargo container to make room for the more valuable loot"); " is 133.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                    Logging.Log("Salvage: Looting container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "]' [" + lootItems.Count + "] valuable items"); " is 147.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                    Logging.Log("Salvage: Container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "] contained no valuable items"); " is 125.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                if (_openedContainers.ContainsKey(containerEntity.Id) && DateTime.Now.Subtract(_openedContainers[containerEntity.Id]).TotalSeconds < 10) " is 136.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                //      this is currently commented out as it would keep golems and other non-speed tanked ships from looting the field as they cleared " is 135.
Long Statement,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The length of the statement  "                //      missions' but NOT stick around after killing things to clear it ALL. Looteverything==false does NOT mean loot nothing " is 125.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            Settings.Instance.settingsPath = Path.Combine(Settings.Instance.path' Cache.Instance.FilterPath(Settings.Instance.characterName) + ".xml"); " is 139.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML? " is 162.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            DebugStates = (bool?) xml.Element("debugStates") ?? false;                                           //enables more console logging having to do with the sub-states within each state " is 182.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            DebugPerformance = (bool?) xml.Element("debugPerformance") ?? false;                                 //enabled more console logging having to do with the time it takes to execute each state " is 189.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            CharacterMode = (string) xml.Element("characterMode") ?? "dps";                                      //other option is "salvage" " is 128.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            AutoStart = (bool?) xml.Element("autoStart") ?? false;                                               // auto Start enabled or disabled by default? " is 146.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            SaveConsoleLog = (bool?)xml.Element("saveLog") ?? true;                                              // save the console log to file " is 132.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            maxLineConsole = (int?)xml.Element("maxLineConsole") ?? 1000;                                        // maximum console log lines to show in the GUI " is 148.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            Disable3D = (bool?)xml.Element("disable3D") ?? false;                                                // Disable3d graphics while in space " is 137.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            UseGatesInSalvage = (bool?)xml.Element("useGatesInSalvage") ?? false;                               // if our mission does not despawn (likely someone in the mission looting our stuff?) use the gates when salvaging to get to our bookmarks " is 238.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            BattleshipInvasionLimit = (int?)xml.Element("battleshipInvasionLimit") ?? 0;                        // if this number of battleships lands on grid while in a mission we will enter panic " is 185.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            BattlecruiserInvasionLimit = (int?)xml.Element("battlecruiserInvasionLimit") ?? 0;                  // if this number of battlecruisers lands on grid while in a mission we will enter panic " is 188.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            CruiserInvasionLimit = (int?)xml.Element("cruiserInvasionLimit") ?? 0;                              // if this number of cruisers lands on grid while in a mission we will enter panic " is 182.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            FrigateInvasionLimit = (int?)xml.Element("frigateInvasionLimit") ?? 0;                              // if this number of frigates lands on grid while in a mission we will enter panic " is 182.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            InvasionRandomDelay = (int?)xml.Element("invasionRandomDelay") ?? 0;                                // random relay to stay docked " is 130.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            InvasionMinimumDelay = (int?)xml.Element("invasionMinimumDelay") ?? 0;                              // minimum delay to stay docked " is 131.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            IskPerLP = (double?)xml.Element("IskPerLP") ?? 600;                                                 //used in value calculations " is 128.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            UndockDelay = (int?)xml.Element("undockdelay") ?? 10;                                               //Delay when undocking - not in use " is 135.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            UndockPrefix = (string) xml.Element("undockprefix") ?? "Insta";                                     //Undock bookmark prefix - used by traveler - not in use " is 156.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            WindowXPosition = (int?) xml.Element("windowXPosition") ?? 1600;                                    //windows position (needs to be changed' default is off screen) " is 163.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            WindowYPosition = (int?)xml.Element("windowYPosition") ?? 1050;                                     //windows position (needs to be changed' default is off screen) " is 163.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            walletbalancechangelogoffdelayLogofforExit = (string)xml.Element("walletbalancechangelogoffdelayLogofforExit") ?? "exit"; " is 121.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "                            Logging.Log("Settings: Error! No default fitting specified or fitting is incorrect.  Fitting manager will not be used."); " is 121.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "                        Logging.Log("Settings: Error! No default fitting specified or fitting is incorrect.  Fitting manager will not be used."); " is 121.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            logpath = (Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) + "\\log\\" + Cache.Instance.DirectEve.Me.Name + "\\"); " is 130.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            ConsoleLogFile = Path.Combine(ConsoleLogPath + string.Format("{0:MM-dd-yyyy}"' DateTime.Today) + "-" + Cache.Instance.DirectEve.Me.Name + "-" + "console" + ".log"); " is 164.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            WreckLootStatisticsFile = Path.Combine(WreckLootStatisticsPath + Cache.Instance.DirectEve.Me.Name + ".WreckLootStatisticsDump.log"); " is 132.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            MissionStats3LogFile = Path.Combine(MissionStats3LogPath + Cache.Instance.DirectEve.Me.Name + ".CustomDatedStatistics.csv"); " is 124.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            PocketStatisticsFile = Path.Combine(PocketStatisticsPath + Cache.Instance.DirectEve.Me.Name + "pocketstats-combined.csv"); " is 122.
Long Statement,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The length of the statement  "            //create all the logging directories even if they aren't configured to be used - we can adjust this later if it really bugs people to have some potentially empty directories.  " is 174.
Long Statement,Questor.Modules,Traveler,C:\repos\Da-Teach_Questor\Questor.Modules\Traveler.cs,NagivateToBookmarkSystem,The length of the statement  "                    entity.Approach(); //you could use a negative approach distance here but ultimately that is a bad idea.. Id like to go toward the entity without approaching it so we would end up inside the docking ring (eventually) " is 215.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    Logging.Log("TravelerDestination.StationDestination: We're docked in the wrong station' undocking from [" + Cache.Instance.DirectEve.GetLocationName(Cache.Instance.DirectEve.Session.StationId ?? 0) + "]"); " is 205.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //    var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.UndockPrefix).OrderByDescending(b => b.CreatedOn).Where(b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId); " is 197.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //    //var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where(b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).Where(b => b.Title.Contains(Settings.Instance.UndockPrefix)); //this does not handle more than one station undock bookmark per system and WILL likely warp to the wrong bm in that case " is 317.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //    //var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where(b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).Where(b => b.Title.Contains(Cache.Instance.DirectEve.GetLocationName(Cache.Instance.DirectEve.Session.StationId ?? 0)) && b.Title.Contains(Settings.Instance.UndockPrefix)); " is 306.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //    //var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where(b => b.Title.Contains(Cache.Instance.DirectEve.GetLocationName(Cache.Instance.DirectEve.Session.StationId ?? 0)) && b.Title.Contains(Settings.Instance.UndockPrefix)); " is 231.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //            Logging.Log("TravelerDestination.StationDestination: undock bookmark [" + localundockBookmark.Title + "] is unusable: it has no coords"); " is 151.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //        else Logging.Log("TravelerDestination.StationDestination: undock bookmark [" + localundockBookmark.Title + "] is usable: it has coords"); " is 147.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                    //    else Logging.Log("TravelerDestination.StationDestination: you do not have an undock bookmark that has the prefix: " + Settings.Instance.UndockPrefix + " in local"); //+ Cache.Instance.DirectEve.GetLocationName((long)Cache.Instance.DirectEve.Session.StationId) + " and " + Settings.Instance.UndockPrefix + " did not both exist in a bookmark"); " is 348.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                if (Cache.Instance.DistanceFromMe(localundockBookmark.X ?? 0' localundockBookmark.Y ?? 0' localundockBookmark.Z ?? 0) < (int)Distance.WarptoDistance) " is 149.
Long Statement,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "            //else Logging.Log("TravelerDestination.BookmarkDestination: undock bookmark missing: " + Cache.Instance.DirectEve.GetLocationName((long)Cache.Instance.DirectEve.Session.StationId) + " and " + Settings.Instance.UndockPrefix + " did not both exist in a bookmark"); " is 263.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //    var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.UndockPrefix).OrderByDescending(b => b.CreatedOn).Where(b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId); " is 197.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //    //var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where(b => b.LocationId == Cache.Instance.DirectEve.Session.SolarSystemId).OrderByDescending(b => b.CreatedOn).Where(b => b.Title.Contains(Settings.Instance.UndockPrefix)); //this does not handle more than one station undock bookmark per system and WILL likely warp to the wrong bm in that case " is 353.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //    //var bookmarks = Cache.Instance.DirectEve.Bookmarks.Where(b => b.Title.Contains(Cache.Instance.DirectEve.GetLocationName(Cache.Instance.DirectEve.Session.StationId ?? 0)) && b.Title.Contains(Settings.Instance.UndockPrefix)); " is 231.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //            Logging.Log("TravelerDestination.BookmarkDestination: undock bookmark [" + undockBookmark.Title + "] is unusable: it has no coords"); " is 147.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //        else Logging.Log("TravelerDestination.BookmarkDestination: undock bookmark [" + undockBookmark.Title + "] is usable: it has coords"); " is 143.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                //    else Logging.Log("TravelerDestination.BookmarkDestination: you do not have an undock bookmark that contains [" + Settings.Instance.UndockPrefix + "] in local"); " is 166.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                var arrived = StationDestination.PerformFinalDestinationTask(bookmark.Entity.Id' bookmark.Entity.Name' ref nextAction' ref undockBookmark); " is 139.
Long Statement,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "                if (Cache.Instance.DistanceFromMe(undockBookmark.X ?? 0' undockBookmark.Y ?? 0' undockBookmark.Z ?? 0) < (int)Distance.WarptoDistance) " is 134.
Long Statement,Questor.Modules,MissionBookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "            var arrived = BookmarkDestination.PerformFinalDestinationTask(GetMissionBookmark(AgentId' Title)' (int)Distance.MissionWarpLimit' ref _nextMissionBookmarkAction' ref undockBookmark); " is 182.
Long Statement,Questor.Modules,MissionBookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The length of the statement  "            return arrived;// Mission bookmarks have a 1.000.000 distance warp-to limit (changed it to 150.000.000 as there are some bugged missions around)   " is 144.
Long Statement,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the statement  "                long lootContainerID = itemshangar.Items.FirstOrDefault(i => i.GivenName != null && i.GivenName.ToLower() == Settings.Instance.LootContainer.ToLower()).ItemId; " is 159.
Long Statement,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the statement  "                    // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines) " is 217.
Long Statement,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the statement  "                    var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314); " is 182.
Long Statement,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the statement  "                    var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId)); " is 173.
Long Statement,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The length of the statement  "                    ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId)))); " is 173.
Complex Conditional,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The conditional expression  "mission.State == (int)MissionState.Offered && (mission.Type == "Mining" || mission.Type == "Trade" || (mission.Type == "Courier" && missionName != "Enemies Abound (2 of 5)"))"  is complex.
Complex Conditional,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The conditional expression  "(State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip"  is complex.
Complex Conditional,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The conditional expression  "Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380)"  is complex.
Complex Conditional,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The conditional expression  "(Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))"  is complex.
Complex Conditional,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The conditional expression  "neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))"  is complex.
Complex Conditional,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The conditional expression  "currentTarget != null && PriorityTargets.Any(pt => pt.Id == currentTarget.Id && pt.IsWarpScramblingMe && pt.IsTarget)"  is complex.
Complex Conditional,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateRepairModules,The conditional expression  "!module.IsActive && ((inCombat && perc < Settings.Instance.ActivateRepairModules) || (!inCombat && perc < Settings.Instance.DeactivateRepairModules && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct))"  is complex.
Complex Conditional,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The conditional expression  "(closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0"  is complex.
Complex Conditional,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The conditional expression  "(target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0"  is complex.
Complex Conditional,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The conditional expression  "(target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0"  is complex.
Complex Conditional,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The conditional expression  "InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31"  is complex.
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForConversation,The following statement contains a magic number: if (Purpose == AgentInteractionPurpose.AmmoCheck)              {                  Logging.Log("AgentInteraction: Checking ammo type");                  State = AgentInteractionState.WaitForMission;              }              else              {                  Logging.Log("AgentInteraction: Replying to agent");                  State = AgentInteractionState.ReplyToAgent;                  _nextAgentAction = DateTime.Now.AddSeconds(7);              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,ReplyToAgent,The following statement contains a magic number: if (responses == null || responses.Count == 0)              {                  if (DateTime.Now.Subtract(_waitingonagentwindowtimer2).TotalSeconds > 30)                  {                      Logging.Log("AgentInteraction: ReplyToAgent: agentWindow == null : waiting");                      if (DateTime.Now.Subtract(_waitingonagentwindowtimer2).TotalSeconds > 60)                      {                          Logging.Log("AgentInteraction: ReplyToAgent: agentWindow == null : trying to close the agent window");                          agentWindow.Close();                          _waitingonagentwindowtimer = DateTime.Now;                      }                  }                  return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,ReplyToAgent,The following statement contains a magic number: if (responses == null || responses.Count == 0)              {                  if (DateTime.Now.Subtract(_waitingonagentwindowtimer2).TotalSeconds > 30)                  {                      Logging.Log("AgentInteraction: ReplyToAgent: agentWindow == null : waiting");                      if (DateTime.Now.Subtract(_waitingonagentwindowtimer2).TotalSeconds > 60)                      {                          Logging.Log("AgentInteraction: ReplyToAgent: agentWindow == null : trying to close the agent window");                          agentWindow.Close();                          _waitingonagentwindowtimer = DateTime.Now;                      }                  }                  return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The following statement contains a magic number: if (agentWindow == null || !agentWindow.IsReady)              {                  if (DateTime.Now.Subtract(_waitingonagentwindowtimer).TotalSeconds > 60)                  {                      Logging.Log("AgentInteraction: WaitForMission: agentWindow == null : waiting");                      _waitingonagentwindowtimer = DateTime.Now;                      if (Math.Round(DateTime.Now.Subtract(Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes) > 7)                      {                          Cache.Instance.CloseQuestorCMDLogoff = false;                          Cache.Instance.CloseQuestorCMDExitGame = true;                          Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh- journalwindows was null: restarting EVE Session";                          Logging.Log(Cache.Instance.ReasonToStopQuestor);                          Cache.Instance.SessionState = "Quitting";                      }                  }                  return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The following statement contains a magic number: if (agentWindow == null || !agentWindow.IsReady)              {                  if (DateTime.Now.Subtract(_waitingonagentwindowtimer).TotalSeconds > 60)                  {                      Logging.Log("AgentInteraction: WaitForMission: agentWindow == null : waiting");                      _waitingonagentwindowtimer = DateTime.Now;                      if (Math.Round(DateTime.Now.Subtract(Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes) > 7)                      {                          Cache.Instance.CloseQuestorCMDLogoff = false;                          Cache.Instance.CloseQuestorCMDExitGame = true;                          Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh- journalwindows was null: restarting EVE Session";                          Logging.Log(Cache.Instance.ReasonToStopQuestor);                          Cache.Instance.SessionState = "Quitting";                      }                  }                  return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The following statement contains a magic number: if (journalWindow == null)              {                  if (DateTime.Now.Subtract(_lastJournalOpenRequest).TotalSeconds > 30)                  {                      Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenJournal);                      _lastJournalOpenRequest = DateTime.Now;                    }                  return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The following statement contains a magic number: if (mission == null)              {                   if (DateTime.Now.Subtract(_waitingonmissiontimer).TotalSeconds > 60)                  {                      Logging.Log("AgentInteraction: WaitForMission: mission == null : waiting");                      _waitingonmissiontimer = DateTime.Now;                      if (Math.Round(DateTime.Now.Subtract(Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes) > 7)                      {                          Cache.Instance.CloseQuestorCMDLogoff = false;                          Cache.Instance.CloseQuestorCMDExitGame = true;                          Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh - mission was null: restarting EVE Session";                          Logging.Log(Cache.Instance.ReasonToStopQuestor);                          Cache.Instance.SessionState = "Quitting";                      }                  }                    return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,WaitForMission,The following statement contains a magic number: if (mission == null)              {                   if (DateTime.Now.Subtract(_waitingonmissiontimer).TotalSeconds > 60)                  {                      Logging.Log("AgentInteraction: WaitForMission: mission == null : waiting");                      _waitingonmissiontimer = DateTime.Now;                      if (Math.Round(DateTime.Now.Subtract(Cache.Instance.lastKnownGoodConnectedTime).TotalMinutes) > 7)                      {                          Cache.Instance.CloseQuestorCMDLogoff = false;                          Cache.Instance.CloseQuestorCMDExitGame = true;                          Cache.Instance.ReasonToStopQuestor = "AgentInteraction: WaitforMission: Journal would not open/refresh - mission was null: restarting EVE Session";                          Logging.Log(Cache.Instance.ReasonToStopQuestor);                          Cache.Instance.SessionState = "Quitting";                      }                  }                    return;              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,DeclineMission,The following statement contains a magic number: if (waitDecline)              {                  var html = agentWindow.Briefing;                  if (html.Contains("Declining a mission from this agent within the next"))                  {                      var standingRegex = new Regex("Effective Standing:\\s(?<standing>\\d+.\\d+)");                      var standingMatch = standingRegex.Match(html);                      float standings = 0;                      if (standingMatch.Success)                      {                          var standingValue = standingMatch.Groups["standing"].Value;                          standingValue = standingValue.Replace('.'' '''); // necessary for systems w/ comma-delimited number formatting                          standings = float.Parse(standingValue);                          if (minStandings > 10)                          {                              standings = standings / 10;                          }                          if (minStandings > 10)                          {                              minStandings = minStandings / 10;                          }                          Logging.Log("AgentInteraction: Agent decline timer detected. Current standings: " + standings + ". Minimum standings: " + minStandings);                      }                        var hourRegex = new Regex("\\s(?<hour>\\d+)\\shour");                      var minuteRegex = new Regex("\\s(?<minute>\\d+)\\sminute");                      var hourMatch = hourRegex.Match(html);                      var minuteMatch = minuteRegex.Match(html);                      int hours = 0;                      int minutes = 0;                      if (hourMatch.Success)                      {                          var hourValue = hourMatch.Groups["hour"].Value;                          hours = Convert.ToInt32(hourValue);                      }                      if (minuteMatch.Success)                      {                          var minuteValue = minuteMatch.Groups["minute"].Value;                          minutes = Convert.ToInt32(minuteValue);                      }                        int secondsToWait = ((hours * 3600) + (minutes * 60) + 60);                      var current_agent = Settings.Instance.AgentsList.FirstOrDefault(i => i.Name == Cache.Instance.CurrentAgent);                        if (standings <= minStandings && !Cache.Instance.IsAgentLoop)                      {                          _nextAgentAction = DateTime.Now.AddSeconds(secondsToWait);                          Logging.Log("AgentInteraction: Current standings at or below minimum.  Waiting " + (secondsToWait / 60) + " minutes to try decline again.");                          CloseConversation();                            State = AgentInteractionState.StartConversation;                            return;                      }                        //add timer to current agent                      if (Cache.Instance.IsAgentLoop && Settings.Instance.MultiAgentSupport)                      {                          current_agent.Decline_timer = DateTime.Now.AddSeconds(secondsToWait);                          CloseConversation();                            Cache.Instance.CurrentAgent = Cache.Instance.SwitchAgent;                          Logging.Log("AgentInteraction: new agent is " + Cache.Instance.CurrentAgent);                          State = AgentInteractionState.ChangeAgent;                            return;                      }                      Logging.Log("AgentInteraction: Current standings above minimum.  Declining mission.");                  }              }
Magic Number,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case ArmState.Idle:                      break;                  case ArmState.Done:                      break;                    case ArmState.NotEnoughDrones:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughDrones");                      //State = ArmState.Idle;                      break;                                    case ArmState.NotEnoughAmmo:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughAmmo");                      //State = ArmState.Idle;                      break;                    case ArmState.Begin:                      //DefaultFittingChecked = false; //flag to check for the correct default fitting before using the fitting manager                      //DefaultFittingFound = true; //Did we find the default fitting?                      Cache.Instance.ArmLoadedCache = false;                      TryMissionShip = true;  // Used in the event we can't find the ship specified in the missionfittings                      UseMissionShip = false; // Were we successful in activating the mission specific ship?                      State = ArmState.OpenShipHangar;                      break;                    case ArmState.OpenShipHangar:                  case ArmState.SwitchToTransportShip:                  case ArmState.SwitchToSalvageShip:                      // Is the ship hangar open?                      if (shipHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenShipHangar);                          break;                      }                        if (!shipHangar.IsReady)                          break;                        if (State == ArmState.OpenShipHangar)                      {                          Logging.Log("Arm: Activating combat ship");                          State = ArmState.ActivateCombatShip;                      }                      else if (State == ArmState.SwitchToTransportShip)                      {                          Logging.Log("Arm: Activating transport ship");                          State = ArmState.ActivateTransportShip;                      }                      else                      {                          Logging.Log("Arm: Activating salvage ship");                          State = ArmState.ActivateSalvageShip;                      }                      break;                    case ArmState.ActivateTransportShip:                      string transportshipName = Settings.Instance.TransportShipName.ToLower();                        if (string.IsNullOrEmpty(transportshipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateTransportShip: Could not find transportshipName: " + transportshipName + " in settings!");                          return;                      }                      else if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != transportshipName)                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds) //default 10 seconds                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == transportshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      else if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds) //default 7 seconds                      {                          if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() == transportshipName)                          {                              Logging.Log("Arm.ActivateTransportShip: Done");                              State = ArmState.Done;                              return;                          }                      }                      break;                                        case ArmState.ActivateSalvageShip:                      var salvageshipName = Settings.Instance.SalvageShipName.ToLower();                        if (string.IsNullOrEmpty(salvageshipName))                      {                          State = ArmState.NotEnoughAmmo;                          Logging.Log("Arm.ActivateSalvageShip: Could not find salvageshipName: " + salvageshipName + " in settings!");                          return;                      }                        if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == salvageshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds)                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                          return;                      }                      break;                    case ArmState.ActivateCombatShip:                      var shipName = Settings.Instance.CombatShipName.ToLower();                        if (string.IsNullOrEmpty(shipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateCombatShip: Could not find CombatShipName: " + shipName + " in settings!");                          return;                      }                      if (!Cache.Instance.ArmLoadedCache)                      {                          _missionItemMoved = false;                          Cache.Instance.RefreshMissionItems(AgentId);                          Cache.Instance.ArmLoadedCache = true;                      }                      // If we've got a mission-specific ship defined' switch to it                      if ((State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip)                          shipName = Cache.Instance.MissionShip.ToLower();                        if (Settings.Instance.CombatShipName.ToLower() == shipName) // if the mission specific ship is our default combat ship' no need to do anything special                          TryMissionShip = false;                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == shipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                                  if (TryMissionShip)                                      UseMissionShip = true;                                  return;                              }                                if (TryMissionShip && !UseMissionShip)                              {                                  Logging.Log("Arm: Unable to find the ship specified in the missionfitting.  Using default combat ship and default fitting.");                                  TryMissionShip = false;                                  Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                                  return;                              }                                State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm: Found the following ships:");                              foreach (var ship in ships)                                  Logging.Log("Arm: [" + ship.GivenName + "]");                              Logging.Log("Arm: Could not find [" + shipName + "] ship!");                              return;                          }                          return;                      }                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      else if (TryMissionShip)                          UseMissionShip = true;                        //if (State == ArmState.ActivateSalvageShip)                      //{                      //    Logging.Log("Arm: Done");                      //    State = ArmState.Done;                      //    return;                      //}                        //_missionItemMoved = false;                      //Cache.Instance.RefreshMissionItems(AgentId);                      if (AmmoToLoad.Count == 0 && string.IsNullOrEmpty(Cache.Instance.BringMissionItem))                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                      }                      else                      {                          Logging.Log("Arm: Opening item hangar");                          State = ArmState.OpenItemHangar;                      }                      break;                    case ArmState.OpenItemHangar:                      // Is the hangar open?                      if (itemHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          _lastArmAction = DateTime.Now;                          break;                      }                        if (!itemHangar.IsReady)                          break;                        if (corpHangar != null)                      {                          Logging.Log("Arm: Opening corporation hangar");                          State = ArmState.OpenCorpHangar;                      }                      else                      {                          Logging.Log("Arm: Opening ship's cargo");                          State = ArmState.OpenCargo;                      }                      break;                    case ArmState.OpenCorpHangar:                      // Is the hangar open?                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("Arm: Opening ship's cargo");                      State = ArmState.OpenCargo;                      break;                    case ArmState.OpenCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380))                      {                          Logging.Log("Arm: Opening ship's drone bay");                          State = ArmState.OpenDroneBay;                      }                      else if ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                      }                      else                          State = ArmState.MoveItems;                      break;                    case ArmState.OpenFittingWindow:                      //let's check first if we need to change fitting at all                      Logging.Log("Arm: Fitting: " + Cache.Instance.Fitting + " - currentFit: " + Cache.Instance.currentFit);                      if (Cache.Instance.Fitting.Equals(Cache.Instance.currentFit))                      {                          Logging.Log("Arm: Current fit is correct - no change necessary");                          State = ArmState.MoveItems;                      }                      else                      {                          Cache.Instance.DirectEve.OpenFitingManager();                          State = ArmState.WaitForFittingWindow;                      }                      break;                    case ArmState.WaitForFittingWindow:                        var fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      //open it again ?                      if (fittingMgr == null)                      {                          Logging.Log("Arm: Opening fitting manager");                          Cache.Instance.DirectEve.OpenFitingManager();                      }                      //check if it's ready                      else if (fittingMgr.IsReady)                      {                          State = ArmState.ChoseFitting;                      }                      break;                    case ArmState.ChoseFitting:                      fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      bool found = false;                      if (!DefaultFittingChecked)                      {                          DefaultFittingChecked = true;                          Logging.Log("Arm: Looking for Default Fitting " + Cache.Instance.DefaultFitting);                          foreach (var fitting in fittingMgr.Fittings)                          {                              //ok found it                              if (Cache.Instance.DefaultFitting.ToLower().Equals(fitting.Name.ToLower()))                              {                                  found = true;                                  Logging.Log("Arm: Found Default Fitting " + fitting.Name);                              }                          }                          if (!found)                          {                              Logging.Log("Arm: Error! Couldn't find Default Fitting.  Disabling fitting manager.");                              DefaultFittingFound = false;                              Settings.Instance.UseFittingManager = false;                              State = ArmState.MoveItems;                              break;                          }                          found = false;                      }                      Logging.Log("Arm: Looking for fitting " + Cache.Instance.Fitting);                      foreach (var fitting in fittingMgr.Fittings)                      {                          //ok found it                          var ship = Cache.Instance.DirectEve.ActiveShip;                          if (Cache.Instance.Fitting.ToLower().Equals(fitting.Name.ToLower()) && fitting.ShipTypeId == ship.TypeId)                          {                              Logging.Log("Arm: Found fitting " + fitting.Name);                              //switch to the requested fitting for the current mission                              fitting.Fit();                              _lastArmAction = DateTime.Now;                              Cache.Instance.currentFit = fitting.Name;                              State = ArmState.WaitForFitting;                              found = true;                              break;                          }                        }                      //if we didn't find it' we'll set currentfit to default                      //this should provide backwards compatibility without trying to fit always                      if (!found)                      {                          if (UseMissionShip)                          {                              Logging.Log("Arm: Couldn't find fitting for this ship typeid.  Using current fitting.");                              State = ArmState.MoveItems;                              break;                          }                          else                          {                              Logging.Log("Arm: Couldn't find fitting - switching to default");                              Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                              break;                          }                      }                      State = ArmState.MoveItems;                      fittingMgr.Close();                      break;                    case ArmState.WaitForFitting:                      //let's wait 10 seconds                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.FittingWindowLoadFittingDelay_seconds &&                          Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          //we should be done fitting' proceed to the next state                          State = ArmState.MoveItems;                          fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                          fittingMgr.Close();                          Logging.Log("Arm: Done fitting");                      }                      else Logging.Log("Arm: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastArmAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count);                      break;                    case ArmState.OpenDroneBay:                      // Is cargo open?                      if (droneBay.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenDroneBayOfActiveShip);                          break;                      }                         if (!droneBay.IsReady)                          break;                         Logging.Log("Arm: Moving drones");                      State = ArmState.MoveDrones;                      break;                     case ArmState.MoveDrones:                      var drone = ammoHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (!string.IsNullOrEmpty(Settings.Instance.AmmoHangar))                          drone = corpHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      else                          drone = itemHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (drone == null || drone.Stacksize < 1)                      {                          Logging.Log("Arm: Out of drones");                          State = ArmState.NotEnoughDrones;                          break;                      }                         var neededDrones = Math.Floor((droneBay.Capacity - droneBay.UsedCapacity)/drone.Volume);                      Logging.Log("neededDrones: " + neededDrones);                      if (neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                          break;                      }                      else if (neededDrones == 0)                      {                          State = ArmState.MoveItems;                          break;                      }                        // Move needed drones                      droneBay.Add(drone' (int)Math.Min(neededDrones' drone.Stacksize));                      break;                    case ArmState.MoveItems:                      var bringItem = Cache.Instance.BringMissionItem;                      if (string.IsNullOrEmpty(bringItem))                          _missionItemMoved = true;                        if (!_missionItemMoved)                      {                          var missionItem = (corpHangar ?? itemHangar).Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                          if (missionItem == null)                              missionItem = itemHangar.Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                            if (missionItem != null)                          {                              Logging.Log("Arm: Moving [" + missionItem.TypeName + "]");                                cargo.Add(missionItem' 1);                              _missionItemMoved = true;                              break;                          }                      }                        var itemMoved = false;                      if (Cache.Instance.missionAmmo.Count() != 0)                      {                          AmmoToLoad = new List<Ammo>(Cache.Instance.missionAmmo);                      }                      foreach (var item in ammoHangar.Items.OrderBy(i => i.Quantity))                      {                          if (item.ItemId <= 0)                              continue;                            var ammo = AmmoToLoad.FirstOrDefault(a => a.TypeId == item.TypeId);                          if (ammo == null)                              continue;                            Logging.Log("Arm: Moving [" + item.TypeName + "]");                            var moveQuantity = Math.Min(item.Quantity' ammo.Quantity);                          moveQuantity = Math.Max(moveQuantity' 1);                          cargo.Add(item' moveQuantity);                            ammo.Quantity -= moveQuantity;                          if (ammo.Quantity <= 0)                          {                              Cache.Instance.missionAmmo.RemoveAll(a => a.TypeId == item.TypeId);                              AmmoToLoad.RemoveAll(a => a.TypeId == item.TypeId);                          }                          itemMoved = true;                          break;                      }                        if (AmmoToLoad.Count == 0 && _missionItemMoved)                      {                          _lastArmAction = DateTime.Now;                            Logging.Log("Arm: Waiting for items");                          State = ArmState.WaitForItems;                      }                      else if (!itemMoved)                      {                          if (AmmoToLoad.Count > 0)                              foreach (var ammo in AmmoToLoad)                              {                                  Logging.Log("Arm: Missing ammo with TypeId [" + ammo.TypeId + "]");                              }                            if (!_missionItemMoved)                              Logging.Log("Arm: Missing mission item [" + bringItem + "]");                            State = ArmState.NotEnoughAmmo;                      }                      break;                    case ArmState.WaitForItems:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds < (int)Time.Armstate_WaitforItemstoMove_seconds)                          break;                        if (cargo.Items.Count == 0)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          // Close the drone bay' its not required in space.                          if (droneBay.IsReady)                              droneBay.Window.Close();                            Logging.Log("Arm: Done");                            //reload the ammo setting for combat                          try                          {                              var mission = Cache.Instance.DirectEve.AgentMissions.FirstOrDefault(m => m.AgentId == AgentId);                              if (mission == null)                                  return;                                var missionName = Cache.Instance.FilterPath(mission.Name);                              var missionXmlPath = Path.Combine(Settings.Instance.MissionsPath' missionName + ".xml");                              var missionXml = XDocument.Load(missionXmlPath);                              Cache.Instance.missionAmmo = new List<Ammo>();                              var ammoTypes = missionXml.Root.Element("missionammo");                              if (ammoTypes != null)                                  foreach (var ammo in ammoTypes.Elements("ammo"))                                      Cache.Instance.missionAmmo.Add(new Ammo(ammo));                          }                          catch (Exception e)                          {                              Logging.Log("Arms.WaitForItems: Unable to load missionammo from mission XML: no XML found' " + e.Message);                              Cache.Instance.missionAmmo = new List<Ammo>();                          }                            State = ArmState.Done;                          break;                      }                        // Note' there's no unlock here as we *always* want our ammo!                      break;              }
Magic Number,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case ArmState.Idle:                      break;                  case ArmState.Done:                      break;                    case ArmState.NotEnoughDrones:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughDrones");                      //State = ArmState.Idle;                      break;                                    case ArmState.NotEnoughAmmo:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughAmmo");                      //State = ArmState.Idle;                      break;                    case ArmState.Begin:                      //DefaultFittingChecked = false; //flag to check for the correct default fitting before using the fitting manager                      //DefaultFittingFound = true; //Did we find the default fitting?                      Cache.Instance.ArmLoadedCache = false;                      TryMissionShip = true;  // Used in the event we can't find the ship specified in the missionfittings                      UseMissionShip = false; // Were we successful in activating the mission specific ship?                      State = ArmState.OpenShipHangar;                      break;                    case ArmState.OpenShipHangar:                  case ArmState.SwitchToTransportShip:                  case ArmState.SwitchToSalvageShip:                      // Is the ship hangar open?                      if (shipHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenShipHangar);                          break;                      }                        if (!shipHangar.IsReady)                          break;                        if (State == ArmState.OpenShipHangar)                      {                          Logging.Log("Arm: Activating combat ship");                          State = ArmState.ActivateCombatShip;                      }                      else if (State == ArmState.SwitchToTransportShip)                      {                          Logging.Log("Arm: Activating transport ship");                          State = ArmState.ActivateTransportShip;                      }                      else                      {                          Logging.Log("Arm: Activating salvage ship");                          State = ArmState.ActivateSalvageShip;                      }                      break;                    case ArmState.ActivateTransportShip:                      string transportshipName = Settings.Instance.TransportShipName.ToLower();                        if (string.IsNullOrEmpty(transportshipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateTransportShip: Could not find transportshipName: " + transportshipName + " in settings!");                          return;                      }                      else if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != transportshipName)                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds) //default 10 seconds                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == transportshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      else if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds) //default 7 seconds                      {                          if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() == transportshipName)                          {                              Logging.Log("Arm.ActivateTransportShip: Done");                              State = ArmState.Done;                              return;                          }                      }                      break;                                        case ArmState.ActivateSalvageShip:                      var salvageshipName = Settings.Instance.SalvageShipName.ToLower();                        if (string.IsNullOrEmpty(salvageshipName))                      {                          State = ArmState.NotEnoughAmmo;                          Logging.Log("Arm.ActivateSalvageShip: Could not find salvageshipName: " + salvageshipName + " in settings!");                          return;                      }                        if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == salvageshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds)                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                          return;                      }                      break;                    case ArmState.ActivateCombatShip:                      var shipName = Settings.Instance.CombatShipName.ToLower();                        if (string.IsNullOrEmpty(shipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateCombatShip: Could not find CombatShipName: " + shipName + " in settings!");                          return;                      }                      if (!Cache.Instance.ArmLoadedCache)                      {                          _missionItemMoved = false;                          Cache.Instance.RefreshMissionItems(AgentId);                          Cache.Instance.ArmLoadedCache = true;                      }                      // If we've got a mission-specific ship defined' switch to it                      if ((State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip)                          shipName = Cache.Instance.MissionShip.ToLower();                        if (Settings.Instance.CombatShipName.ToLower() == shipName) // if the mission specific ship is our default combat ship' no need to do anything special                          TryMissionShip = false;                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == shipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                                  if (TryMissionShip)                                      UseMissionShip = true;                                  return;                              }                                if (TryMissionShip && !UseMissionShip)                              {                                  Logging.Log("Arm: Unable to find the ship specified in the missionfitting.  Using default combat ship and default fitting.");                                  TryMissionShip = false;                                  Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                                  return;                              }                                State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm: Found the following ships:");                              foreach (var ship in ships)                                  Logging.Log("Arm: [" + ship.GivenName + "]");                              Logging.Log("Arm: Could not find [" + shipName + "] ship!");                              return;                          }                          return;                      }                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      else if (TryMissionShip)                          UseMissionShip = true;                        //if (State == ArmState.ActivateSalvageShip)                      //{                      //    Logging.Log("Arm: Done");                      //    State = ArmState.Done;                      //    return;                      //}                        //_missionItemMoved = false;                      //Cache.Instance.RefreshMissionItems(AgentId);                      if (AmmoToLoad.Count == 0 && string.IsNullOrEmpty(Cache.Instance.BringMissionItem))                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                      }                      else                      {                          Logging.Log("Arm: Opening item hangar");                          State = ArmState.OpenItemHangar;                      }                      break;                    case ArmState.OpenItemHangar:                      // Is the hangar open?                      if (itemHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          _lastArmAction = DateTime.Now;                          break;                      }                        if (!itemHangar.IsReady)                          break;                        if (corpHangar != null)                      {                          Logging.Log("Arm: Opening corporation hangar");                          State = ArmState.OpenCorpHangar;                      }                      else                      {                          Logging.Log("Arm: Opening ship's cargo");                          State = ArmState.OpenCargo;                      }                      break;                    case ArmState.OpenCorpHangar:                      // Is the hangar open?                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("Arm: Opening ship's cargo");                      State = ArmState.OpenCargo;                      break;                    case ArmState.OpenCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380))                      {                          Logging.Log("Arm: Opening ship's drone bay");                          State = ArmState.OpenDroneBay;                      }                      else if ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                      }                      else                          State = ArmState.MoveItems;                      break;                    case ArmState.OpenFittingWindow:                      //let's check first if we need to change fitting at all                      Logging.Log("Arm: Fitting: " + Cache.Instance.Fitting + " - currentFit: " + Cache.Instance.currentFit);                      if (Cache.Instance.Fitting.Equals(Cache.Instance.currentFit))                      {                          Logging.Log("Arm: Current fit is correct - no change necessary");                          State = ArmState.MoveItems;                      }                      else                      {                          Cache.Instance.DirectEve.OpenFitingManager();                          State = ArmState.WaitForFittingWindow;                      }                      break;                    case ArmState.WaitForFittingWindow:                        var fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      //open it again ?                      if (fittingMgr == null)                      {                          Logging.Log("Arm: Opening fitting manager");                          Cache.Instance.DirectEve.OpenFitingManager();                      }                      //check if it's ready                      else if (fittingMgr.IsReady)                      {                          State = ArmState.ChoseFitting;                      }                      break;                    case ArmState.ChoseFitting:                      fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      bool found = false;                      if (!DefaultFittingChecked)                      {                          DefaultFittingChecked = true;                          Logging.Log("Arm: Looking for Default Fitting " + Cache.Instance.DefaultFitting);                          foreach (var fitting in fittingMgr.Fittings)                          {                              //ok found it                              if (Cache.Instance.DefaultFitting.ToLower().Equals(fitting.Name.ToLower()))                              {                                  found = true;                                  Logging.Log("Arm: Found Default Fitting " + fitting.Name);                              }                          }                          if (!found)                          {                              Logging.Log("Arm: Error! Couldn't find Default Fitting.  Disabling fitting manager.");                              DefaultFittingFound = false;                              Settings.Instance.UseFittingManager = false;                              State = ArmState.MoveItems;                              break;                          }                          found = false;                      }                      Logging.Log("Arm: Looking for fitting " + Cache.Instance.Fitting);                      foreach (var fitting in fittingMgr.Fittings)                      {                          //ok found it                          var ship = Cache.Instance.DirectEve.ActiveShip;                          if (Cache.Instance.Fitting.ToLower().Equals(fitting.Name.ToLower()) && fitting.ShipTypeId == ship.TypeId)                          {                              Logging.Log("Arm: Found fitting " + fitting.Name);                              //switch to the requested fitting for the current mission                              fitting.Fit();                              _lastArmAction = DateTime.Now;                              Cache.Instance.currentFit = fitting.Name;                              State = ArmState.WaitForFitting;                              found = true;                              break;                          }                        }                      //if we didn't find it' we'll set currentfit to default                      //this should provide backwards compatibility without trying to fit always                      if (!found)                      {                          if (UseMissionShip)                          {                              Logging.Log("Arm: Couldn't find fitting for this ship typeid.  Using current fitting.");                              State = ArmState.MoveItems;                              break;                          }                          else                          {                              Logging.Log("Arm: Couldn't find fitting - switching to default");                              Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                              break;                          }                      }                      State = ArmState.MoveItems;                      fittingMgr.Close();                      break;                    case ArmState.WaitForFitting:                      //let's wait 10 seconds                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.FittingWindowLoadFittingDelay_seconds &&                          Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          //we should be done fitting' proceed to the next state                          State = ArmState.MoveItems;                          fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                          fittingMgr.Close();                          Logging.Log("Arm: Done fitting");                      }                      else Logging.Log("Arm: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastArmAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count);                      break;                    case ArmState.OpenDroneBay:                      // Is cargo open?                      if (droneBay.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenDroneBayOfActiveShip);                          break;                      }                         if (!droneBay.IsReady)                          break;                         Logging.Log("Arm: Moving drones");                      State = ArmState.MoveDrones;                      break;                     case ArmState.MoveDrones:                      var drone = ammoHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (!string.IsNullOrEmpty(Settings.Instance.AmmoHangar))                          drone = corpHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      else                          drone = itemHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (drone == null || drone.Stacksize < 1)                      {                          Logging.Log("Arm: Out of drones");                          State = ArmState.NotEnoughDrones;                          break;                      }                         var neededDrones = Math.Floor((droneBay.Capacity - droneBay.UsedCapacity)/drone.Volume);                      Logging.Log("neededDrones: " + neededDrones);                      if (neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                          break;                      }                      else if (neededDrones == 0)                      {                          State = ArmState.MoveItems;                          break;                      }                        // Move needed drones                      droneBay.Add(drone' (int)Math.Min(neededDrones' drone.Stacksize));                      break;                    case ArmState.MoveItems:                      var bringItem = Cache.Instance.BringMissionItem;                      if (string.IsNullOrEmpty(bringItem))                          _missionItemMoved = true;                        if (!_missionItemMoved)                      {                          var missionItem = (corpHangar ?? itemHangar).Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                          if (missionItem == null)                              missionItem = itemHangar.Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                            if (missionItem != null)                          {                              Logging.Log("Arm: Moving [" + missionItem.TypeName + "]");                                cargo.Add(missionItem' 1);                              _missionItemMoved = true;                              break;                          }                      }                        var itemMoved = false;                      if (Cache.Instance.missionAmmo.Count() != 0)                      {                          AmmoToLoad = new List<Ammo>(Cache.Instance.missionAmmo);                      }                      foreach (var item in ammoHangar.Items.OrderBy(i => i.Quantity))                      {                          if (item.ItemId <= 0)                              continue;                            var ammo = AmmoToLoad.FirstOrDefault(a => a.TypeId == item.TypeId);                          if (ammo == null)                              continue;                            Logging.Log("Arm: Moving [" + item.TypeName + "]");                            var moveQuantity = Math.Min(item.Quantity' ammo.Quantity);                          moveQuantity = Math.Max(moveQuantity' 1);                          cargo.Add(item' moveQuantity);                            ammo.Quantity -= moveQuantity;                          if (ammo.Quantity <= 0)                          {                              Cache.Instance.missionAmmo.RemoveAll(a => a.TypeId == item.TypeId);                              AmmoToLoad.RemoveAll(a => a.TypeId == item.TypeId);                          }                          itemMoved = true;                          break;                      }                        if (AmmoToLoad.Count == 0 && _missionItemMoved)                      {                          _lastArmAction = DateTime.Now;                            Logging.Log("Arm: Waiting for items");                          State = ArmState.WaitForItems;                      }                      else if (!itemMoved)                      {                          if (AmmoToLoad.Count > 0)                              foreach (var ammo in AmmoToLoad)                              {                                  Logging.Log("Arm: Missing ammo with TypeId [" + ammo.TypeId + "]");                              }                            if (!_missionItemMoved)                              Logging.Log("Arm: Missing mission item [" + bringItem + "]");                            State = ArmState.NotEnoughAmmo;                      }                      break;                    case ArmState.WaitForItems:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds < (int)Time.Armstate_WaitforItemstoMove_seconds)                          break;                        if (cargo.Items.Count == 0)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          // Close the drone bay' its not required in space.                          if (droneBay.IsReady)                              droneBay.Window.Close();                            Logging.Log("Arm: Done");                            //reload the ammo setting for combat                          try                          {                              var mission = Cache.Instance.DirectEve.AgentMissions.FirstOrDefault(m => m.AgentId == AgentId);                              if (mission == null)                                  return;                                var missionName = Cache.Instance.FilterPath(mission.Name);                              var missionXmlPath = Path.Combine(Settings.Instance.MissionsPath' missionName + ".xml");                              var missionXml = XDocument.Load(missionXmlPath);                              Cache.Instance.missionAmmo = new List<Ammo>();                              var ammoTypes = missionXml.Root.Element("missionammo");                              if (ammoTypes != null)                                  foreach (var ammo in ammoTypes.Elements("ammo"))                                      Cache.Instance.missionAmmo.Add(new Ammo(ammo));                          }                          catch (Exception e)                          {                              Logging.Log("Arms.WaitForItems: Unable to load missionammo from mission XML: no XML found' " + e.Message);                              Cache.Instance.missionAmmo = new List<Ammo>();                          }                            State = ArmState.Done;                          break;                      }                        // Note' there's no unlock here as we *always* want our ammo!                      break;              }
Magic Number,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case ArmState.Idle:                      break;                  case ArmState.Done:                      break;                    case ArmState.NotEnoughDrones:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughDrones");                      //State = ArmState.Idle;                      break;                                    case ArmState.NotEnoughAmmo:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughAmmo");                      //State = ArmState.Idle;                      break;                    case ArmState.Begin:                      //DefaultFittingChecked = false; //flag to check for the correct default fitting before using the fitting manager                      //DefaultFittingFound = true; //Did we find the default fitting?                      Cache.Instance.ArmLoadedCache = false;                      TryMissionShip = true;  // Used in the event we can't find the ship specified in the missionfittings                      UseMissionShip = false; // Were we successful in activating the mission specific ship?                      State = ArmState.OpenShipHangar;                      break;                    case ArmState.OpenShipHangar:                  case ArmState.SwitchToTransportShip:                  case ArmState.SwitchToSalvageShip:                      // Is the ship hangar open?                      if (shipHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenShipHangar);                          break;                      }                        if (!shipHangar.IsReady)                          break;                        if (State == ArmState.OpenShipHangar)                      {                          Logging.Log("Arm: Activating combat ship");                          State = ArmState.ActivateCombatShip;                      }                      else if (State == ArmState.SwitchToTransportShip)                      {                          Logging.Log("Arm: Activating transport ship");                          State = ArmState.ActivateTransportShip;                      }                      else                      {                          Logging.Log("Arm: Activating salvage ship");                          State = ArmState.ActivateSalvageShip;                      }                      break;                    case ArmState.ActivateTransportShip:                      string transportshipName = Settings.Instance.TransportShipName.ToLower();                        if (string.IsNullOrEmpty(transportshipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateTransportShip: Could not find transportshipName: " + transportshipName + " in settings!");                          return;                      }                      else if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != transportshipName)                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds) //default 10 seconds                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == transportshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      else if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds) //default 7 seconds                      {                          if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() == transportshipName)                          {                              Logging.Log("Arm.ActivateTransportShip: Done");                              State = ArmState.Done;                              return;                          }                      }                      break;                                        case ArmState.ActivateSalvageShip:                      var salvageshipName = Settings.Instance.SalvageShipName.ToLower();                        if (string.IsNullOrEmpty(salvageshipName))                      {                          State = ArmState.NotEnoughAmmo;                          Logging.Log("Arm.ActivateSalvageShip: Could not find salvageshipName: " + salvageshipName + " in settings!");                          return;                      }                        if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == salvageshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds)                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                          return;                      }                      break;                    case ArmState.ActivateCombatShip:                      var shipName = Settings.Instance.CombatShipName.ToLower();                        if (string.IsNullOrEmpty(shipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateCombatShip: Could not find CombatShipName: " + shipName + " in settings!");                          return;                      }                      if (!Cache.Instance.ArmLoadedCache)                      {                          _missionItemMoved = false;                          Cache.Instance.RefreshMissionItems(AgentId);                          Cache.Instance.ArmLoadedCache = true;                      }                      // If we've got a mission-specific ship defined' switch to it                      if ((State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip)                          shipName = Cache.Instance.MissionShip.ToLower();                        if (Settings.Instance.CombatShipName.ToLower() == shipName) // if the mission specific ship is our default combat ship' no need to do anything special                          TryMissionShip = false;                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == shipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                                  if (TryMissionShip)                                      UseMissionShip = true;                                  return;                              }                                if (TryMissionShip && !UseMissionShip)                              {                                  Logging.Log("Arm: Unable to find the ship specified in the missionfitting.  Using default combat ship and default fitting.");                                  TryMissionShip = false;                                  Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                                  return;                              }                                State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm: Found the following ships:");                              foreach (var ship in ships)                                  Logging.Log("Arm: [" + ship.GivenName + "]");                              Logging.Log("Arm: Could not find [" + shipName + "] ship!");                              return;                          }                          return;                      }                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      else if (TryMissionShip)                          UseMissionShip = true;                        //if (State == ArmState.ActivateSalvageShip)                      //{                      //    Logging.Log("Arm: Done");                      //    State = ArmState.Done;                      //    return;                      //}                        //_missionItemMoved = false;                      //Cache.Instance.RefreshMissionItems(AgentId);                      if (AmmoToLoad.Count == 0 && string.IsNullOrEmpty(Cache.Instance.BringMissionItem))                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                      }                      else                      {                          Logging.Log("Arm: Opening item hangar");                          State = ArmState.OpenItemHangar;                      }                      break;                    case ArmState.OpenItemHangar:                      // Is the hangar open?                      if (itemHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          _lastArmAction = DateTime.Now;                          break;                      }                        if (!itemHangar.IsReady)                          break;                        if (corpHangar != null)                      {                          Logging.Log("Arm: Opening corporation hangar");                          State = ArmState.OpenCorpHangar;                      }                      else                      {                          Logging.Log("Arm: Opening ship's cargo");                          State = ArmState.OpenCargo;                      }                      break;                    case ArmState.OpenCorpHangar:                      // Is the hangar open?                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("Arm: Opening ship's cargo");                      State = ArmState.OpenCargo;                      break;                    case ArmState.OpenCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380))                      {                          Logging.Log("Arm: Opening ship's drone bay");                          State = ArmState.OpenDroneBay;                      }                      else if ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                      }                      else                          State = ArmState.MoveItems;                      break;                    case ArmState.OpenFittingWindow:                      //let's check first if we need to change fitting at all                      Logging.Log("Arm: Fitting: " + Cache.Instance.Fitting + " - currentFit: " + Cache.Instance.currentFit);                      if (Cache.Instance.Fitting.Equals(Cache.Instance.currentFit))                      {                          Logging.Log("Arm: Current fit is correct - no change necessary");                          State = ArmState.MoveItems;                      }                      else                      {                          Cache.Instance.DirectEve.OpenFitingManager();                          State = ArmState.WaitForFittingWindow;                      }                      break;                    case ArmState.WaitForFittingWindow:                        var fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      //open it again ?                      if (fittingMgr == null)                      {                          Logging.Log("Arm: Opening fitting manager");                          Cache.Instance.DirectEve.OpenFitingManager();                      }                      //check if it's ready                      else if (fittingMgr.IsReady)                      {                          State = ArmState.ChoseFitting;                      }                      break;                    case ArmState.ChoseFitting:                      fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      bool found = false;                      if (!DefaultFittingChecked)                      {                          DefaultFittingChecked = true;                          Logging.Log("Arm: Looking for Default Fitting " + Cache.Instance.DefaultFitting);                          foreach (var fitting in fittingMgr.Fittings)                          {                              //ok found it                              if (Cache.Instance.DefaultFitting.ToLower().Equals(fitting.Name.ToLower()))                              {                                  found = true;                                  Logging.Log("Arm: Found Default Fitting " + fitting.Name);                              }                          }                          if (!found)                          {                              Logging.Log("Arm: Error! Couldn't find Default Fitting.  Disabling fitting manager.");                              DefaultFittingFound = false;                              Settings.Instance.UseFittingManager = false;                              State = ArmState.MoveItems;                              break;                          }                          found = false;                      }                      Logging.Log("Arm: Looking for fitting " + Cache.Instance.Fitting);                      foreach (var fitting in fittingMgr.Fittings)                      {                          //ok found it                          var ship = Cache.Instance.DirectEve.ActiveShip;                          if (Cache.Instance.Fitting.ToLower().Equals(fitting.Name.ToLower()) && fitting.ShipTypeId == ship.TypeId)                          {                              Logging.Log("Arm: Found fitting " + fitting.Name);                              //switch to the requested fitting for the current mission                              fitting.Fit();                              _lastArmAction = DateTime.Now;                              Cache.Instance.currentFit = fitting.Name;                              State = ArmState.WaitForFitting;                              found = true;                              break;                          }                        }                      //if we didn't find it' we'll set currentfit to default                      //this should provide backwards compatibility without trying to fit always                      if (!found)                      {                          if (UseMissionShip)                          {                              Logging.Log("Arm: Couldn't find fitting for this ship typeid.  Using current fitting.");                              State = ArmState.MoveItems;                              break;                          }                          else                          {                              Logging.Log("Arm: Couldn't find fitting - switching to default");                              Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                              break;                          }                      }                      State = ArmState.MoveItems;                      fittingMgr.Close();                      break;                    case ArmState.WaitForFitting:                      //let's wait 10 seconds                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.FittingWindowLoadFittingDelay_seconds &&                          Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          //we should be done fitting' proceed to the next state                          State = ArmState.MoveItems;                          fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                          fittingMgr.Close();                          Logging.Log("Arm: Done fitting");                      }                      else Logging.Log("Arm: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastArmAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count);                      break;                    case ArmState.OpenDroneBay:                      // Is cargo open?                      if (droneBay.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenDroneBayOfActiveShip);                          break;                      }                         if (!droneBay.IsReady)                          break;                         Logging.Log("Arm: Moving drones");                      State = ArmState.MoveDrones;                      break;                     case ArmState.MoveDrones:                      var drone = ammoHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (!string.IsNullOrEmpty(Settings.Instance.AmmoHangar))                          drone = corpHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      else                          drone = itemHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (drone == null || drone.Stacksize < 1)                      {                          Logging.Log("Arm: Out of drones");                          State = ArmState.NotEnoughDrones;                          break;                      }                         var neededDrones = Math.Floor((droneBay.Capacity - droneBay.UsedCapacity)/drone.Volume);                      Logging.Log("neededDrones: " + neededDrones);                      if (neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                          break;                      }                      else if (neededDrones == 0)                      {                          State = ArmState.MoveItems;                          break;                      }                        // Move needed drones                      droneBay.Add(drone' (int)Math.Min(neededDrones' drone.Stacksize));                      break;                    case ArmState.MoveItems:                      var bringItem = Cache.Instance.BringMissionItem;                      if (string.IsNullOrEmpty(bringItem))                          _missionItemMoved = true;                        if (!_missionItemMoved)                      {                          var missionItem = (corpHangar ?? itemHangar).Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                          if (missionItem == null)                              missionItem = itemHangar.Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                            if (missionItem != null)                          {                              Logging.Log("Arm: Moving [" + missionItem.TypeName + "]");                                cargo.Add(missionItem' 1);                              _missionItemMoved = true;                              break;                          }                      }                        var itemMoved = false;                      if (Cache.Instance.missionAmmo.Count() != 0)                      {                          AmmoToLoad = new List<Ammo>(Cache.Instance.missionAmmo);                      }                      foreach (var item in ammoHangar.Items.OrderBy(i => i.Quantity))                      {                          if (item.ItemId <= 0)                              continue;                            var ammo = AmmoToLoad.FirstOrDefault(a => a.TypeId == item.TypeId);                          if (ammo == null)                              continue;                            Logging.Log("Arm: Moving [" + item.TypeName + "]");                            var moveQuantity = Math.Min(item.Quantity' ammo.Quantity);                          moveQuantity = Math.Max(moveQuantity' 1);                          cargo.Add(item' moveQuantity);                            ammo.Quantity -= moveQuantity;                          if (ammo.Quantity <= 0)                          {                              Cache.Instance.missionAmmo.RemoveAll(a => a.TypeId == item.TypeId);                              AmmoToLoad.RemoveAll(a => a.TypeId == item.TypeId);                          }                          itemMoved = true;                          break;                      }                        if (AmmoToLoad.Count == 0 && _missionItemMoved)                      {                          _lastArmAction = DateTime.Now;                            Logging.Log("Arm: Waiting for items");                          State = ArmState.WaitForItems;                      }                      else if (!itemMoved)                      {                          if (AmmoToLoad.Count > 0)                              foreach (var ammo in AmmoToLoad)                              {                                  Logging.Log("Arm: Missing ammo with TypeId [" + ammo.TypeId + "]");                              }                            if (!_missionItemMoved)                              Logging.Log("Arm: Missing mission item [" + bringItem + "]");                            State = ArmState.NotEnoughAmmo;                      }                      break;                    case ArmState.WaitForItems:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds < (int)Time.Armstate_WaitforItemstoMove_seconds)                          break;                        if (cargo.Items.Count == 0)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          // Close the drone bay' its not required in space.                          if (droneBay.IsReady)                              droneBay.Window.Close();                            Logging.Log("Arm: Done");                            //reload the ammo setting for combat                          try                          {                              var mission = Cache.Instance.DirectEve.AgentMissions.FirstOrDefault(m => m.AgentId == AgentId);                              if (mission == null)                                  return;                                var missionName = Cache.Instance.FilterPath(mission.Name);                              var missionXmlPath = Path.Combine(Settings.Instance.MissionsPath' missionName + ".xml");                              var missionXml = XDocument.Load(missionXmlPath);                              Cache.Instance.missionAmmo = new List<Ammo>();                              var ammoTypes = missionXml.Root.Element("missionammo");                              if (ammoTypes != null)                                  foreach (var ammo in ammoTypes.Elements("ammo"))                                      Cache.Instance.missionAmmo.Add(new Ammo(ammo));                          }                          catch (Exception e)                          {                              Logging.Log("Arms.WaitForItems: Unable to load missionammo from mission XML: no XML found' " + e.Message);                              Cache.Instance.missionAmmo = new List<Ammo>();                          }                            State = ArmState.Done;                          break;                      }                        // Note' there's no unlock here as we *always* want our ammo!                      break;              }
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_shield_percentage_this_pocket = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_armor_percentage_this_pocket = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_capacitor_percentage_this_pocket = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_shield_percentage_this_mission = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_armor_percentage_this_mission = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,Cache,The following statement contains a magic number: lowest_capacitor_percentage_this_mission = 100;
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The following statement contains a magic number: if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons)              {                  if (Cache.Instance.MissionWeaponGroupId == 55 || Cache.Instance.MissionWeaponGroupId == 508)                  {                      if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates)                          return targets.Where(t => !t.TargetValue.HasValue && t.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && t.Distance < distance).OrderByDescending(t => t.Distance).FirstOrDefault();                      if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance < (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates)                          lowValueTarget = null;                  }              }
Magic Number,Questor.Modules,Cache,C:\repos\Da-Teach_Questor\Questor.Modules\Cache.cs,GetBestTarget,The following statement contains a magic number: if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons)              {                  if (Cache.Instance.MissionWeaponGroupId == 55 || Cache.Instance.MissionWeaponGroupId == 508)                  {                      if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates)                          return targets.Where(t => !t.TargetValue.HasValue && t.Distance > (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && t.Distance < distance).OrderByDescending(t => t.Distance).FirstOrDefault();                      if (lowValueTarget != null && !lowValueFirst && lowValueTarget.Distance < (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates)                          lowValueTarget = null;                  }              }
Magic Number,Questor.Modules,CharSchedule,C:\repos\Da-Teach_Questor\Questor.Modules\CharSchedule.cs,CharSchedule,The following statement contains a magic number: if (_start != null)              {                  if (!DateTime.TryParseExact(_start' "HH:mm"' enUS' DateTimeStyles.None' out _startTime))                  {                      Logging.Log("[CharSchedule] " + Name + ": Couldn't parse starttime.");                      _startTime = DateTime.Now.AddSeconds(20);                  }                  else                      startTimeSpecified = true;              }              else              {                  Logging.Log("[CharSchedule] No start time specified. Starting now.");                  _startTime = DateTime.Now.AddSeconds(20);              }
Magic Number,Questor.Modules,CharSchedule,C:\repos\Da-Teach_Questor\Questor.Modules\CharSchedule.cs,CharSchedule,The following statement contains a magic number: if (_start != null)              {                  if (!DateTime.TryParseExact(_start' "HH:mm"' enUS' DateTimeStyles.None' out _startTime))                  {                      Logging.Log("[CharSchedule] " + Name + ": Couldn't parse starttime.");                      _startTime = DateTime.Now.AddSeconds(20);                  }                  else                      startTimeSpecified = true;              }              else              {                  Logging.Log("[CharSchedule] No start time specified. Starting now.");                  _startTime = DateTime.Now.AddSeconds(20);              }
Magic Number,Questor.Modules,CharSchedule,C:\repos\Da-Teach_Questor\Questor.Modules\CharSchedule.cs,CharSchedule,The following statement contains a magic number: if (_stop != null)              {                  if (!DateTime.TryParseExact(_stop' "HH:mm"' enUS' DateTimeStyles.None' out _stopTime))                  {                      Logging.Log("[CharSchedule] " + Name + ": Couldn't parse stoptime.");                      _stopTime = DateTime.Now.AddHours(24);                  }                  else                      stopTimeSpecified = true;              }              else              {                  Logging.Log("[CharSchedule] No stop time specified.");                  _stopTime = DateTime.Now.AddHours(24);              }
Magic Number,Questor.Modules,CharSchedule,C:\repos\Da-Teach_Questor\Questor.Modules\CharSchedule.cs,CharSchedule,The following statement contains a magic number: if (_stop != null)              {                  if (!DateTime.TryParseExact(_stop' "HH:mm"' enUS' DateTimeStyles.None' out _stopTime))                  {                      Logging.Log("[CharSchedule] " + Name + ": Couldn't parse stoptime.");                      _stopTime = DateTime.Now.AddHours(24);                  }                  else                      stopTimeSpecified = true;              }              else              {                  Logging.Log("[CharSchedule] No stop time specified.");                  _stopTime = DateTime.Now.AddHours(24);              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ReloadAll,The following statement contains a magic number: foreach (var weapon in weapons)              {                    if (weapon.CurrentCharges >= weapon.MaxCharges)                      return;                    if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      return;                    if (_lastWeaponReload.ContainsKey(weapon.ItemId) && DateTime.Now < _lastWeaponReload[weapon.ItemId].AddSeconds(22))                      return;                    _lastWeaponReload[weapon.ItemId] = DateTime.Now;                    if (weapon.Charge.TypeId == charge.TypeId)                  {                      Logging.Log("AnomalyController: Reloading All [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                        weapon.ReloadAmmo(charge);                  }                }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (closest.Distance < (int)Distance.WayTooClose)                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          closest.Orbit((int)Distance.GateActivationRange);                          Logging.Log("AnomolyController: Activate: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                          _lastOrbit = DateTime.Now;                      }                  }                  Logging.Log(" dist " + closest.Distance);                  if (closest.Distance >= (int)Distance.WayTooClose)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      ReloadAll();                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                      Logging.Log("AnomalyController.Activate: Activate [" + closest.Name + "] and change state to 'NextPocket'");                        _lastActivateAction = DateTime.Now;                      State = AnomalyControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      Logging.Log("AnomalyController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "]");                      closest.Approach();                  }              }              else              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                                        if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > 2)                  {                  // Probably never happens                  closest.AlignTo();                  _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (closest.Distance < (int)Distance.WayTooClose)                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          closest.Orbit((int)Distance.GateActivationRange);                          Logging.Log("AnomolyController: Activate: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                          _lastOrbit = DateTime.Now;                      }                  }                  Logging.Log(" dist " + closest.Distance);                  if (closest.Distance >= (int)Distance.WayTooClose)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      ReloadAll();                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                      Logging.Log("AnomalyController.Activate: Activate [" + closest.Name + "] and change state to 'NextPocket'");                        _lastActivateAction = DateTime.Now;                      State = AnomalyControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      Logging.Log("AnomalyController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "]");                      closest.Approach();                  }              }              else              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                                        if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > 2)                  {                  // Probably never happens                  closest.AlignTo();                  _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                  // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                          if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("AnomalyController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("AnomalyController.ClearPocket: Approaching target [" + target.Name + "][ID: " + target.Id + "]");                        if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              target.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("AnomolyController: Clearpocket: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                          }                      }                      else                      {                          if (target.Distance > Cache.Instance.OrbitDistance + (int)Distance.OrbitDistanceCushion)                              target.Approach(Cache.Instance.OrbitDistance);                          else                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("AnomalyController: ClearPocket: Stop Ship. we are in weapons range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                  // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                          if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("AnomalyController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("AnomalyController.ClearPocket: Approaching target [" + target.Name + "][ID: " + target.Id + "]");                        if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              target.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("AnomolyController: Clearpocket: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                          }                      }                      else                      {                          if (target.Distance > Cache.Instance.OrbitDistance + (int)Distance.OrbitDistanceCushion)                              target.Approach(Cache.Instance.OrbitDistance);                          else                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("AnomalyController: ClearPocket: Stop Ship. we are in weapons range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ClearPocketAction,The following statement contains a magic number: if (!_clearPocketTimeout.HasValue)                  _clearPocketTimeout = DateTime.Now.AddSeconds(5);
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,MoveToAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // We are close enough to whatever we needed to move to                  _currentAction++;                    if (Cache.Instance.Approaching != null)                  {                      Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                      Cache.Instance.Approaching = null;                      Logging.Log("AnomolyController: MoveTo: Stop ship' we are in range");                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      Logging.Log("AnomalyController.MoveTo: Approaching target [" + closest.Name + "][ID: " + closest.Id + "]");                      closest.Approach();                  }              }              else              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > 2)                  {                  // Probably never happens                  closest.AlignTo();                  _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,WaitUntilTargeted,The following statement contains a magic number: if (!int.TryParse(action.GetParameterValue("timeout")' out timeout))                  timeout = 30;
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,KillAction,The following statement contains a magic number: if (closest.Distance < Cache.Instance.WeaponRange)              {                  if (!Cache.Instance.PriorityTargets.Any(pt => pt.Id == closest.Id))                  {                      Logging.Log("AnomalyController.Kill: Adding [" + closest.Name + "][ID: " + closest.Id + "] as a priority target");                      Cache.Instance.AddPriorityTargets(new[] {closest}' Priority.PriorityKillTarget);                  }              }              else              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      Logging.Log("AnomalyController.Kill: Approaching target [" + closest.Name + "][ID: " + closest.Id + "]");                        if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("AnomalyController: Kill: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                          }                      }                      else                      {                          if (closest.Distance > Cache.Instance.OrbitDistance + (int)Distance.OrbitDistanceCushion)                          {                              closest.Approach(Cache.Instance.OrbitDistance);                              Logging.Log("AnomalyController: Kill: initiating Orbit of [" + closest.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                          }                          else                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("AnomalyController: Kill: Stop ship' we are in weapons range");                          }                      }                  }              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case AnomalyControllerState.Idle:                  case AnomalyControllerState.Done:                  case AnomalyControllerState.Error:                      break;                    case AnomalyControllerState.Start:                      _pocket = 0;                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = AnomalyControllerState.LoadPocket;                      break;                    case AnomalyControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(0' _pocket' false));                        if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("AnomalyController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("AnomalyController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("AnomalyController: Action." + a);  					  					if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)  						Logging.Log("AnomalyController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);  						                      // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = AnomalyControllerState.ExecutePocketActions;                      break;                    case AnomalyControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("AnomalyController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = AnomalyControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("AnomalyController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("AnomalyController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case AnomalyControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("AnomalyController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = AnomalyControllerState.LoadPocket;                      }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("AnomalyController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = AnomalyControllerState.ExecutePocketActions;                      }                      break;              }
Magic Number,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case AnomalyControllerState.Idle:                  case AnomalyControllerState.Done:                  case AnomalyControllerState.Error:                      break;                    case AnomalyControllerState.Start:                      _pocket = 0;                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = AnomalyControllerState.LoadPocket;                      break;                    case AnomalyControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(0' _pocket' false));                        if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("AnomalyController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("AnomalyController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("AnomalyController: Action." + a);  					  					if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)  						Logging.Log("AnomalyController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);  						                      // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = AnomalyControllerState.ExecutePocketActions;                      break;                    case AnomalyControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("AnomalyController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = AnomalyControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("AnomalyController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("AnomalyController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case AnomalyControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("AnomalyController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = AnomalyControllerState.LoadPocket;                      }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("AnomalyController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = AnomalyControllerState.ExecutePocketActions;                      }                      break;              }
Magic Number,Questor.Modules,Cleanup,C:\repos\Da-Teach_Questor\Questor.Modules\Cleanup.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case CleanupState.Start:                      //Cleanup State should only start every 20 seconds                      if (DateTime.Now.Subtract(_lastCleanupAction).TotalSeconds < 20)                          break;                        State = CleanupState.CheckModalWindows;                      break;                    case CleanupState.CheckModalWindows:                      //                      // go through *every* window                      //                      foreach (var window in Cache.Instance.Windows)                      {                          // Telecom messages are generally mission info messages: close them                          if (window.Name == "telecom")                          {                              Logging.Log("Cleanup: Closing telecom message...");                              Logging.Log("Cleanup: Content of telecom window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                              window.Close();                          }                            // Modal windows must be closed                          // But lets only close known modal windows                          if (window.Name == "modal")                          {                              bool close = false;                              bool restart = false;                              bool gotobasenow = false;                              bool sayyes = false;                              //bool sayno = false;                              if (!string.IsNullOrEmpty(window.Html))                              {                                  // Server going down /unscheduled/ potentially very soon!                                   // CCP does not reboot in the middle of the day because the server is behaving                                  // dock now to avoid problems                                  gotobasenow |= window.Html.Contains("for a short unscheduled reboot");                                                                    // Server going down                                  close |= window.Html.Contains("Please make sure your characters are out of harm");                                  close |= window.Html.Contains("the servers are down for 30 minutes each day for maintenance and updates");                                  if (window.Html.Contains("The socket was closed"))                                  {                                      Logging.Log("Cleanup: This window indicates we are disconnected: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                                      //Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdLogOff); //this causes the questor window to not re-appear                                      Cache.Instance.CloseQuestorCMDLogoff = false;                                      Cache.Instance.CloseQuestorCMDExitGame = true;                                      Cache.Instance.ReasonToStopQuestor = "The socket was closed";                                      Cache.Instance.SessionState = "Quitting";                                      break;                                  }                                    // In space "shit"                                  close |= window.Html.Contains("Item cannot be moved back to a loot container.");                                  close |= window.Html.Contains("you do not have the cargo space");                                  close |= window.Html.Contains("cargo units would be required to complete this operation.");                                  close |= window.Html.Contains("You are too far away from the acceleration gate to activate it!");                                  close |= window.Html.Contains("maximum distance is 2500 meters");                                  // Stupid warning' lets see if we can find it                                  close |= window.Html.Contains("Do you wish to proceed with this dangerous action?");                                  // Yes we know the mission isnt complete' Questor will just redo the mission                                  close |= window.Html.Contains("Please check your mission journal for further information.");                                  close |= window.Html.Contains("weapons in that group are already full");                                  close |= window.Html.Contains("You have to be at the drop off location to deliver the items in person");                                  // Lag :/                                  close |= window.Html.Contains("This gate is locked!");                                  close |= window.Html.Contains("The Zbikoki's Hacker Card");                                  close |= window.Html.Contains(" units free.");                                  close |= window.Html.Contains("already full");                                  //                                  // restart the client if these are encountered                                  //                                  restart |= window.Html.Contains("Local cache is corrupt");                                  restart |= window.Html.Contains("Local session information is corrupt");                                  restart |= window.Html.Contains("The connection to the server was closed"); 										//CONNECTION LOST                                  restart |= window.Html.Contains("server was closed");  																//CONNECTION LOST                                  restart |= window.Html.Contains("The socket was closed"); 															//CONNECTION LOST                                  restart |= window.Html.Contains("The connection was closed"); 														//CONNECTION LOST                                  restart |= window.Html.Contains("Connection to server lost"); 														//INFORMATION                                  restart |= window.Html.Contains("The user connection has been usurped on the proxy"); 								//CONNECTION LOST                                  restart |= window.Html.Contains("The transport has not yet been connected' or authentication was not successful"); 	//CONNECTION LOST                                  //                                  // Modal Dialogs the need "yes" pressed                                  //                                  sayyes |= window.Html.Contains("objectives requiring a total capacity");                                  sayyes |= window.Html.Contains("your ship only has space for");                                  //                                  // Modal Dialogs the need "no" pressed                                  //                                  //sayno |= window.Html.Contains("Do you wish to proceed with this dangerous action                              }                              if (sayyes)                              {                                  Logging.Log("Cleanup: Found a window that needs 'yes' chosen...");                                  Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                                  window.AnswerModal("Yes");                                  continue;                              }                              if (close)                              {                                  Logging.Log("Cleanup: Closing modal window...");                                  Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                                  window.Close();                                  continue;                              }                                if (restart)                              {                                  Logging.Log("Cleanup: Restarting eve...");                                  Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                                  Cache.Instance.CloseQuestorCMDLogoff = false;                                  Cache.Instance.CloseQuestorCMDExitGame = true;                                  Cache.Instance.ReasonToStopQuestor = "A message from ccp indicated we were disconnected";                                  Cache.Instance.SessionState = "Quitting";                                  window.Close();                                  continue;                              }                              if (gotobasenow)                              {                                  Logging.Log("Cleanup: Evidentially the cluster is dieing... and CCP is restarting the server");                                  Logging.Log("Cleanup: Content of modal window (HTML): [" + (window.Html ?? string.Empty).Replace("\n"' "").Replace("\r"' "") + "]");                                  Cache.Instance.GotoBaseNow = true;                                  Settings.Instance.AutoStart = false;                                  //                                  // do not close eve' let the shutdown of the server do that                                  //                                  //Cache.Instance.CloseQuestorCMDLogoff = false;                                  //Cache.Instance.CloseQuestorCMDExitGame = true;                                  //Cache.Instance.ReasonToStopQuestor = "A message from ccp indicated we were disonnected";                                  //Cache.Instance.SessionState = "Quitting";                                  window.Close();                                  continue;                              }                          }                      }                      State = CleanupState.Done;                      break;                        case CleanupState.Done:                      _lastCleanupAction = DateTime.Now;                      State = CleanupState.Start;                      break;                    default:                      // Next state                      State = CleanupState.Start;                      break;              }
Magic Number,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case StatisticsState.Idle:                      //This State should only start every 20 seconds                      //if (DateTime.Now.Subtract(_lastCleanupAction).TotalSeconds < 20)                      //    break;                        //State = StatisticsState.CheckModalWindows;                      break;                    case StatisticsState.MissionLog:                      //Logging.Log("StatisticsState: StatisticsState.MissionLog: Entered this state");                      if (!Statistics.Instance.MissionLoggingStarted) //this makes sure we only set the timestamp once (keep in mind this will potentially run many times before completing)                      {                          if (Statistics.Instance.DebugMissionStatistics) Logging.Log("MissionLoggingStarted is" + Statistics.Instance.MissionLoggingStartedTimestamp);                          Statistics.Instance.MissionLoggingStartedTimestamp = DateTime.Now;                          Statistics.Instance.MissionLoggingStarted = true;                      }                        //Logging.Log("StatisticsState: MissionLogCompleted is false: we still need to create the mission logs for this last mission");                      //if (Cache.Instance.Agent.LoyaltyPoints == -1) //if this agent has no loyalty points associated then you didn't complete a mission yet.                      //{                      //    Logging.Log("We do not have loyalty points with the current agent yet' still -1");                      //    _lastAction = DateTime.Now;                      //    return;                      //}                      if (DateTime.Now.Subtract(Statistics.Instance.FinishedSalvaging).TotalMinutes > 10 || DateTime.Now.Subtract(Cache.Instance.StartTime).TotalMinutes < 5) //FinishedSalvaging is the later of the 2 timestamps (FinishedMission and FinishedSalvaging)' if you aren't after mission salvaging this timestamp is the same as FinishedMission                      {                          Logging.Log("Statistics: It is unlikely a mission has been run... No Mission log will be written.");                          Statistics.Instance.MissionLoggingCompleted = true; //if the mission was completed more than 10 min ago assume the logging has been done already.                          return;                      }                      else                      {                          //Logging.Log("Statistics: it has not been more than 10 minutes since the last mission was finished. The Mission log should be written.");                                                  }                        if (Statistics.Instance.DebugMissionStatistics) // we only need to see the following wall of comments if debugging mission statistics                      {                          Logging.Log("...Checking to see if we should create a mission log now...");                          Logging.Log(" ");                          Logging.Log(" ");                          Logging.Log("The Rules for After Mission Logging are as Follows...");                          Logging.Log("1)  we must have loyalty points with the current agent (disabled at the moment)"); //which we already verified if we got this far                          Logging.Log("2) Cache.Instance.MissionName must not be empty - we must have had a mission already this session");                          Logging.Log("AND");                          Logging.Log("3a Cache.Instance.mission == null - their must not be a current mission OR");                          Logging.Log("3b Cache.Instance.mission.State != (int)MissionState.Accepted) - the missionstate isn't 'Accepted'");                          Logging.Log(" ");                          Logging.Log(" ");                          Logging.Log("If those are all met then we get to create a log for the previous mission.");                            if (!string.IsNullOrEmpty(Cache.Instance.MissionName)) //condition 1                          {                              Logging.Log("1 We must have a mission because Missionmame is filled in");                              Logging.Log("1 Mission is: " + Cache.Instance.MissionName);                                  if (Cache.Instance.mission != null) //condition 2                              {                                  Logging.Log("2 Cache.Instance.mission is: " + Cache.Instance.mission);                                  Logging.Log("2 Cache.Instance.mission.Name is: " + Cache.Instance.mission.Name);                                  Logging.Log("2 Cache.Instance.mission.State is: " + Cache.Instance.mission.State);                                    if (Cache.Instance.mission.State != (int)MissionState.Accepted) //condition 3                                  {                                      Logging.Log("MissionState is NOT Accepted: which is correct if we want to do logging");                                  }                                  else                                  {                                      Logging.Log("MissionState is Accepted: which means the mission is not yet complete");                                      Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                                  }                              }                              else                              {                                  Logging.Log("mission is NUL - which means we have no current mission");                                  Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                              }                          }                          else                          {                              Logging.Log("1 We must NOT have had a mission yet because MissionName is not filled in");                              Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                          }                      }                      if (!string.IsNullOrEmpty(Cache.Instance.MissionName) && (Cache.Instance.mission == null || (Cache.Instance.mission.State != (int)MissionState.Accepted)))                      {                          Statistics.Instance.MissionsThisSession = Statistics.Instance.MissionsThisSession + 1;                          if (Statistics.Instance.DebugMissionStatistics) Logging.Log("We jumped through all the hoops: now do the mission logging");                          Cache.Instance.SessionIskGenerated = (Cache.Instance.SessionIskGenerated + (Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth));                          Cache.Instance.SessionLootGenerated = (Cache.Instance.SessionLootGenerated + (int)LootValue);                          Cache.Instance.SessionLPGenerated = (Cache.Instance.SessionLPGenerated + (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints));                          if (Settings.Instance.MissionStats1Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats1LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats1LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats1LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats1LogFile' "Date;Mission;TimeMission;TimeSalvage;TotalTime;Isk;Loot;LP;\r\n");                                // Build the line                              var line = DateTime.Now + ";";                                                      // Date                              line += Cache.Instance.MissionName + ";";                                                               // Mission                              line += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";         // TimeMission                              line += ((int)DateTime.Now.Subtract(Statistics.Instance.FinishedMission).TotalMinutes) + ";";           // Time Doing After Mission Salvaging                              line += ((int)DateTime.Now.Subtract(Statistics.Instance.StartedMission).TotalMinutes) + ";";            // Total Time doing Mission                              line += ((int)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                      // Isk (balance difference from start and finish of mission: is not accurate as the wallet ticks from bounty kills are every x minuts)                              line += ((int)Statistics.Instance.LootValue) + ";";                                                     // Loot                              line += (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";\r\n";                                 // LP                                // The mission is finished                              File.AppendAllText(Settings.Instance.MissionStats1LogFile' line);                              Logging.Log("Questor: writing mission log1 to  [ " + Settings.Instance.MissionStats1LogFile);                          }                          if (Settings.Instance.MissionStats2Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats2LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats2LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats2LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats2LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue\r\n");                                // Build the line                              var line2 = string.Format("{0:MM/dd/yyyy HH:mm:ss}"' DateTime.Now) + ";";                               // Date                              line2 += Cache.Instance.MissionName + ";";                                                              // Mission                              line2 += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";        // TimeMission                              line2 += ((int)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                     // Isk                              line2 += ((int)Statistics.Instance.LootValue) + ";";                                                    // Loot                              line2 += (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";";                                    // LP                              line2 += ((int)Statistics.Instance.LostDrones) + ";";                                                   // Lost Drones                              line2 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                              // Ammo Consumption                              line2 += ((int)Statistics.Instance.AmmoValue) + ";\r\n";                                                // Ammo Value                                // The mission is finished                              Logging.Log("Questor: writing mission log2 to [ " + Settings.Instance.MissionStats2LogFile);                              File.AppendAllText(Settings.Instance.MissionStats2LogFile' line2);                          }                          if (Settings.Instance.MissionStats3Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats3LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats3LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats3LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats3LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue;Panics;LowestShield;LowestArmor;LowestCap;RepairCycles\r\n");                                // Build the line                              var line3 = DateTime.Now + ";";                                                                          // Date                              line3 += Cache.Instance.MissionName + ";";                                                               // Mission                              line3 += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";         // TimeMission                              line3 += ((long)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                     // Isk                              line3 += ((long)Statistics.Instance.LootValue) + ";";                                                    // Loot                              line3 += ((long)Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";";                               // LP                              line3 += ((int)Statistics.Instance.LostDrones) + ";";                                                    // Lost Drones                              line3 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                               // Ammo Consumption                              line3 += ((int)Statistics.Instance.AmmoValue) + ";";                                                     // Ammo Value                              line3 += ((int)Cache.Instance.panic_attempts_this_mission) + ";";                                        // Panics                              line3 += ((int)Cache.Instance.lowest_shield_percentage_this_mission) + ";";                              // Lowest Shield %                              line3 += ((int)Cache.Instance.lowest_armor_percentage_this_mission) + ";";                               // Lowest Armor %                              line3 += ((int)Cache.Instance.lowest_capacitor_percentage_this_mission) + ";";                           // Lowest Capacitor %                              line3 += ((int)Cache.Instance.repair_cycle_time_this_mission) + ";";                                     // repair Cycle Time                              line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ";"; // After Mission Salvaging Time                              line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ((int)FinishedMission.Subtract(StartedMission).TotalMinutes) + ";\r\n"; // Total Time' Mission + After Mission Salvaging (if any)                                // The mission is finished                              Logging.Log("Questor: writing mission log3 to  [ " + Settings.Instance.MissionStats3LogFile);                              File.AppendAllText(Settings.Instance.MissionStats3LogFile' line3);                          }                          // Disable next log line                          Cache.Instance.MissionName = null;                          Statistics.Instance.MissionLoggingCompleted = true;                      }                      State = StatisticsState.Idle;                      break;                    case StatisticsState.PocketLog:                      State = StatisticsState.Idle;                      break;                    case StatisticsState.SessionLog:                      State = StatisticsState.Idle;                      break;                    case StatisticsState.Done:                      _lastStatisticsAction = DateTime.Now;                      State = StatisticsState.Idle;                      break;                    default:                      // Next state                      State = StatisticsState.Idle;                      break;              }
Magic Number,Questor.Modules,Statistics,C:\repos\Da-Teach_Questor\Questor.Modules\Statistics.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case StatisticsState.Idle:                      //This State should only start every 20 seconds                      //if (DateTime.Now.Subtract(_lastCleanupAction).TotalSeconds < 20)                      //    break;                        //State = StatisticsState.CheckModalWindows;                      break;                    case StatisticsState.MissionLog:                      //Logging.Log("StatisticsState: StatisticsState.MissionLog: Entered this state");                      if (!Statistics.Instance.MissionLoggingStarted) //this makes sure we only set the timestamp once (keep in mind this will potentially run many times before completing)                      {                          if (Statistics.Instance.DebugMissionStatistics) Logging.Log("MissionLoggingStarted is" + Statistics.Instance.MissionLoggingStartedTimestamp);                          Statistics.Instance.MissionLoggingStartedTimestamp = DateTime.Now;                          Statistics.Instance.MissionLoggingStarted = true;                      }                        //Logging.Log("StatisticsState: MissionLogCompleted is false: we still need to create the mission logs for this last mission");                      //if (Cache.Instance.Agent.LoyaltyPoints == -1) //if this agent has no loyalty points associated then you didn't complete a mission yet.                      //{                      //    Logging.Log("We do not have loyalty points with the current agent yet' still -1");                      //    _lastAction = DateTime.Now;                      //    return;                      //}                      if (DateTime.Now.Subtract(Statistics.Instance.FinishedSalvaging).TotalMinutes > 10 || DateTime.Now.Subtract(Cache.Instance.StartTime).TotalMinutes < 5) //FinishedSalvaging is the later of the 2 timestamps (FinishedMission and FinishedSalvaging)' if you aren't after mission salvaging this timestamp is the same as FinishedMission                      {                          Logging.Log("Statistics: It is unlikely a mission has been run... No Mission log will be written.");                          Statistics.Instance.MissionLoggingCompleted = true; //if the mission was completed more than 10 min ago assume the logging has been done already.                          return;                      }                      else                      {                          //Logging.Log("Statistics: it has not been more than 10 minutes since the last mission was finished. The Mission log should be written.");                                                  }                        if (Statistics.Instance.DebugMissionStatistics) // we only need to see the following wall of comments if debugging mission statistics                      {                          Logging.Log("...Checking to see if we should create a mission log now...");                          Logging.Log(" ");                          Logging.Log(" ");                          Logging.Log("The Rules for After Mission Logging are as Follows...");                          Logging.Log("1)  we must have loyalty points with the current agent (disabled at the moment)"); //which we already verified if we got this far                          Logging.Log("2) Cache.Instance.MissionName must not be empty - we must have had a mission already this session");                          Logging.Log("AND");                          Logging.Log("3a Cache.Instance.mission == null - their must not be a current mission OR");                          Logging.Log("3b Cache.Instance.mission.State != (int)MissionState.Accepted) - the missionstate isn't 'Accepted'");                          Logging.Log(" ");                          Logging.Log(" ");                          Logging.Log("If those are all met then we get to create a log for the previous mission.");                            if (!string.IsNullOrEmpty(Cache.Instance.MissionName)) //condition 1                          {                              Logging.Log("1 We must have a mission because Missionmame is filled in");                              Logging.Log("1 Mission is: " + Cache.Instance.MissionName);                                  if (Cache.Instance.mission != null) //condition 2                              {                                  Logging.Log("2 Cache.Instance.mission is: " + Cache.Instance.mission);                                  Logging.Log("2 Cache.Instance.mission.Name is: " + Cache.Instance.mission.Name);                                  Logging.Log("2 Cache.Instance.mission.State is: " + Cache.Instance.mission.State);                                    if (Cache.Instance.mission.State != (int)MissionState.Accepted) //condition 3                                  {                                      Logging.Log("MissionState is NOT Accepted: which is correct if we want to do logging");                                  }                                  else                                  {                                      Logging.Log("MissionState is Accepted: which means the mission is not yet complete");                                      Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                                  }                              }                              else                              {                                  Logging.Log("mission is NUL - which means we have no current mission");                                  Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                              }                          }                          else                          {                              Logging.Log("1 We must NOT have had a mission yet because MissionName is not filled in");                              Statistics.Instance.MissionLoggingCompleted = true; //if if it isn't true - this means we shouldn't be trying to log mission stats atm                          }                      }                      if (!string.IsNullOrEmpty(Cache.Instance.MissionName) && (Cache.Instance.mission == null || (Cache.Instance.mission.State != (int)MissionState.Accepted)))                      {                          Statistics.Instance.MissionsThisSession = Statistics.Instance.MissionsThisSession + 1;                          if (Statistics.Instance.DebugMissionStatistics) Logging.Log("We jumped through all the hoops: now do the mission logging");                          Cache.Instance.SessionIskGenerated = (Cache.Instance.SessionIskGenerated + (Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth));                          Cache.Instance.SessionLootGenerated = (Cache.Instance.SessionLootGenerated + (int)LootValue);                          Cache.Instance.SessionLPGenerated = (Cache.Instance.SessionLPGenerated + (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints));                          if (Settings.Instance.MissionStats1Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats1LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats1LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats1LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats1LogFile' "Date;Mission;TimeMission;TimeSalvage;TotalTime;Isk;Loot;LP;\r\n");                                // Build the line                              var line = DateTime.Now + ";";                                                      // Date                              line += Cache.Instance.MissionName + ";";                                                               // Mission                              line += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";         // TimeMission                              line += ((int)DateTime.Now.Subtract(Statistics.Instance.FinishedMission).TotalMinutes) + ";";           // Time Doing After Mission Salvaging                              line += ((int)DateTime.Now.Subtract(Statistics.Instance.StartedMission).TotalMinutes) + ";";            // Total Time doing Mission                              line += ((int)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                      // Isk (balance difference from start and finish of mission: is not accurate as the wallet ticks from bounty kills are every x minuts)                              line += ((int)Statistics.Instance.LootValue) + ";";                                                     // Loot                              line += (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";\r\n";                                 // LP                                // The mission is finished                              File.AppendAllText(Settings.Instance.MissionStats1LogFile' line);                              Logging.Log("Questor: writing mission log1 to  [ " + Settings.Instance.MissionStats1LogFile);                          }                          if (Settings.Instance.MissionStats2Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats2LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats2LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats2LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats2LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue\r\n");                                // Build the line                              var line2 = string.Format("{0:MM/dd/yyyy HH:mm:ss}"' DateTime.Now) + ";";                               // Date                              line2 += Cache.Instance.MissionName + ";";                                                              // Mission                              line2 += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";        // TimeMission                              line2 += ((int)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                     // Isk                              line2 += ((int)Statistics.Instance.LootValue) + ";";                                                    // Loot                              line2 += (Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";";                                    // LP                              line2 += ((int)Statistics.Instance.LostDrones) + ";";                                                   // Lost Drones                              line2 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                              // Ammo Consumption                              line2 += ((int)Statistics.Instance.AmmoValue) + ";\r\n";                                                // Ammo Value                                // The mission is finished                              Logging.Log("Questor: writing mission log2 to [ " + Settings.Instance.MissionStats2LogFile);                              File.AppendAllText(Settings.Instance.MissionStats2LogFile' line2);                          }                          if (Settings.Instance.MissionStats3Log)                          {                              if (!Directory.Exists(Settings.Instance.MissionStats3LogPath))                                  Directory.CreateDirectory(Settings.Instance.MissionStats3LogPath);                                // Write the header                              if (!File.Exists(Settings.Instance.MissionStats3LogFile))                                  File.AppendAllText(Settings.Instance.MissionStats3LogFile' "Date;Mission;Time;Isk;Loot;LP;LostDrones;AmmoConsumption;AmmoValue;Panics;LowestShield;LowestArmor;LowestCap;RepairCycles\r\n");                                // Build the line                              var line3 = DateTime.Now + ";";                                                                          // Date                              line3 += Cache.Instance.MissionName + ";";                                                               // Mission                              line3 += ((int)Statistics.Instance.FinishedMission.Subtract(StartedMission).TotalMinutes) + ";";         // TimeMission                              line3 += ((long)(Cache.Instance.DirectEve.Me.Wealth - Cache.Instance.Wealth)) + ";";                     // Isk                              line3 += ((long)Statistics.Instance.LootValue) + ";";                                                    // Loot                              line3 += ((long)Cache.Instance.Agent.LoyaltyPoints - LoyaltyPoints) + ";";                               // LP                              line3 += ((int)Statistics.Instance.LostDrones) + ";";                                                    // Lost Drones                              line3 += ((int)Statistics.Instance.AmmoConsumption) + ";";                                               // Ammo Consumption                              line3 += ((int)Statistics.Instance.AmmoValue) + ";";                                                     // Ammo Value                              line3 += ((int)Cache.Instance.panic_attempts_this_mission) + ";";                                        // Panics                              line3 += ((int)Cache.Instance.lowest_shield_percentage_this_mission) + ";";                              // Lowest Shield %                              line3 += ((int)Cache.Instance.lowest_armor_percentage_this_mission) + ";";                               // Lowest Armor %                              line3 += ((int)Cache.Instance.lowest_capacitor_percentage_this_mission) + ";";                           // Lowest Capacitor %                              line3 += ((int)Cache.Instance.repair_cycle_time_this_mission) + ";";                                     // repair Cycle Time                              line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ";"; // After Mission Salvaging Time                              line3 += ((int)Statistics.Instance.FinishedSalvaging.Subtract(Statistics.Instance.StartedSalvaging).TotalMinutes) + ((int)FinishedMission.Subtract(StartedMission).TotalMinutes) + ";\r\n"; // Total Time' Mission + After Mission Salvaging (if any)                                // The mission is finished                              Logging.Log("Questor: writing mission log3 to  [ " + Settings.Instance.MissionStats3LogFile);                              File.AppendAllText(Settings.Instance.MissionStats3LogFile' line3);                          }                          // Disable next log line                          Cache.Instance.MissionName = null;                          Statistics.Instance.MissionLoggingCompleted = true;                      }                      State = StatisticsState.Idle;                      break;                    case StatisticsState.PocketLog:                      State = StatisticsState.Idle;                      break;                    case StatisticsState.SessionLog:                      State = StatisticsState.Idle;                      break;                    case StatisticsState.Done:                      _lastStatisticsAction = DateTime.Now;                      State = StatisticsState.Idle;                      break;                    default:                      // Next state                      State = StatisticsState.Idle;                      break;              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The following statement contains a magic number: if (weapon.Charge != null && weapon.Charge.TypeId == charge.TypeId)              {                  if (DateTime.Now.Subtract(_lastLoggingAction).TotalSeconds > 10)                  {                       Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds;                      _lastLoggingAction = DateTime.Now;                  }                  Logging.Log("Combat: Reloading [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                  weapon.ReloadAmmo(charge);              }              else              {                  if (DateTime.Now.Subtract(_lastLoggingAction).TotalSeconds > 10)                  {                      Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds;                      _lastLoggingAction = DateTime.Now;                  }                  Logging.Log("Combat: Changing [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                  weapon.ChangeAmmo(charge);              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadNormalAmmo,The following statement contains a magic number: if (weapon.Charge != null && weapon.Charge.TypeId == charge.TypeId)              {                  if (DateTime.Now.Subtract(_lastLoggingAction).TotalSeconds > 10)                  {                       Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds;                      _lastLoggingAction = DateTime.Now;                  }                  Logging.Log("Combat: Reloading [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                  weapon.ReloadAmmo(charge);              }              else              {                  if (DateTime.Now.Subtract(_lastLoggingAction).TotalSeconds > 10)                  {                      Cache.Instance.TimeSpentReloading_seconds = Cache.Instance.TimeSpentReloading_seconds + (int)Time.ReloadWeaponDelayBeforeUsable_seconds;                      _lastLoggingAction = DateTime.Now;                  }                  Logging.Log("Combat: Changing [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                  weapon.ChangeAmmo(charge);              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadEnergyWeaponAmmo,The following statement contains a magic number: if (_lastWeaponReload.ContainsKey(weapon.ItemId) && DateTime.Now < _lastWeaponReload[weapon.ItemId].AddSeconds(5))                  return false;
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ReloadAll,The following statement contains a magic number: foreach (var weapon in weapons)              {                  if (weapon.CurrentCharges >= weapon.MaxCharges)                      return;                    if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      return;                    if (_lastWeaponReload.ContainsKey(weapon.ItemId) && DateTime.Now < _lastWeaponReload[weapon.ItemId].AddSeconds(22))                      return;                  _lastWeaponReload[weapon.ItemId] = DateTime.Now;                    if (weapon.Charge.TypeId == charge.TypeId)                  {                      Logging.Log("Combat: ReloadingAll [" + weapon.ItemId + "] with [" + charge.TypeName + "][TypeID: " + charge.TypeId + "]");                      weapon.ReloadAmmo(charge);                  }                }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,CanActivate,The following statement contains a magic number: if (_lastModuleActivation.ContainsKey(module.ItemId))              {                  if (DateTime.Now.Subtract(_lastModuleActivation[module.ItemId]).TotalSeconds < 3)                      return false;                    _lastModuleActivation.Remove(module.ItemId);                  return true;              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The following statement contains a magic number: if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                  {                      target.Orbit(Cache.Instance.OrbitDistance);                      Logging.Log("Combat.ActivateWeapons: Initiating Orbit [" + target.Name + "][ID: " + target.Id + "]");                      _lastOrbit = DateTime.Now;                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The following statement contains a magic number: foreach (var weapon in weapons)              {                  // don't waste ammo on small target if you use autocannon or siege i hope you use drone                  if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons) //this defaults to false and needs to be changed in your characters settings xml file if you want to enable this option                  {                      if (Settings.Instance.WeaponGroupId == 55 || Settings.Instance.WeaponGroupId == 508 || Settings.Instance.WeaponGroupId == 506)                      {                      if (target.Distance <= (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && !target.TargetValue.HasValue && target.GroupId != (int)Group.LargeCollidableStructure)                          {                              weapon.Deactivate();                          }                      }                  }                  if (!weapon.IsActive)                      continue;                    if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      continue;                    // No ammo loaded                  if (weapon.Charge == null)                      continue;                    var ammo = Settings.Instance.Ammo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                    //use mission specific ammo                  if (Cache.Instance.missionAmmo.Count() != 0)                  {                      ammo = Cache.Instance.missionAmmo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                  }                    // How can this happen? Someone manually loaded ammo                  if (ammo == null)                      continue;                    // If we have already activated warp' deactivate the weapons                  if (!Cache.Instance.DirectEve.ActiveShip.Entity.IsWarping)                  {                      // Target is in range                      if(target.Distance <= ammo.Range)                      continue;                  }                  // Target is out of range' stop firing                  weapon.Deactivate();              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The following statement contains a magic number: foreach (var weapon in weapons)              {                  // don't waste ammo on small target if you use autocannon or siege i hope you use drone                  if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons) //this defaults to false and needs to be changed in your characters settings xml file if you want to enable this option                  {                      if (Settings.Instance.WeaponGroupId == 55 || Settings.Instance.WeaponGroupId == 508 || Settings.Instance.WeaponGroupId == 506)                      {                      if (target.Distance <= (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && !target.TargetValue.HasValue && target.GroupId != (int)Group.LargeCollidableStructure)                          {                              weapon.Deactivate();                          }                      }                  }                  if (!weapon.IsActive)                      continue;                    if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      continue;                    // No ammo loaded                  if (weapon.Charge == null)                      continue;                    var ammo = Settings.Instance.Ammo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                    //use mission specific ammo                  if (Cache.Instance.missionAmmo.Count() != 0)                  {                      ammo = Cache.Instance.missionAmmo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                  }                    // How can this happen? Someone manually loaded ammo                  if (ammo == null)                      continue;                    // If we have already activated warp' deactivate the weapons                  if (!Cache.Instance.DirectEve.ActiveShip.Entity.IsWarping)                  {                      // Target is in range                      if(target.Distance <= ammo.Range)                      continue;                  }                  // Target is out of range' stop firing                  weapon.Deactivate();              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The following statement contains a magic number: foreach (var weapon in weapons)              {                  // don't waste ammo on small target if you use autocannon or siege i hope you use drone                  if (Settings.Instance.DontShootFrigatesWithSiegeorAutoCannons) //this defaults to false and needs to be changed in your characters settings xml file if you want to enable this option                  {                      if (Settings.Instance.WeaponGroupId == 55 || Settings.Instance.WeaponGroupId == 508 || Settings.Instance.WeaponGroupId == 506)                      {                      if (target.Distance <= (int)Distance.InsideThisRangeIsLIkelyToBeMostlyFrigates && !target.TargetValue.HasValue && target.GroupId != (int)Group.LargeCollidableStructure)                          {                              weapon.Deactivate();                          }                      }                  }                  if (!weapon.IsActive)                      continue;                    if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      continue;                    // No ammo loaded                  if (weapon.Charge == null)                      continue;                    var ammo = Settings.Instance.Ammo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                    //use mission specific ammo                  if (Cache.Instance.missionAmmo.Count() != 0)                  {                      ammo = Cache.Instance.missionAmmo.FirstOrDefault(a => a.TypeId == weapon.Charge.TypeId);                  }                    // How can this happen? Someone manually loaded ammo                  if (ammo == null)                      continue;                    // If we have already activated warp' deactivate the weapons                  if (!Cache.Instance.DirectEve.ActiveShip.Entity.IsWarping)                  {                      // Target is in range                      if(target.Distance <= ammo.Range)                      continue;                  }                  // Target is out of range' stop firing                  weapon.Deactivate();              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateWeapons,The following statement contains a magic number: foreach (var weapon in weapons)              {                  // Are we reloading' deactivating or changing ammo?                  if (weapon.IsReloadingAmmo || weapon.IsDeactivating || weapon.IsChangingAmmo)                      continue;                  // Are we on the right target?                  if (weapon.IsActive)                  {                      if (weapon.TargetId != target.Id)                          weapon.Deactivate();                        continue;                  }                    // No' check ammo type and if that is correct' activate weapon                  if (ReloadAmmo(weapon' target) && CanActivate(weapon' target' true))                  {                      Logging.Log("Combat: Activating weapon [" + weapon.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                      weapon.Activate(target.Id);                      _nextWeaponAction = DateTime.Now.AddMilliseconds((int)Time.WeaponDelay_miliseconds);                      //we know we are connected if we were able to get this far - update the lastknownGoodConnectedTime                      Cache.Instance.lastKnownGoodConnectedTime = DateTime.Now;                      Cache.Instance.MyWalletBalance = Cache.Instance.DirectEve.Me.Wealth;                      return;                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateTargetPainters,The following statement contains a magic number: foreach (var painter in targetPainters)              {                  // Are we on the right target?                  if (painter.IsActive)                  {                      if (painter.TargetId != target.Id)                          painter.Deactivate();                        continue;                  }                    // Are we deactivating?                  if (painter.IsDeactivating)                      continue;                    if (CanActivate(painter' target' false))                  {                      Logging.Log("Combat: Activating painter [" + painter.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                      painter.Activate(target.Id);                      _nextPainterAction = DateTime.Now.AddMilliseconds((int)Time.PainterDelay_miliseconds);                      return;                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,The following statement contains a magic number: foreach (var nos in noses)              {                  // Are we on the right target?                  if (nos.IsActive)                  {                      if (nos.TargetId != target.Id)                          nos.Deactivate();                        continue;                  }                    // Are we deactivating?                  if (nos.IsDeactivating)                      continue;                  //Logging.Log("Combat: Distances Target[ " + Math.Round(target.Distance'0) + " Optimal[" + nos.OptimalRange.ToString()+"]");                  // Target is out of Nos range                  if (target.Distance >= Settings.Instance.NosDistance)                      continue;                    if (CanActivate(nos' target' false))                  {                      Logging.Log("Combat: Nos  [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                      nos.Activate(target.Id);                      _nextNosAction = DateTime.Now.AddMilliseconds((int)Time.NosDelay_miliseconds);                      return;                  }                  else                  {                      Logging.Log("Combat: Cannot Activate Nos [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,ActivateNos,The following statement contains a magic number: foreach (var nos in noses)              {                  // Are we on the right target?                  if (nos.IsActive)                  {                      if (nos.TargetId != target.Id)                          nos.Deactivate();                        continue;                  }                    // Are we deactivating?                  if (nos.IsDeactivating)                      continue;                  //Logging.Log("Combat: Distances Target[ " + Math.Round(target.Distance'0) + " Optimal[" + nos.OptimalRange.ToString()+"]");                  // Target is out of Nos range                  if (target.Distance >= Settings.Instance.NosDistance)                      continue;                    if (CanActivate(nos' target' false))                  {                      Logging.Log("Combat: Nos  [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away]");                      nos.Activate(target.Id);                      _nextNosAction = DateTime.Now.AddMilliseconds((int)Time.NosDelay_miliseconds);                      return;                  }                  else                  {                      Logging.Log("Combat: Cannot Activate Nos [" + nos.ItemId + "] on [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: for (var i = combatTargets.Count - 1; i >= 0; i--)              {                  var target = combatTargets[i];                  if (target.Distance > maxRange*1.5d)                  {                      Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] out of range [" + Math.Round(target.Distance/1000'0) + "k away]");                  }                  else if (Cache.Instance.IgnoreTargets.Contains(target.Name.Trim()))                  {                      Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] on ignore list [" + Math.Round(target.Distance/1000'0) + "k away]");                  }                  else continue;                    target.UnlockTarget();                  _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                  combatTargets.RemoveAt(i);                  return; //this does kind of negates the 'for' loop' but we want the pause between commands sent to the server              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: for (var i = combatTargets.Count - 1; i >= 0; i--)              {                  var target = combatTargets[i];                  if (target.Distance > maxRange*1.5d)                  {                      Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] out of range [" + Math.Round(target.Distance/1000'0) + "k away]");                  }                  else if (Cache.Instance.IgnoreTargets.Contains(target.Name.Trim()))                  {                      Logging.Log("Combat: Target [" + target.Name + "][ID: " + target.Id + "] on ignore list [" + Math.Round(target.Distance/1000'0) + "k away]");                  }                  else continue;                    target.UnlockTarget();                  _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                  combatTargets.RemoveAt(i);                  return; //this does kind of negates the 'for' loop' but we want the pause between commands sent to the server              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: while (highValueTargets.Where(t => !Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).Count() > Math.Max(maxHighValueTarget - Cache.Instance.PriorityTargets.Count()' 0))              {                  // Unlock any target                  var target = highValueTargets.OrderByDescending(t => t.Distance).Where(t => !Cache.Instance.PriorityTargets.Any(pt => pt.Id == t.Id)).FirstOrDefault();                  if (target == null)                      break;                    Logging.Log("Combat: unlocking high value target [" + target.Name + "][ID:" + target.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(target.Distance/1000'0) + "k away]");                  target.UnlockTarget();                  highValueTargets.Remove(target);                  _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                  return;              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: while (lowValueTargets.Count > maxLowValueTarget)              {                  // Unlock any target                  var target = lowValueTargets.OrderByDescending(t => t.Distance).First();                  Logging.Log("Combat: unlocking low value target [" + target.Name + "][ID:" + target.Id + "]{" + lowValueTargets.Count + "} [" + Math.Round(target.Distance/1000'0) + "k away]");                  target.UnlockTarget();                  lowValueTargets.Remove(target);                  _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                  return;              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: foreach (var entity in priority)              {                  // Have we reached the limit of high value targets?                  if (highValueTargets.Count >= maxHighValueTarget)                      break;                    if (entity.IsTarget || entity.IsTargeting) //This target is already targeted no need to target it again                  {                      return;                  }                  else                  {                      Logging.Log("Combat: Targeting priority target [" + entity.Name + "][ID:" + entity.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]");                      entity.LockTarget();                      highValueTargets.Add(entity);                      _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                      return;                  }                                }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: foreach (var entity in highValueTargetingMe)              {                  // Have we reached the limit of high value targets?                  if (highValueTargets.Count >= maxHighValueTarget)                      break;                    if (entity.IsTarget || entity.IsTargeting) //This target is already targeted no need to target it again                  {                      return;                  }                  else                  {                      Logging.Log("Combat: Targeting high value target [" + entity.Name + "][ID:" + entity.Id + "]{" + highValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]");                      entity.LockTarget();                      highValueTargets.Add(entity);                      _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                      return;                  }              }
Magic Number,Questor.Modules,Combat,C:\repos\Da-Teach_Questor\Questor.Modules\Combat.cs,TargetCombatants,The following statement contains a magic number: foreach (var entity in lowValueTargetingMe)              {                  // Have we reached the limit of low value targets?                  if (lowValueTargets.Count >= maxLowValueTarget)                      break;                    if (entity.IsTarget || entity.IsTargeting) //This target is already targeted no need to target it again                  {                      return;                  }                  else                  {                      Logging.Log("Combat: Targeting low value target [" + entity.Name + "][ID:" + entity.Id + "]{" + lowValueTargets.Count + "} [" + Math.Round(entity.Distance/1000'0) + "k away]");                      entity.LockTarget();                      lowValueTargets.Add(entity);                      _nextTargetAction = DateTime.Now.AddMilliseconds((int)Time.TargetDelay_miliseconds);                      return;                  }                                }
Magic Number,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,MoveItem,The following statement contains a magic number: if (hangar.Window == null)              {                  _nextCourierAction = DateTime.Now.AddSeconds(8);                  Logging.Log("CourierMissionState: Opening hangar floor");                  directEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                  return false;              }
Magic Number,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,MoveItem,The following statement contains a magic number: if (cargo.Window == null)              {                  _nextCourierAction = DateTime.Now.AddSeconds(8);                  Logging.Log("CourierMissionState: Opening cargo");                  directEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                  return false;              }
Magic Number,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,MoveItem,The following statement contains a magic number: _nextCourierAction = DateTime.Now.AddSeconds(8);
Magic Number,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ActivateOnce,The following statement contains a magic number: foreach (var module in Cache.Instance.Modules)              {                  if (!module.IsActivatable)                      continue;                    var activate = false;                  activate |= module.GroupId == (int)Group.CloakingDevice;                  activate |= module.GroupId == (int)Group.ShieldHardeners;                  activate |= module.GroupId == (int)Group.DamageControl;                  activate |= module.GroupId == (int)Group.ArmorHardeners;                  activate |= module.GroupId == (int)Group.SensorBooster;                  activate |= module.GroupId == (int)Group.TrackingComputer;                  activate |= module.GroupId == (int)Group.ECCM;                                      if (!activate)                      continue;                    if (module.IsActive | module.IsGoingOnline | module.IsDeactivating | module.InLimboState)                      continue;                    if (module.GroupId == (int)Group.CloakingDevice)                  {                      //Logging.Log("This module has a typeID of: " + module.TypeId + " !!");                      if (module.TypeId != 11578)  //11578 Covert Ops Cloaking Device - if you don't have a covert ops cloak try the next module                      {                          continue;                      }                      var StuffThatMayDecloakMe = Cache.Instance.Entities.Where(t => t.Name != Cache.Instance.DirectEve.Me.Name || t.IsBadIdea || t.IsContainer || t.IsNpc || t.IsPlayer).OrderBy(t => t.Distance).FirstOrDefault();                      if (StuffThatMayDecloakMe != null || StuffThatMayDecloakMe.Distance <= (int)Distance.SafeToCloakDistance) //if their is anything within 2300m do not attempt to cloak                      {                          if (StuffThatMayDecloakMe.Distance != 0)                          {                              //Logging.Log(StuffThatMayDecloakMe.Name + " is very close at: " + StuffThatMayDecloakMe.Distance + " meters");                              continue;                          }                      }                  }                  //                  // at this point the module should be active but isn't: activate it' set the delay and return. The process will resume on the next tick                  //                  module.Click();                  _nextActivateAction = DateTime.Now.AddMilliseconds((int)Time.DefenceDelay_milliseconds);                  Logging.Log("Defense: Defensive module activated: [ " + module.ItemId + "] next Activation delayed until [" + _nextActivateAction.ToString("HH:mm:ss") + "]");                                        return;              }
Magic Number,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ProcessState,The following statement contains a magic number: if (DateTime.Now.Subtract(_lastSessionChange).TotalSeconds < 5)              {                  Logging.Log("Defense: we just completed a session change less than 5 seconds ago... waiting.");                  return;              }
Magic Number,Questor.Modules,Defense,C:\repos\Da-Teach_Questor\Questor.Modules\Defense.cs,ProcessState,The following statement contains a magic number: if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < 10 && Cache.Instance.TargetedBy.Count() == 0)                  return;
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,EngageTarget,The following statement contains a magic number: if (_lastTarget == target.Id && DateTime.Now.Subtract(_lastEngageCommand).TotalSeconds < 15)                 return;
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,EngageTarget,The following statement contains a magic number: if (target.IsActiveTarget)             {                 // Save target id (so we do not constantly switch)                 _lastTarget = target.Id;                  // Engage target                 Logging.Log("Drones: Engaging drones on [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance / 1000' 0) + "k away]");                  Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesEngage);                 _lastEngageCommand = DateTime.Now;             }             else // Make the target active             {                 target.MakeActiveTarget();                 Logging.Log("Drones: Making [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance/1000'0) + "k away] the active target for drone engagement.");              }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,EngageTarget,The following statement contains a magic number: if (target.IsActiveTarget)             {                 // Save target id (so we do not constantly switch)                 _lastTarget = target.Id;                  // Engage target                 Logging.Log("Drones: Engaging drones on [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance / 1000' 0) + "k away]");                  Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesEngage);                 _lastEngageCommand = DateTime.Now;             }             else // Make the target active             {                 target.MakeActiveTarget();                 Logging.Log("Drones: Making [" + target.Name + "][ID: " + target.Id + "]" + Math.Round(target.Distance/1000'0) + "k away] the active target for drone engagement.");              }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following statement contains a magic number: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Magic Number,Questor.Modules,EntityCache,C:\repos\Da-Teach_Questor\Questor.Modules\EntityCache.cs,LockTarget,The following statement contains a magic number: if (Cache.Instance.TargetingIDs.ContainsKey(Id))              {                  var lastTargeted = Cache.Instance.TargetingIDs[Id];                    // Ignore targeting request                  var seconds = DateTime.Now.Subtract(lastTargeted).TotalSeconds;                  if (seconds < 45)                  {                      Logging.Log("EntityCache: LockTarget is ignored for [" + Name + "][" + Id + "]' can retarget in [" + (45 - seconds) + "]");                      return;                  }              }
Magic Number,Questor.Modules,EntityCache,C:\repos\Da-Teach_Questor\Questor.Modules\EntityCache.cs,LockTarget,The following statement contains a magic number: if (Cache.Instance.TargetingIDs.ContainsKey(Id))              {                  var lastTargeted = Cache.Instance.TargetingIDs[Id];                    // Ignore targeting request                  var seconds = DateTime.Now.Subtract(lastTargeted).TotalSeconds;                  if (seconds < 45)                  {                      Logging.Log("EntityCache: LockTarget is ignored for [" + Name + "][" + Id + "]' can retarget in [" + (45 - seconds) + "]");                      return;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The following statement contains a magic number: Cache.Instance.lowest_shield_percentage_this_pocket = 101;
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The following statement contains a magic number: Cache.Instance.lowest_armor_percentage_this_pocket = 101;
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LogStatistics,The following statement contains a magic number: Cache.Instance.lowest_capacitor_percentage_this_pocket = 101;
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ActivateAction,The following statement contains a magic number: if (closest.Distance < (int)Distance.GateActivationRange)              {                  // Tell the drones module to retract drones                  Cache.Instance.IsMissionPocketDone = true;                    // We cant activate if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    //                  // this is a bad idea for a speed tank' we ought to somehow cache the object they are orbiting/approaching' etc                  // this seemingly slowed down the exit from certain missions for me for 2-3min as it had a command to orbit some random object                  // after the "done" command                  //                  if (closest.Distance < -10100)                  {                      if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                      {                          closest.Orbit(1000);                          Logging.Log("MissionController: Activate: We are too close to [" + closest.Name + "] Initiating orbit");                          _lastOrbit = DateTime.Now;                      }                  }                  //Logging.Log("MissionController: distance " + closest.Distance);                  //if ((closest.Distance <= (int)Distance.TooCloseToStructure) && (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 30)) //-10100 meters (inside docking ring) - so close that we may get tangled in the structure on activation - move away                  //{                  //    Logging.Log("MissionController.Activate: Too close to Structure to activate: orbiting");                  //    closest.Orbit((int)Distance.GateActivationRange); // 1000 meters                  //    _lastOrbit = DateTime.Now;                  //}                    //if (closest.Distance >= (int)Distance.TooCloseToStructure) //If we aren't so close that we may get tangled in the structure' activate it                  if (closest.Distance >= -10100)                  {                      // Add bookmark (before we activate)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons and activate gate to move to the next pocket                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload before moving to next pocket");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                      Logging.Log("MissionController: closest.Activate: [" + closest.Name + "] Move to next pocket after reload command and change state to 'NextPocket'");                      closest.Activate();                        // Do not change actions' if NextPocket gets a timeout (>2 mins) then it reverts to the last action                                              _lastActivateAction = DateTime.Now;                      State = MissionControllerState.NextPocket;                  }              }              else if (closest.Distance < (int)Distance.WarptoDistance) //else if (closest.Distance < (int)Distance.WarptoDistance) //if we are inside warpto distance then approach              {                  // Move to the target                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 2)                      {                          Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                          closest.Approach();                          _lastApproachAction = DateTime.Now;                      }                    }              }              else //we must be outside warpto distance' but we are likely in a deadspace so align to the target              {                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Only happens if we are asked to Activate something that is outside Distance.CloseToGateActivationRange (default is: 6k)                      Logging.Log("MissionController: closest.AlignTo: [" + closest.Name + "] This only happens if we are asked to Activate something that is outside [" + Distance.CloseToGateActivationRange + "]");                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (distancetoclear != 0 && distancetoclear != -2147483648 && distancetoclear != 2147483647)              {                  range = Math.Min(range' distancetoclear);              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (distancetoclear != 0 && distancetoclear != -2147483648 && distancetoclear != 2147483647)              {                  range = Math.Min(range' distancetoclear);              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (target_null && targetedby == 0 && DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadALL: Reload if [" + target_null + "] && [" + targetedby + "] == 0 AND [" + Math.Round(target.Distance'0) + "] < [" + range + "]");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                           if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearPocket: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }                  else                  {                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload weapons");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                  }                    // Are we approaching the active (out of range) target?                  // Wait for it (or others) to get into range                    if (Settings.Instance.SpeedTank && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                      {                          target.Orbit(Cache.Instance.OrbitDistance);                          Logging.Log("MissionController.ClearPocket: Initiating [" + Cache.Instance.OrbitDistance + "] meter Orbit of [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                          _lastOrbit = DateTime.Now;                      }                  }                    if (!Settings.Instance.SpeedTank) //we need to make sure that orbitrange is set to the range of the ship if it isn't specified in the character XML!!!!                  {                      if (Settings.Instance.OptimalRange != 0)                      {                          if (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach(Settings.Instance.OptimalRange);                                  Logging.Log("MissionController.ClearPocket: Using Optimal Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= Settings.Instance.OptimalRange && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Optimal Range: Stop ship' target at [" + Math.Round(target.Distance / 1000' 0) + "k away] is inside optimal");                          }                      }                      else                      {                          if (target.Distance > range && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id))                          {                              if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                              {                                  target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                                  Logging.Log("MissionController.ClearPocket: Using Weapons Range: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                                  _lastApproachAction = DateTime.Now;                              }                          }                            if (target.Distance <= range && Cache.Instance.Approaching != null)                          {                              Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                              Cache.Instance.Approaching = null;                              Logging.Log("MissionController.ClearPocket: Using Weapons Range: Stop ship' target is in orbit range");                          }                      }                  }                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearPocketAction,The following statement contains a magic number: if (!_clearPocketTimeout.HasValue)                  _clearPocketTimeout = DateTime.Now.AddSeconds(5);
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The following statement contains a magic number: if (target != null)              {                  // Reset timeout                  _clearPocketTimeout = null;                    // Lock priority target if within weapons range                  if (target.Distance < range)                  {                      if (Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets > 0)                      {                          if (target.IsTarget || target.IsTargeting) //This target is already targeted no need to target it again                          {                              return;                          }                          else                          {                              Logging.Log("MissionController.ClearwithinWeaponsRange: Targeting [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                              target.LockTarget();                          }                      }                      return;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ClearWithinWeaponsRangeOnlyAction,The following statement contains a magic number: if (!_clearPocketTimeout.HasValue)                  _clearPocketTimeout = DateTime.Now.AddSeconds(5);
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToBackgroundAction,The following statement contains a magic number: Logging.Log("MissionController.MoveToBackground: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The following statement contains a magic number: if (closest.Distance < distancetoapp)              {                  // We are close enough to whatever we needed to move to                  _currentAction++;                    if (Cache.Instance.Approaching != null)                  {                      Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                      Cache.Instance.Approaching = null;                      Logging.Log("MissionController.MoveTo: Stop ship' we are [" + distancetoapp + "] from [ID: " + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                  }                  //if (Settings.Instance.SpeedTank)                  //{                  //    //this should at least keep speed tanked ships from going poof if a mission XML uses moveto                  //    closest.Orbit(Cache.Instance.OrbitDistance);                  //    Logging.Log("MissionController: MoveTo: Initiating orbit after reaching target")                  //}              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                      // Move to the target                      if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                              closest.Approach();                              _lastApproachAction = DateTime.Now;                              //_lastApproach = DateTime.Now;                          }                      }              }              else              {                  //// Move to the target                  //if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  //{                  //    Logging.Log("MissionController.MoveTo: Approaching target [" + closest.Name + "][" + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away]");                  //    closest.Approach();                  //}                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Probably never happens                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The following statement contains a magic number: if (closest.Distance < distancetoapp)              {                  // We are close enough to whatever we needed to move to                  _currentAction++;                    if (Cache.Instance.Approaching != null)                  {                      Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                      Cache.Instance.Approaching = null;                      Logging.Log("MissionController.MoveTo: Stop ship' we are [" + distancetoapp + "] from [ID: " + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                  }                  //if (Settings.Instance.SpeedTank)                  //{                  //    //this should at least keep speed tanked ships from going poof if a mission XML uses moveto                  //    closest.Orbit(Cache.Instance.OrbitDistance);                  //    Logging.Log("MissionController: MoveTo: Initiating orbit after reaching target")                  //}              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                      // Move to the target                      if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                              closest.Approach();                              _lastApproachAction = DateTime.Now;                              //_lastApproach = DateTime.Now;                          }                      }              }              else              {                  //// Move to the target                  //if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  //{                  //    Logging.Log("MissionController.MoveTo: Approaching target [" + closest.Name + "][" + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away]");                  //    closest.Approach();                  //}                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Probably never happens                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,MoveToAction,The following statement contains a magic number: if (closest.Distance < distancetoapp)              {                  // We are close enough to whatever we needed to move to                  _currentAction++;                    if (Cache.Instance.Approaching != null)                  {                      Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                      Cache.Instance.Approaching = null;                      Logging.Log("MissionController.MoveTo: Stop ship' we are [" + distancetoapp + "] from [ID: " + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                  }                  //if (Settings.Instance.SpeedTank)                  //{                  //    //this should at least keep speed tanked ships from going poof if a mission XML uses moveto                  //    closest.Orbit(Cache.Instance.OrbitDistance);                  //    Logging.Log("MissionController: MoveTo: Initiating orbit after reaching target")                  //}              }              else if (closest.Distance < (int)Distance.WarptoDistance)              {                      // Move to the target                      if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              Logging.Log("MissionController.Activate: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                              closest.Approach();                              _lastApproachAction = DateTime.Now;                              //_lastApproach = DateTime.Now;                          }                      }              }              else              {                  //// Move to the target                  //if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  //{                  //    Logging.Log("MissionController.MoveTo: Approaching target [" + closest.Name + "][" + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away]");                  //    closest.Approach();                  //}                  // We cant warp if we have drones out                  if (Cache.Instance.ActiveDrones.Count() > 0)                      return;                    if (DateTime.Now.Subtract(_lastAlign ).TotalMinutes > (int)Time.LastAlignDelay_minutes)                  {                      // Probably never happens                      closest.AlignTo();                      _lastAlign = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,WaitUntilTargeted,The following statement contains a magic number: if (!int.TryParse(action.GetParameterValue("timeout")' out timeout))                  timeout = 30;
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,The following statement contains a magic number: if (Cache.Instance.TargetedBy.Any(t => !t.IsSentry && targetNames.Contains(t.Name)))              {                  // We are being attacked' break the kill order                  if (Cache.Instance.RemovePriorityTargets(targets))                      Logging.Log("MissionController.AggroOnly: Done with AggroOnly: We have aggro.");                    foreach (var target in Cache.Instance.Targets.Where(e => targets.Any(t => t.Id == e.Id)))                  {                      Logging.Log("MissionController.AggroOnly: Unlocking [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away] due to aggro being obtained");                      target.UnlockTarget();                    }                  _currentAction++;                  return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AggroOnlyAction,The following statement contains a magic number: if (!Cache.Instance.PriorityTargets.Any(pt => pt.Id == closest.Id))              {                  Logging.Log("MissionController.AggroOnly: Adding [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance/1000'0) + "k away] as a priority target");                  Cache.Instance.AddPriorityTargets(new[] { closest }' Priority.PriorityKillTarget);              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if (breakOnAttackers && Cache.Instance.TargetedBy.Any(t => !t.IsSentry && t.Distance < Cache.Instance.WeaponRange))              {                  // We are being attacked' break the kill order                  if (Cache.Instance.RemovePriorityTargets(targets))                      Logging.Log("MissionController.Kill: Breaking off kill order' new spawn has arrived!");                    foreach (var target in Cache.Instance.Targets.Where(e => targets.Any(t => t.Id == e.Id)))                  {                      Logging.Log("MissionController.Kill: Unlocking [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance/1000'0) + "k away] due to kill order being put on hold");                      target.UnlockTarget();                  }                    return;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if (closest.Distance < range)              {                  if (!Cache.Instance.PriorityTargets.Any(pt => pt.Id == closest.Id))                  {                      Logging.Log("MissionController.Kill: Adding [" + closest.Name + "][ID: " + closest.Id + "] as a priority target");                      Cache.Instance.AddPriorityTargets(new[] {closest}' Priority.PriorityKillTarget);                  }                                    if (Cache.Instance.Approaching != null && !Settings.Instance.SpeedTank && (Settings.Instance.OptimalRange <= 0))                  {                      if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                      {                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                          Cache.Instance.Approaching = null;                          Logging.Log("MissionController.Kill: Stop ship' target is in weapons range");                          _lastApproachAction = DateTime.Now;                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillAction,The following statement contains a magic number: if ((closest.Distance > range && Settings.Instance.OptimalRange <= 0) || (closest.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                    //Logging.Log("MissionController: kill: we are out of range)");                  Cache.Instance.TimeSpentInMissionOutOfRange = Cache.Instance.TimeSpentInMissionOutOfRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)                  {                      //Logging.Log("MissionController: kill: if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id)");                      if (Settings.Instance.SpeedTank)                      {                          if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15))                          {                              closest.Orbit(Cache.Instance.OrbitDistance);                              Logging.Log("MissionController.Kill: Initiating Orbit [" + closest.Name + "][ID: " + closest.Id + "] at [" + Cache.Instance.OrbitDistance + "] meters' the orbit target is: [" + Math.Round(closest.Distance' 0) + "] meters away");                              _lastOrbit = DateTime.Now;                          }                        }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              closest.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: Kill: initiating Approach of [" + closest.Name + "][" + Math.Round(closest.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }                  else                  {                      if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                      {                          //Logging.Log("MissionController: kill: we are already on approach to the target");                      }                  }              }              else              {                  if ((DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)) //abuse the lastorbit timestamp here - ugly                  {                      Cache.Instance.TimeSpentInMissionInRange = Cache.Instance.TimeSpentInMissionInRange + ((int)Time.QuestorPulse_milliseconds / 1000); //their has to be a more precise way to do this...                      //Logging.Log("MissionController: kill: target(s) are IN range");                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,KillOnceAction,The following statement contains a magic number: if (Cache.Instance.DirectEve.ActiveShip.Entity.Velocity > 9999999) //this concept with a relatively more realistic speed should be used in places to make sure speed tanks are moving              {                  /* if (Cache.Instance.NormalApproch)                      Cache.Instance.NormalApproch = false;                    bool ignoreAttackers;                  if (!bool.TryParse(action.GetParameterValue("ignoreattackers")' out ignoreAttackers))                      ignoreAttackers = false;                    bool breakOnAttackers;                  if (!bool.TryParse(action.GetParameterValue("breakonattackers")' out breakOnAttackers))                      breakOnAttackers = false;                    bool nottheclosest;                  if (!bool.TryParse(action.GetParameterValue("notclosest")' out nottheclosest))                      nottheclosest = false;                    int numbertoignore;                  if (!int.TryParse(action.GetParameterValue("numbertoignore")' out numbertoignore))                      numbertoignore = 0;                    var targetNames = action.GetParameterValues("target");                  // No parameter? Ignore kill action                  if (targetNames.Count == 0)                  {                      Logging.Log("MissionController.KillOnce: No targets defined!");                        _currentAction++;                      return;              }                      if (Cache.Instance.CurrentCombatTargets.Count == 0 )                  {                      if (!nottheclosest) //default is the closest target                      {                  //        Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => targetNames.Contains(e.Name)).OrderBy(t => t.Distance).First();                      }                      else if (nottheclosest) // if specified then reverse the entity search so that we are targeting the furthest target                      {                                      //        Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => targetNames.Contains(e.Name)).OrderByDescending(t => t.Distance).First();                          //Cache.Instance.CurrentCombatTargets = Cache.Instance.Entities.Where(e => e.IsContainer && e.HaveLootRights || e.GroupId == (int) Group.Wreck)).OrderBy(e => e.Distance).ToList();                        }                  }                  var target = Cache.Instance.Entities.Where(e => targetNames.Contains(e.Name)).OrderBy(t => t.Distance).First();                  //var containers = Cache.Instance.Containers.Where(e => !Cache.Instance.LootedContainers.Contains(e.Id)).OrderBy(e => e.Distance);                   //        target =   Cache.Instance.Entities.Where(e =>  Cache.Instance.CurrentCombatTargets.Contains(e.Id).Orderby(t => target.Distance).First();                  //                  // is it dead?                  //                  //if (target.)                  //{                  //    Logging.Log("MissionController.KillOnce: The target is dead' not valid anymore ");                  //                  //    // We killed it/them !?!?!? :)                  //    _currentAction++;                  //    return;                  //}                    if (!ignoreAttackers || breakOnAttackers)                  {                      // Apparently we are busy' wait for combat to clear attackers first                      var targetedBy = Cache.Instance.TargetedBy;                      if (targetedBy != null && targetedBy.Count(t => !t.IsSentry && t.Distance < Cache.Instance.WeaponRange) > 0)                          return;                  }                      if (target.Distance < Cache.Instance.WeaponRange)                  {                      if (!Cache.Instance.PriorityTargets.Any(pt => pt.Id == target.Id))                      {                          Logging.Log("MissionController.KillOnce: Adding [" + target.Name + "][" + target.Id + "] as a priority target");                          Cache.Instance.AddPriorityTargets(new[] { target }' Priority.PriorityKillTarget);                      }                        if (Cache.Instance.Approaching != null && !Settings.Instance.SpeedTank)                      {                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdStopShip);                          Cache.Instance.Approaching = null;                          Logging.Log("MissionController.KillOnce: Stop ship' target is in weapons range");                      }                  }                  else                  {                      // Move within 80% max distance                      if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                      {                          Logging.Log("MissionController.KillOnce: Approaching target [" + target.Name + "][" + target.Id + "]");                            if (Settings.Instance.SpeedTank)                          {                              if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                              {                                  target.Orbit(Cache.Instance.OrbitDistance);                                  Logging.Log("MissionController: killonce: initiating orbit");                                  _lastOrbit = DateTime.Now;                              }                          }                          else                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d));                              Logging.Log("MissionController: killonce: approaching");                          }                      }                  } */              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosestByName: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosestByName: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                          }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                          Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                      }                      else                      {                          target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                          Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestByNameAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosestByName: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosestByName: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                          }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                          Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                      }                      else                      {                          target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                          Logging.Log("MissionController: AttackClosestByName: initiating Approach of [" + target.Name + "] distance: [" + Math.Round(target.Distance'0) + "] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,AttackClosestAction,The following statement contains a magic number: if ((target.Distance > range && Settings.Instance.OptimalRange <= 0) || (target.Distance > Settings.Instance.OptimalRange + (int)Distance.OptimalRangeCushion) && Settings.Instance.OptimalRange > 0)              {                  if (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != target.Id)                  {                      Logging.Log("MissionController.AttackClosest: Approaching target [" + target.Name + "][ID: " + target.Id + "][" + Math.Round(target.Distance / 1000' 0) + "k away]");                        if (Settings.Instance.SpeedTank)                      {                          if (DateTime.Now.Subtract(_lastOrbit).TotalSeconds > 15)                          {                              target.Orbit(Cache.Instance.OrbitDistance); //orbit                              Logging.Log("MissionController: AttackClosest: initiating Orbit of [" + target.Name + "] orbiting at [" + Cache.Instance.OrbitDistance + "]");                              _lastOrbit = DateTime.Now;                                                        }                      }                      else if (Settings.Instance.OptimalRange > 0)                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Settings.Instance.OptimalRange * 0.8d)); // Move within 80% of optimalrange                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance/1000'0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                      else                      {                          if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                          {                              target.Approach((int)(Cache.Instance.WeaponRange * 0.8d)); // Move within 80% of range                              Logging.Log("MissionController: AttackClosest: initiating Approach of [" + target.Name + "][" + Math.Round(target.Distance / 1000' 0) + "k away] approaching to [" + (Settings.Instance.OptimalRange * 0.8d) + "]");                              _lastApproachAction = DateTime.Now;                          }                      }                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The following statement contains a magic number: if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id))              {                  if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                  {                      Logging.Log("MissionController.LootItem: Approaching target [" + closest.Name + "][ID: " + closest.Id + "] which is at [" + Math.Round(closest.Distance / 1000' 0) + "k away]");                      closest.Approach();                      _lastApproachAction = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootItemAction,The following statement contains a magic number: if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id))              {                  if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                  {                      Logging.Log("MissionController.LootItem: Approaching target [" + closest.Name + "][ID: " + closest.Id + "] which is at [" + Math.Round(closest.Distance / 1000' 0) + "k away]");                      closest.Approach();                      _lastApproachAction = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,The following statement contains a magic number: if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id))              {                  if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                  {                      Logging.Log("MissionController.Loot: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                      closest.Approach();                      _lastApproachAction = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,LootAction,The following statement contains a magic number: if (closest.Distance > (int)Distance.SafeScoopRange && (Cache.Instance.Approaching == null || Cache.Instance.Approaching.Id != closest.Id))              {                  if (DateTime.Now.Subtract(_lastApproachAction).TotalSeconds > 5)                  {                      Logging.Log("MissionController.Loot: Approaching target [" + closest.Name + "][ID: " + closest.Id + "][" + Math.Round(closest.Distance / 1000' 0) + "k away]");                      closest.Approach();                      _lastApproachAction = DateTime.Now;                  }              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,PerformAction,The following statement contains a magic number: switch (action.State)              {                  case ActionState.Activate:                      ActivateAction(action);                      break;                    case ActionState.ClearPocket:                      ClearPocketAction(action);                      break;                    case ActionState.SalvageBookmark:                      BookmarkPocketForSalvaging();                        _currentAction++;                      break;                    case ActionState.Done:                      // Tell the drones module to retract drones                      Cache.Instance.IsMissionPocketDone = true;                        // We do not switch to "done" status if we still have drones out                      if (Cache.Instance.ActiveDrones.Count() > 0)                          return;                        // Add bookmark (before we're done)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload because ActionState is Done - Reloading Weapons.");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        State = MissionControllerState.Done;                      break;                    case ActionState.Kill:                      KillAction(action);                      break;                    case ActionState.KillOnce:                      KillOnceAction(action);                      break;                    case ActionState.AttackClosestByName:                      AttackClosestByNameAction(action);                      break;                    case ActionState.AttackClosest:                      AttackClosestAction(action);                      break;                    case ActionState.MoveTo:                      MoveToAction(action);                      break;                    case ActionState.MoveToBackground:                      MoveToBackgroundAction(action);                      break;                                    case ActionState.ClearWithinWeaponsRangeOnly:                      ClearWithinWeaponsRangeOnlyAction(action);                      break;                    case ActionState.Loot:                      LootAction(action);                      break;                    case ActionState.LootItem:                      LootItemAction(action);                      break;                    case ActionState.Ignore:                      IgnoreAction(action);                      break;                    case ActionState.WaitUntilTargeted:                      WaitUntilTargeted(action);                      break;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case MissionControllerState.Idle:                      break;                  case MissionControllerState.Done:                      LogStatistics();                        if (!Cache.Instance.NormalApproch)                          Cache.Instance.NormalApproch = true;                        Cache.Instance.IgnoreTargets.Clear();                      break;                  case MissionControllerState.Error:                      break;                    case MissionControllerState.Start:                      _pocket = 0;                      // Update statistic values                      Wealth = Cache.Instance.DirectEve.Me.Wealth;                      StartedPocket = DateTime.Now;                        // Reload the items needed for this mission from the XML file                      Cache.Instance.RefreshMissionItems(AgentId);                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = MissionControllerState.LoadPocket;                      break;                    case MissionControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(AgentId' _pocket' true));                        //                      // LogStatistics();                      //                      if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("MissionController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("MissionController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("MissionController: Action." + a);                        if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)                      {                          if (Cache.Instance.OrbitDistance == 0)                          {                              Cache.Instance.OrbitDistance = Settings.Instance.OrbitDistance;                              Logging.Log("MissionController: Using default orbit distance: " + Cache.Instance.OrbitDistance + " (as the custom one was 0)");                          }                          else                              Logging.Log("MissionController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);                      }                        // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = MissionControllerState.ExecutePocketActions;                      break;                    case MissionControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("MissionController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = MissionControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      if (action.ToString() != Cache.Instance.CurrentPocketAction)                      {                          Cache.Instance.CurrentPocketAction = action.ToString();                      }                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("MissionController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("MissionController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case MissionControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("MissionController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = MissionControllerState.LoadPocket;                          LogStatistics();                                                }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("MissionController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = MissionControllerState.ExecutePocketActions;                      }                      break;              }
Magic Number,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case MissionControllerState.Idle:                      break;                  case MissionControllerState.Done:                      LogStatistics();                        if (!Cache.Instance.NormalApproch)                          Cache.Instance.NormalApproch = true;                        Cache.Instance.IgnoreTargets.Clear();                      break;                  case MissionControllerState.Error:                      break;                    case MissionControllerState.Start:                      _pocket = 0;                      // Update statistic values                      Wealth = Cache.Instance.DirectEve.Me.Wealth;                      StartedPocket = DateTime.Now;                        // Reload the items needed for this mission from the XML file                      Cache.Instance.RefreshMissionItems(AgentId);                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = MissionControllerState.LoadPocket;                      break;                    case MissionControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(AgentId' _pocket' true));                        //                      // LogStatistics();                      //                      if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("MissionController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("MissionController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("MissionController: Action." + a);                        if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)                      {                          if (Cache.Instance.OrbitDistance == 0)                          {                              Cache.Instance.OrbitDistance = Settings.Instance.OrbitDistance;                              Logging.Log("MissionController: Using default orbit distance: " + Cache.Instance.OrbitDistance + " (as the custom one was 0)");                          }                          else                              Logging.Log("MissionController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);                      }                        // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = MissionControllerState.ExecutePocketActions;                      break;                    case MissionControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("MissionController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = MissionControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      if (action.ToString() != Cache.Instance.CurrentPocketAction)                      {                          Cache.Instance.CurrentPocketAction = action.ToString();                      }                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("MissionController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("MissionController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case MissionControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("MissionController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = MissionControllerState.LoadPocket;                          LogStatistics();                                                }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("MissionController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = MissionControllerState.ExecutePocketActions;                      }                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Magic Number,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,TargetHostileWrecks,The following statement contains a magic number: foreach (var wreck in wrecks.Where(w => !Cache.Instance.IgnoreTargets.Contains(w.Name.Trim())))              {                  // Its already a target' ignore it                  if (wreck.IsTarget || wreck.IsTargeting)                      continue;                    if (wreck.Distance > tractorBeamRange)                      continue;                    //if (!wreck.HaveLootRights)                  //    continue;                    // No need to tractor a non-wreck within loot range                  if (wreck.GroupId != (int)Group.Wreck && wreck.Distance < (int)Distance.SafeScoopRange)                      continue;                    if (wreck.GroupId != (int)Group.Wreck && wreck.GroupId != (int)Group.CargoContainer)                      continue;                    if (!hasSalvagers)                  {                      // Ignore already looted wreck                      if (Cache.Instance.LootedContainers.Contains(wreck.Id))                          continue;                        // Ignore empty wrecks                      if (wreck.GroupId == (int)Group.Wreck && wreck.IsWreckEmpty)                          continue;                  }                    Logging.Log("Salvage: Locking [" + wreck.Name + "][ID:" + wreck.Id + "][" + Math.Round(wreck.Distance/1000'0) + "k away]");                    wreck.LockTarget();                  wreckTargets.Add(wreck);                    if (wreckTargets.Count >= MaximumWreckTargets)                      break;              }
Magic Number,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The following statement contains a magic number: foreach (var window in lootWindows)              {                  // The window is not ready' then continue                  if (!window.IsReady)                      continue;                    // Get the container                  var containerEntity = Cache.Instance.EntityById(window.ItemId);                    // Does it no longer exist or is it out of transfer range or its looted                  if (containerEntity == null || containerEntity.Distance > (int)Distance.SafeScoopRange || Cache.Instance.LootedContainers.Contains(containerEntity.Id))                  {                      Logging.Log("Salvage: Closing loot window [" + window.ItemId + "]");                      window.Close();                      continue;                  }                                      // Get the container that is associated with the cargo container                  var container = Cache.Instance.DirectEve.GetContainer(window.ItemId);                    // List its items                  var items = container.Items.Select(i => new ItemCache(i));                    // Build a list of items to loot                  var lootItems = new List<ItemCache>();                    //can we loot all items in one go here?                  //                  // bulk loot code would go here                  //                    // Walk through the list of items ordered by highest value item first                  foreach (var item in items) //.OrderByDescending(i => i.IskPerM3))                  {                      // We never want to pick up Bookmarks                      if (item.IsBookmark)                          continue;                                            // We never want to pick up a cap booster                      if (item.GroupID == (int) Group.CapacitorGroupCharge)                          continue;                        // We never want to pick up metal scraps                      if (item.IsScrapMetal)                          continue;                        // We never want to pick up Ore...                      if (item.IsOre)                          continue;                        // We never want to pick up Low End Minerals                      if (item.IsLowEndMineral)                          continue;                                            // Never pick up contraband                      if (item.IsContraband)                          continue;                        // We pick up loot depending on isk per m3                      var isMissionItem = Cache.Instance.MissionItems.Contains((item.Name ?? string.Empty).ToLower());                        // We are at our max' either make room or skip the item                      if ((freeCargoCapacity - item.TotalVolume) <= (isMissionItem ? 0 : ReserveCargoCapacity))                      {                          // We can't drop items in this container anyway' well get it after its salvaged                          if (!isMissionItem && containerEntity.GroupId != (int)Group.CargoContainer)                              continue;                            // Make a list of items which are worth less                          List<ItemCache> worthLess;                          worthLess = shipsCargo;                          if (item.IskPerM3.HasValue)                              worthLess = shipsCargo.Where(sc => sc.IskPerM3.HasValue && sc.IskPerM3 < item.IskPerM3).ToList();                          else                              worthLess = shipsCargo.Where(sc => sc.IskPerM3.HasValue).ToList();                            // Remove mission item from this list                          worthLess.RemoveAll(wl => Cache.Instance.MissionItems.Contains((wl.Name ?? string.Empty).ToLower()));                          worthLess.RemoveAll(wl => (wl.Name ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem);                              // Nothing is worth less then the current item                          if (worthLess.Count() == 0)                              continue;                            // Not enough space even if we dumped the crap                          if ((freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) < item.TotalVolume)                          {                              if (isMissionItem)                                  Logging.Log("Scoop: Not enough space for [" + item.Name + "] Need [" + item.TotalVolume + "]m3 - maximum available [" + (freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) + "]m3");                                continue;                          }                            // Start clearing out items that are worth less                          var moveTheseItems = new List<DirectItem>();                          foreach (var wl in worthLess.OrderBy(wl => wl.IskPerM3.HasValue ? wl.IskPerM3.Value : double.MaxValue).ThenByDescending(wl => wl.TotalVolume))                          {                              // Mark this item as moved                              moveTheseItems.Add(wl.DirectItem);                                // Substract (now) free volume                              freeCargoCapacity += wl.TotalVolume;                                // We freed up enough space?                              if ((freeCargoCapacity - item.TotalVolume) >= ReserveCargoCapacity)                                  break;                          }                            if (moveTheseItems.Count > 0)                          {                              // If this is not a cargo container' then jettison loot                              if (containerEntity.GroupId != (int)Group.CargoContainer)                              {                                  if (DateTime.Now.Subtract(_lastJettison).TotalSeconds < 185)                                      return;                                    Logging.Log("Scoop: Jettisoning [" + moveTheseItems.Count + "] items to make room for the more valuable loot");                                    // Note: This could (in theory) fuck up with the bot jettison an item and                                   // then picking it up again :/ (granted it should never happen unless                                   // mission item volume > reserved volume                                  cargo.Jettison(moveTheseItems.Select(i => i.ItemId));                                  _lastJettison = DateTime.Now;                                  return;                              }                                // Move items to the cargo container                              container.Add(moveTheseItems);                                // Remove it from the ships cargo list                              shipsCargo.RemoveAll(i => moveTheseItems.Any(wl => wl.ItemId == i.Id));                              Logging.Log("Scoop: Moving [" + moveTheseItems.Count + "] items into the cargo container to make room for the more valuable loot");                          }                      }                        // Update free space                      freeCargoCapacity -= item.TotalVolume;                      lootItems.Add(item);                  }                      // Mark container as looted                  Cache.Instance.LootedContainers.Add(containerEntity.Id);                    // Loot actual items                  if (lootItems.Count != 0)                  {                      cargo.Add(lootItems.Select(i => i.DirectItem));                      //Logging.Log("Scoop: Looting container [" + containerEntity.Name + "][" + containerEntity.Id + "]' [" + lootItems.Count + "] valuable items");                  }                  else                      Logging.Log("Scoop: Container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "] contained no valuable items");              }
Magic Number,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,LootHostileWrecks,The following statement contains a magic number: foreach (var containerEntity in Cache.Instance.UnlootedWrecksAndSecureCans.Where(e => e.Distance <= (int)Distance.SafeScoopRange))              {                  // Emptry wreck' ignore                  if (containerEntity.GroupId == (int)Group.Wreck && containerEntity.IsWreckEmpty)                      continue;                    // We looted this container                  if (Cache.Instance.LootedContainers.Contains(containerEntity.Id))                      continue;                    // We already opened the loot window                  var window = lootWindows.FirstOrDefault(w => w.ItemId == containerEntity.Id);                  if (window != null)                      continue;                    // Ignore open request within 10 seconds                  if (_openedContainers.ContainsKey(containerEntity.Id) && DateTime.Now.Subtract(_openedContainers[containerEntity.Id]).TotalSeconds < 10)                      continue;                    // Open the container                  Logging.Log("Scoop: Opening container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "]");                  containerEntity.OpenCargo();                  _openedContainers[containerEntity.Id] = DateTime.Now;                  break;              }
Magic Number,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case ScoopState.TargetHostileWrecks:                      //TargetHostileWrecks();                        // Next state                      State = ScoopState.LootHostileWrecks;                      break;                    case ScoopState.LootHostileWrecks:                      LootHostileWrecks();                        //State = ScoopState.SalvageHostileWrecks;                      break;                    case ScoopState.SalvageHostileWrecks:                      ActivateSalvagers();                        // Default action                      State = ScoopState.TargetHostileWrecks;                      //if (cargo.IsReady && cargo.Items.Any() && _nextAction < DateTime.Now)                      //{                          // Check if there are actually duplicates                      //    var duplicates = cargo.Items.Where(i => i.Quantity > 0).GroupBy(i => i.TypeId).Any(t => t.Count() > 1);                      //    if (duplicates)                      //        State = SalvageState.StackItems;                      //    else                      //        _nextAction = DateTime.Now.AddSeconds(150);                      //}                      break;                    case ScoopState.StackItemsWhileAggressed:                      Logging.Log("Salvage: Stacking items");                        if (cargo.IsReady)                          cargo.StackAll();                        _nextAction = DateTime.Now.AddSeconds(5);                      State = ScoopState.WaitForStackingWhileAggressed;                      break;                    case ScoopState.WaitForStackingWhileAggressed:                      // Wait 5 seconds after stacking                      if (_nextAction > DateTime.Now)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("Salvage: Done stacking");                          State = ScoopState.TargetHostileWrecks;                          break;                      }                        if (DateTime.Now.Subtract(_nextAction).TotalSeconds > 120)                      {                          Logging.Log("Salvage: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("Salvage: Done stacking");                          State = ScoopState.TargetHostileWrecks;                          break;                      }                      break;                                    case ScoopState.Error:                      // Wait indefinately...                      break;                    default:                      // Unknown state' goto first state                      State = ScoopState.LootHostileWrecks;                      break;              }
Magic Number,Questor.Modules,Scoop,C:\repos\Da-Teach_Questor\Questor.Modules\Scoop.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case ScoopState.TargetHostileWrecks:                      //TargetHostileWrecks();                        // Next state                      State = ScoopState.LootHostileWrecks;                      break;                    case ScoopState.LootHostileWrecks:                      LootHostileWrecks();                        //State = ScoopState.SalvageHostileWrecks;                      break;                    case ScoopState.SalvageHostileWrecks:                      ActivateSalvagers();                        // Default action                      State = ScoopState.TargetHostileWrecks;                      //if (cargo.IsReady && cargo.Items.Any() && _nextAction < DateTime.Now)                      //{                          // Check if there are actually duplicates                      //    var duplicates = cargo.Items.Where(i => i.Quantity > 0).GroupBy(i => i.TypeId).Any(t => t.Count() > 1);                      //    if (duplicates)                      //        State = SalvageState.StackItems;                      //    else                      //        _nextAction = DateTime.Now.AddSeconds(150);                      //}                      break;                    case ScoopState.StackItemsWhileAggressed:                      Logging.Log("Salvage: Stacking items");                        if (cargo.IsReady)                          cargo.StackAll();                        _nextAction = DateTime.Now.AddSeconds(5);                      State = ScoopState.WaitForStackingWhileAggressed;                      break;                    case ScoopState.WaitForStackingWhileAggressed:                      // Wait 5 seconds after stacking                      if (_nextAction > DateTime.Now)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("Salvage: Done stacking");                          State = ScoopState.TargetHostileWrecks;                          break;                      }                        if (DateTime.Now.Subtract(_nextAction).TotalSeconds > 120)                      {                          Logging.Log("Salvage: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("Salvage: Done stacking");                          State = ScoopState.TargetHostileWrecks;                          break;                      }                      break;                                    case ScoopState.Error:                      // Wait indefinately...                      break;                    default:                      // Unknown state' goto first state                      State = ScoopState.LootHostileWrecks;                      break;              }
Magic Number,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,TargetWrecks,The following statement contains a magic number: foreach (var wreck in wrecks.Where(w => !Cache.Instance.IgnoreTargets.Contains(w.Name.Trim())))              {                  // Its already a target' ignore it                  if (wreck.IsTarget || wreck.IsTargeting)                      continue;                    if (wreck.Distance > tractorBeamRange)                      continue;                    if (!wreck.HaveLootRights)                      continue;                    // No need to tractor a non-wreck within loot range                  if (wreck.GroupId != (int) Group.Wreck && wreck.Distance < (int)Distance.SafeScoopRange)                      continue;                    if(!Cache.Instance.SalvageAll)                  {                      if (Settings.Instance.WreckBlackList.Any(a => a == wreck.TypeId) && (wreck.IsWreckEmpty || wreck.Distance < (int)Distance.SafeScoopRange))                          continue;                  }                    if (wreck.GroupId != (int) Group.Wreck && wreck.GroupId != (int) Group.CargoContainer)                      continue;                    if (!hasSalvagers)                  {                      // Ignore already looted wreck                      if (Cache.Instance.LootedContainers.Contains(wreck.Id))                          continue;                        // Ignore empty wrecks                      if (wreck.GroupId == (int) Group.Wreck && wreck.IsWreckEmpty)                          continue;                  }                    Logging.Log("Salvage: Locking [" + wreck.Name + "][ID:" + wreck.Id + "][" + Math.Round(wreck.Distance / 1000' 0) + "k away]");                    wreck.LockTarget();                  wreckTargets.Add(wreck);                    if(Cache.Instance.MissionLoot)                  {                      if(wreckTargets.Count >= Math.Min(Cache.Instance.DirectEve.ActiveShip.MaxLockedTargets' Cache.Instance.DirectEve.Me.MaxLockedTargets))                          return;                  }                  else                  if (wreckTargets.Count >= MaximumWreckTargets)                          return;              }
Magic Number,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The following statement contains a magic number: foreach (var window in lootWindows)              {                  // The window is not ready' then continue                  if (!window.IsReady)                      continue;                    // Get the container                  var containerEntity = Cache.Instance.EntityById(window.ItemId);                    // Does it no longer exist or is it out of transfer range or its looted                  if (containerEntity == null || containerEntity.Distance > (int)Distance.SafeScoopRange || Cache.Instance.LootedContainers.Contains(containerEntity.Id))                  {                      Logging.Log("Salvage: Closing loot window [" + window.ItemId + "]");                      window.Close();                      continue;                  }                    // Get the container that is associated with the cargo container                  var container = Cache.Instance.DirectEve.GetContainer(window.ItemId);                    // List its items                  var items = container.Items.Select(i => new ItemCache(i));                    // Build a list of items to loot                  var lootItems = new List<ItemCache>();                    if (Settings.Instance.WreckLootStatistics)                  {                      // Log all items found in the wreck                      File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "TIME: " + string.Format("{0:dd/MM/yyyy HH:mm:ss}"' DateTime.Now) + "\n");                      File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "NAME: " + containerEntity.Name + "\n");                      File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "ITEMS:" + "\n");                      foreach (var item in items.OrderBy(i => i.TypeId))                      {                          File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "TypeID: " + item.TypeId.ToString() + "\n");                          File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "Name: " + item.Name + "\n");                          File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "Quantity: " + item.Quantity.ToString() + "\n");                          File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' "=\n");                      }                      File.AppendAllText(Settings.Instance.WreckLootStatisticsFile' ";" + "\n");                  }                  //if (freeCargoCapacity < 1000) //this should allow BSs to dump scrapmetal but haulers and noctus' to hold onto it                  //{                  //	// Dump scrap metal if we have any                  //	if (containerEntity.Name == "Cargo Container" && shipsCargo.Any(i => i.IsScrapMetal))                  //	{                  //		foreach (var item in shipsCargo.Where(i => i.IsScrapMetal))                  //		{                  //			container.Add(item.DirectItem);                  //			freeCargoCapacity += item.TotalVolume;                  //		}                  //                  //		shipsCargo.RemoveAll(i => i.IsScrapMetal);                  //	}                  //}                  // Walk through the list of items ordered by highest value item first                  foreach (var item in items.OrderByDescending(i => i.IskPerM3))                  {                      if (freeCargoCapacity < 1000) //this should allow BSs to not pickup large low value items but haulers and noctus' to scoop everything                      {                          // We never want to pick up a cap booster                          if (item.GroupID == (int)Group.CapacitorGroupCharge)                              continue;                            // We never want to pick up metal scraps                          //if (item.IsScrapMetal)                          //	continue;                      }                      // We pick up loot depending on isk per m3                      var isMissionItem = Cache.Instance.MissionItems.Contains((item.Name ?? string.Empty).ToLower());                        // Never pick up contraband (unless its the mission item)                      if (!isMissionItem && item.IsContraband)                          continue;                        // Do we want to loot other items?                      if (!isMissionItem && !LootEverything)                          continue;                        // Do not pick up items that cannot enter in a freighter container (unless its the mission item)                      // Note: some mission items that are alive have been allowed to be                       //       scooped because unloadlootstate.MoveCommonMissionCompletionitems                       //       will move them into the hangar floor not the loot location                      if (!isMissionItem && item.IsAliveandWontFitInContainers)                          continue;                        // We are at our max' either make room or skip the item                      if ((freeCargoCapacity - item.TotalVolume) <= (isMissionItem ? 0 : ReserveCargoCapacity))                      {                          // We can't drop items in this container anyway' well get it after its salvaged                          if (!isMissionItem && containerEntity.GroupId != (int) Group.CargoContainer)                              continue;                            // Make a list of items which are worth less                          List<ItemCache> worthLess;                          if (isMissionItem)                              worthLess = shipsCargo;                          else if (item.IskPerM3.HasValue)                              worthLess = shipsCargo.Where(sc => sc.IskPerM3.HasValue && sc.IskPerM3 < item.IskPerM3).ToList();                          else                              worthLess = shipsCargo.Where(sc => sc.IskPerM3.HasValue).ToList();                            // Remove mission item from this list                          worthLess.RemoveAll(wl => Cache.Instance.MissionItems.Contains((wl.Name ?? string.Empty).ToLower()));                          worthLess.RemoveAll(wl => (wl.Name ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem);                            // Consider dropping ammo if it concerns the mission item!                          if (!isMissionItem)                              worthLess.RemoveAll(wl => Ammo.Any(a => a.TypeId == wl.TypeId));                            // Nothing is worth less then the current item                          if (worthLess.Count() == 0)                              continue;                            // Not enough space even if we dumped the crap                          if ((freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) < item.TotalVolume)                          {                              if (isMissionItem)                                  Logging.Log("Salvage: Not enough space for mission item! Need [" + item.TotalVolume + "] maximum available [" + (freeCargoCapacity + worthLess.Sum(wl => wl.TotalVolume)) + "]");                                continue;                          }                            // Start clearing out items that are worth less                          var moveTheseItems = new List<DirectItem>();                          foreach (var wl in worthLess.OrderBy(wl => wl.IskPerM3.HasValue ? wl.IskPerM3.Value : double.MaxValue).ThenByDescending(wl => wl.TotalVolume))                          {                              // Mark this item as moved                              moveTheseItems.Add(wl.DirectItem);                                // Subtract (now) free volume                              freeCargoCapacity += wl.TotalVolume;                                // We freed up enough space?                              if ((freeCargoCapacity - item.TotalVolume) >= ReserveCargoCapacity)                                  break;                          }                            if (moveTheseItems.Count > 0)                          {                              // If this is not a cargo container' then jettison loot                              if (containerEntity.GroupId != (int) Group.CargoContainer || isMissionItem)                              {                                  if (DateTime.Now.Subtract(_lastJettison).TotalSeconds < (int)Time.DelayBetweenJetcans_seconds)                                      return;                                    Logging.Log("Salvage: Jettisoning [" + moveTheseItems.Count + "] items to make room for the more valuable loot");                                    // Note: This could (in theory) fuck up with the bot jettison an item and                                   // then picking it up again :/ (granted it should never happen unless                                   // mission item volume > reserved volume                                  cargo.Jettison(moveTheseItems.Select(i => i.ItemId));                                  _lastJettison = DateTime.Now;                                  return;                              }                                // Move items to the cargo container                              container.Add(moveTheseItems);                                // Remove it from the ships cargo list                              shipsCargo.RemoveAll(i => moveTheseItems.Any(wl => wl.ItemId == i.Id));                              Logging.Log("Salvage: Moving [" + moveTheseItems.Count + "] items into the cargo container to make room for the more valuable loot");                          }                      }                        // Update free space                      freeCargoCapacity -= item.TotalVolume;                      lootItems.Add(item);                  }                      // Mark container as looted                  Cache.Instance.LootedContainers.Add(containerEntity.Id);                    // Loot actual items                  if (lootItems.Count != 0)                  {                      Logging.Log("Salvage: Looting container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "]' [" + lootItems.Count + "] valuable items");                      cargo.Add(lootItems.Select(i => i.DirectItem));                  }                  else                      Logging.Log("Salvage: Container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "] contained no valuable items");              }
Magic Number,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,LootWrecks,The following statement contains a magic number: foreach (var containerEntity in Cache.Instance.Containers.Where(e => e.Distance <= (int)Distance.SafeScoopRange))              {                  // Emptry wreck' ignore                  if (containerEntity.GroupId == (int) Group.Wreck && containerEntity.IsWreckEmpty)                      continue;                    // We looted this container                  if (Cache.Instance.LootedContainers.Contains(containerEntity.Id))                      continue;                    // We already opened the loot window                  var window = lootWindows.FirstOrDefault(w => w.ItemId == containerEntity.Id);                  if (window != null)                      continue;                    // Ignore open request within 10 seconds                  if (_openedContainers.ContainsKey(containerEntity.Id) && DateTime.Now.Subtract(_openedContainers[containerEntity.Id]).TotalSeconds < 10)                      continue;                    // Don't even try to open a wreck if you are speed tanking and you aren't processing a loot action                  if (Settings.Instance.SpeedTank == true && Cache.Instance.OpenWrecks == false)                      continue;                    // Don't even try to open a wreck if you are specified LootEverything as false and you aren't processing a loot action                  //      this is currently commented out as it would keep golems and other non-speed tanked ships from looting the field as they cleared                  //      missions' but NOT stick around after killing things to clear it ALL. Looteverything==false does NOT mean loot nothing                  //if (Settings.Instance.LootEverything == false && Cache.Instance.OpenWrecks == false)                  //    continue;                    // Open the container                  Logging.Log("Salvage: Opening container [" + containerEntity.Name + "][ID: " + containerEntity.Id + "]");                  containerEntity.OpenCargo();                  _openedContainers[containerEntity.Id] = DateTime.Now;                  break;              }
Magic Number,Questor.Modules,Salvage,C:\repos\Da-Teach_Questor\Questor.Modules\Salvage.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case SalvageState.TargetWrecks:                      TargetWrecks();                        // Next state                      State = SalvageState.LootWrecks;                      break;                    case SalvageState.LootWrecks:                      LootWrecks();                        State = SalvageState.SalvageWrecks;                      break;                    case SalvageState.SalvageWrecks:                      ActivateTractorBeams();                      ActivateSalvagers();                        // Default action                      State = SalvageState.TargetWrecks;                      if (cargo.IsReady && cargo.Items.Any() && _nextSalvageAction < DateTime.Now)                      {                          // Check if there are actually duplicates                          var duplicates = cargo.Items.Where(i => i.Quantity > 0).GroupBy(i => i.TypeId).Any(t => t.Count() > 1);                          if (duplicates)                              State = SalvageState.StackItems;                          else                              _nextSalvageAction = DateTime.Now.AddSeconds((int)Time.SalvageStackItems_seconds);                      }                      break;                    case SalvageState.StackItems:                      Logging.Log("Salvage: Stacking items");                        if (cargo.IsReady)                          cargo.StackAll();                        _nextSalvageAction = DateTime.Now.AddSeconds((int)Time.SalvageStackItemsDelayBeforeResuming_seconds);                      State = SalvageState.WaitForStacking;                      break;                    case SalvageState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (_nextSalvageAction > DateTime.Now)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("Salvage: Done stacking");                          State = SalvageState.TargetWrecks;                          break;                      }                        if (DateTime.Now.Subtract(_nextSalvageAction).TotalSeconds > 120)                      {                          Logging.Log("Salvage: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("Salvage: Done stacking");                          State = SalvageState.TargetWrecks;                          break;                      }                      break;                    default:                      // Unknown state' goto first state                      State = SalvageState.TargetWrecks;                      break;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,ramdom_number,The following statement contains a magic number: return ramdom.Next(10' 35);
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,ramdom_number,The following statement contains a magic number: return ramdom.Next(10' 35);
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (!File.Exists(Settings.Instance.settingsPath)) //if the settings file does not exist initialize these values. Should we not halt when missing the settings XML?              {                  // Clear settings                  //AgentName = string.Empty;                    CharacterMode = "dps";                    AutoStart = false;                    SaveConsoleLog = true;                    maxLineConsole = 1000;                    waitDecline = false;                    Disable3D = false;                    RandomDelay = 0;                    minStandings = 10;                    MinimumDelay = 0;                    minStandings = 10;                    WindowXPosition = null;                  WindowYPosition = null;                    LootHangar = string.Empty;                  AmmoHangar = string.Empty;                  BookmarkHangar = string.Empty;                  LootContainer = string.Empty;                    MissionsPath = Path.Combine(path' "Missions");                    bookmarkWarpOut = string.Empty;                    MaximumHighValueTargets = 0;                  MaximumLowValueTargets = 0;                    Ammo.Clear();                  ItemsBlackList.Clear();                  WreckBlackList.Clear();                  FactionFitting.Clear();                  AgentsList.Clear();                  MissionFitting.Clear();                    MinimumAmmoCharges = 0;                    WeaponGroupId = 0;                    ReserveCargoCapacity = 0;                    MaximumWreckTargets = 0;                    SpeedTank = false;                  OrbitDistance = 0;                  OptimalRange = 0;                  NosDistance = 38000;                  MinimumPropulsionModuleDistance = 3000;                  MinimumPropulsionModuleCapacitor = 35;                    ActivateRepairModules = 0;                  DeactivateRepairModules = 0;                    MinimumShieldPct = 0;                  MinimumArmorPct = 0;                  MinimumCapacitorPct = 0;                  SafeShieldPct = 0;                  SafeArmorPct = 0;                  SafeCapacitorPct = 0;                    UseDrones = false;                  DroneTypeId = 0;                  DroneControlRange = 0;                  DroneMinimumShieldPct = 0;                  DroneMinimumArmorPct = 0;                  DroneMinimumCapacitorPct = 0;                  DroneRecallCapacitorPct = 0;                  LongRangeDroneRecallCapacitorPct = 0;                    UseGatesInSalvage = false;                    Blacklist.Clear();                  FactionBlacklist.Clear();                    missionName = null;                  //missionbookmarktoagentloops = 0;                  return;              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: maxLineConsole = (int?)xml.Element("maxLineConsole") ?? 1000;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: minStandings = (float?) xml.Element("minStandings") ?? 10;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: LocalBadStandingLevelToConsiderBad = (double?)xml.Element("LocalBadStandingLevelToConsiderBad") ?? -0.1;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: IskPerLP = (double?)xml.Element("IskPerLP") ?? 600;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: UndockDelay = (int?)xml.Element("undockdelay") ?? 10;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: WindowXPosition = (int?) xml.Element("windowXPosition") ?? 1600;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: WindowYPosition = (int?)xml.Element("windowYPosition") ?? 1050;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: EVEProcessMemoryCeiling = (int?)xml.Element("EVEProcessMemoryCeiling") ?? 900;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: walletbalancechangelogoffdelay = (int?)xml.Element("walletbalancechangelogoffdelay") ?? 30;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MaximumHighValueTargets = (int?) xml.Element("maximumHighValueTargets") ?? 2;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MaximumLowValueTargets = (int?) xml.Element("maximumLowValueTargets") ?? 2;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if(agentList != null)              {                  if (agentList.HasElements)                  {                                           int i = 0;                      foreach (var agent in agentList.Elements("agentList"))                      {                          AgentsList.Add(new AgentsList(agent));                          i++;                      }                      if (i >= 2)                      {                          MultiAgentSupport = true;                          Logging.Log("Settings: Found more than one agent in your character XML: MultiAgentSupport is true");                      }                      else                      {                          MultiAgentSupport = false;                          Logging.Log("Settings: Found only one agent in your character XML: MultiAgentSupport is false");                      }                  }                  else                  {                      Logging.Log("Settings: agentList exists in your characters config but no agents were listed.");                  }              }              else                  Logging.Log("Settings: Error! No Agents List specified.");
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: NosDistance = (int?)xml.Element("NosDistance") ?? 38000;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MinimumPropulsionModuleDistance = (int?) xml.Element("minimumPropulsionModuleDistance") ?? 5000;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: ActivateRepairModules = (int?) xml.Element("activateRepairModules") ?? 65;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: DeactivateRepairModules = (int?) xml.Element("deactivateRepairModules") ?? 95;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MinimumShieldPct = (int?) xml.Element("minimumShieldPct") ?? 100;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MinimumArmorPct = (int?) xml.Element("minimumArmorPct") ?? 100;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MinimumCapacitorPct = (int?) xml.Element("minimumCapacitorPct") ?? 50;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: DroneMinimumShieldPct = (int?) xml.Element("droneMinimumShieldPct") ?? 50;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: DroneMinimumArmorPct = (int?) xml.Element("droneMinimumArmorPct") ?? 50;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MaterialsForWarOreID = (int?)xml.Element("MaterialsForWarOreID") ?? 20;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: MaterialsForWarOreQty = (int?)xml.Element("MaterialsForWarOreQty") ?? 8000;
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListSmallWrecks)              {                  WreckBlackList.Add(26557);                  WreckBlackList.Add(26561);                  WreckBlackList.Add(26564);                  WreckBlackList.Add(26567);                  WreckBlackList.Add(26570);                  WreckBlackList.Add(26573);                  WreckBlackList.Add(26576);                  WreckBlackList.Add(26579);                  WreckBlackList.Add(26582);                  WreckBlackList.Add(26585);                  WreckBlackList.Add(26588);                  WreckBlackList.Add(26591);                  WreckBlackList.Add(26594);                  WreckBlackList.Add(26935);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,Settings,C:\repos\Da-Teach_Questor\Questor.Modules\Settings.cs,LoadSettings,The following statement contains a magic number: if (WreckBlackListMediumWrecks)              {                  WreckBlackList.Add(26558);                  WreckBlackList.Add(26562);                  WreckBlackList.Add(26568);                  WreckBlackList.Add(26574);                  WreckBlackList.Add(26580);                  WreckBlackList.Add(26586);                  WreckBlackList.Add(26592);                  WreckBlackList.Add(26934);              }
Magic Number,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The following statement contains a magic number: if (localundockBookmark != null)              {                  if (Cache.Instance.DistanceFromMe(localundockBookmark.X ?? 0' localundockBookmark.Y ?? 0' localundockBookmark.Z ?? 0) < (int)Distance.WarptoDistance)                  {                      Logging.Log("TravelerDestination.BookmarkDestination: Arrived at undock bookmark [" + localundockBookmark.Title + "]");                      localundockBookmark = null;                  }                  else                  {                      Logging.Log("TravelerDestination.BookmarkDestination: Warping to undock bookmark [" + localundockBookmark.Title + "]");                      localundockBookmark.WarpTo();                      nextAction = DateTime.Now.AddSeconds(10);                      //nextAction = DateTime.Now.AddSeconds(Settings.Instance.UndockDelay);                      return false;                  }              }
Magic Number,Questor.Modules,StationDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The following statement contains a magic number: nextAction = DateTime.Now.AddSeconds(20);
Magic Number,Questor.Modules,BookmarkDestination,C:\repos\Da-Teach_Questor\Questor.Modules\TravelerDestination.cs,PerformFinalDestinationTask,The following statement contains a magic number: var arrived = PerformFinalDestinationTask(bookmark' 150000' ref _nextBookmarkAction' ref undockBookmark);
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Magic Number,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following statement contains a magic number: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
Missing Default,Questor.Modules,AgentInteraction,C:\repos\Da-Teach_Questor\Questor.Modules\AgentInteraction.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case AgentInteractionState.Idle:                      break;                  case AgentInteractionState.Done:                      break;                    case AgentInteractionState.ChangeAgent:                      Logging.Log("AgentInteraction: Change Agent");                      break;                    case AgentInteractionState.StartConversation:                      Agent.InteractWith();                        Logging.Log("AgentInteraction: Waiting for conversation");                      State = AgentInteractionState.WaitForConversation;                      break;                    case AgentInteractionState.WaitForConversation:                      WaitForConversation();                      break;                    case AgentInteractionState.ReplyToAgent:                      ReplyToAgent();                      break;                    case AgentInteractionState.WaitForMission:                      WaitForMission();                      break;                    case AgentInteractionState.AcceptMission:                      AcceptMission();                      break;                    case AgentInteractionState.DeclineMission:                      DeclineMission();                      break;                    case AgentInteractionState.CloseConversation:                      CloseConversation();                      break;              }
Missing Default,Questor.Modules,Arm,C:\repos\Da-Teach_Questor\Questor.Modules\Arm.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case ArmState.Idle:                      break;                  case ArmState.Done:                      break;                    case ArmState.NotEnoughDrones:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughDrones");                      //State = ArmState.Idle;                      break;                                    case ArmState.NotEnoughAmmo:                      //This is logged in questor.cs - do not double log                      //Logging.Log("Arm: Armstate.NotEnoughAmmo");                      //State = ArmState.Idle;                      break;                    case ArmState.Begin:                      //DefaultFittingChecked = false; //flag to check for the correct default fitting before using the fitting manager                      //DefaultFittingFound = true; //Did we find the default fitting?                      Cache.Instance.ArmLoadedCache = false;                      TryMissionShip = true;  // Used in the event we can't find the ship specified in the missionfittings                      UseMissionShip = false; // Were we successful in activating the mission specific ship?                      State = ArmState.OpenShipHangar;                      break;                    case ArmState.OpenShipHangar:                  case ArmState.SwitchToTransportShip:                  case ArmState.SwitchToSalvageShip:                      // Is the ship hangar open?                      if (shipHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenShipHangar);                          break;                      }                        if (!shipHangar.IsReady)                          break;                        if (State == ArmState.OpenShipHangar)                      {                          Logging.Log("Arm: Activating combat ship");                          State = ArmState.ActivateCombatShip;                      }                      else if (State == ArmState.SwitchToTransportShip)                      {                          Logging.Log("Arm: Activating transport ship");                          State = ArmState.ActivateTransportShip;                      }                      else                      {                          Logging.Log("Arm: Activating salvage ship");                          State = ArmState.ActivateSalvageShip;                      }                      break;                    case ArmState.ActivateTransportShip:                      string transportshipName = Settings.Instance.TransportShipName.ToLower();                        if (string.IsNullOrEmpty(transportshipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateTransportShip: Could not find transportshipName: " + transportshipName + " in settings!");                          return;                      }                      else if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != transportshipName)                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds) //default 10 seconds                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == transportshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      else if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds) //default 7 seconds                      {                          if (Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() == transportshipName)                          {                              Logging.Log("Arm.ActivateTransportShip: Done");                              State = ArmState.Done;                              return;                          }                      }                      break;                                        case ArmState.ActivateSalvageShip:                      var salvageshipName = Settings.Instance.SalvageShipName.ToLower();                        if (string.IsNullOrEmpty(salvageshipName))                      {                          State = ArmState.NotEnoughAmmo;                          Logging.Log("Arm.ActivateSalvageShip: Could not find salvageshipName: " + salvageshipName + " in settings!");                          return;                      }                        if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == salvageshipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                              }                              return;                          }                          return;                      }                      if ((!string.IsNullOrEmpty(salvageshipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != salvageshipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsCheck_seconds)                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                          return;                      }                      break;                    case ArmState.ActivateCombatShip:                      var shipName = Settings.Instance.CombatShipName.ToLower();                        if (string.IsNullOrEmpty(shipName))                      {                          State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm.ActivateCombatShip: Could not find CombatShipName: " + shipName + " in settings!");                          return;                      }                      if (!Cache.Instance.ArmLoadedCache)                      {                          _missionItemMoved = false;                          Cache.Instance.RefreshMissionItems(AgentId);                          Cache.Instance.ArmLoadedCache = true;                      }                      // If we've got a mission-specific ship defined' switch to it                      if ((State == ArmState.ActivateCombatShip) && !(Cache.Instance.MissionShip == "" || Cache.Instance.MissionShip == null) && TryMissionShip)                          shipName = Cache.Instance.MissionShip.ToLower();                        if (Settings.Instance.CombatShipName.ToLower() == shipName) // if the mission specific ship is our default combat ship' no need to do anything special                          TryMissionShip = false;                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == shipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  _lastArmAction = DateTime.Now;                                  if (TryMissionShip)                                      UseMissionShip = true;                                  return;                              }                                if (TryMissionShip && !UseMissionShip)                              {                                  Logging.Log("Arm: Unable to find the ship specified in the missionfitting.  Using default combat ship and default fitting.");                                  TryMissionShip = false;                                  Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                                  return;                              }                                State = ArmState.NotEnoughAmmo;                              Logging.Log("Arm: Found the following ships:");                              foreach (var ship in ships)                                  Logging.Log("Arm: [" + ship.GivenName + "]");                              Logging.Log("Arm: Could not find [" + shipName + "] ship!");                              return;                          }                          return;                      }                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          State = ArmState.OpenShipHangar;                          break;                      }                      else if (TryMissionShip)                          UseMissionShip = true;                        //if (State == ArmState.ActivateSalvageShip)                      //{                      //    Logging.Log("Arm: Done");                      //    State = ArmState.Done;                      //    return;                      //}                        //_missionItemMoved = false;                      //Cache.Instance.RefreshMissionItems(AgentId);                      if (AmmoToLoad.Count == 0 && string.IsNullOrEmpty(Cache.Instance.BringMissionItem))                      {                          Logging.Log("Arm: Done");                          State = ArmState.Done;                      }                      else                      {                          Logging.Log("Arm: Opening item hangar");                          State = ArmState.OpenItemHangar;                      }                      break;                    case ArmState.OpenItemHangar:                      // Is the hangar open?                      if (itemHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          _lastArmAction = DateTime.Now;                          break;                      }                        if (!itemHangar.IsReady)                          break;                        if (corpHangar != null)                      {                          Logging.Log("Arm: Opening corporation hangar");                          State = ArmState.OpenCorpHangar;                      }                      else                      {                          Logging.Log("Arm: Opening ship's cargo");                          State = ArmState.OpenCargo;                      }                      break;                    case ArmState.OpenCorpHangar:                      // Is the hangar open?                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("Arm: Opening ship's cargo");                      State = ArmState.OpenCargo;                      break;                    case ArmState.OpenCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (Settings.Instance.UseDrones && (Cache.Instance.DirectEve.ActiveShip.GroupId != 31 && Cache.Instance.DirectEve.ActiveShip.GroupId != 28 && Cache.Instance.DirectEve.ActiveShip.GroupId != 380))                      {                          Logging.Log("Arm: Opening ship's drone bay");                          State = ArmState.OpenDroneBay;                      }                      else if ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings)))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                      }                      else                          State = ArmState.MoveItems;                      break;                    case ArmState.OpenFittingWindow:                      //let's check first if we need to change fitting at all                      Logging.Log("Arm: Fitting: " + Cache.Instance.Fitting + " - currentFit: " + Cache.Instance.currentFit);                      if (Cache.Instance.Fitting.Equals(Cache.Instance.currentFit))                      {                          Logging.Log("Arm: Current fit is correct - no change necessary");                          State = ArmState.MoveItems;                      }                      else                      {                          Cache.Instance.DirectEve.OpenFitingManager();                          State = ArmState.WaitForFittingWindow;                      }                      break;                    case ArmState.WaitForFittingWindow:                        var fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      //open it again ?                      if (fittingMgr == null)                      {                          Logging.Log("Arm: Opening fitting manager");                          Cache.Instance.DirectEve.OpenFitingManager();                      }                      //check if it's ready                      else if (fittingMgr.IsReady)                      {                          State = ArmState.ChoseFitting;                      }                      break;                    case ArmState.ChoseFitting:                      fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      bool found = false;                      if (!DefaultFittingChecked)                      {                          DefaultFittingChecked = true;                          Logging.Log("Arm: Looking for Default Fitting " + Cache.Instance.DefaultFitting);                          foreach (var fitting in fittingMgr.Fittings)                          {                              //ok found it                              if (Cache.Instance.DefaultFitting.ToLower().Equals(fitting.Name.ToLower()))                              {                                  found = true;                                  Logging.Log("Arm: Found Default Fitting " + fitting.Name);                              }                          }                          if (!found)                          {                              Logging.Log("Arm: Error! Couldn't find Default Fitting.  Disabling fitting manager.");                              DefaultFittingFound = false;                              Settings.Instance.UseFittingManager = false;                              State = ArmState.MoveItems;                              break;                          }                          found = false;                      }                      Logging.Log("Arm: Looking for fitting " + Cache.Instance.Fitting);                      foreach (var fitting in fittingMgr.Fittings)                      {                          //ok found it                          var ship = Cache.Instance.DirectEve.ActiveShip;                          if (Cache.Instance.Fitting.ToLower().Equals(fitting.Name.ToLower()) && fitting.ShipTypeId == ship.TypeId)                          {                              Logging.Log("Arm: Found fitting " + fitting.Name);                              //switch to the requested fitting for the current mission                              fitting.Fit();                              _lastArmAction = DateTime.Now;                              Cache.Instance.currentFit = fitting.Name;                              State = ArmState.WaitForFitting;                              found = true;                              break;                          }                        }                      //if we didn't find it' we'll set currentfit to default                      //this should provide backwards compatibility without trying to fit always                      if (!found)                      {                          if (UseMissionShip)                          {                              Logging.Log("Arm: Couldn't find fitting for this ship typeid.  Using current fitting.");                              State = ArmState.MoveItems;                              break;                          }                          else                          {                              Logging.Log("Arm: Couldn't find fitting - switching to default");                              Cache.Instance.Fitting = Cache.Instance.DefaultFitting;                              break;                          }                      }                      State = ArmState.MoveItems;                      fittingMgr.Close();                      break;                    case ArmState.WaitForFitting:                      //let's wait 10 seconds                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds > (int)Time.FittingWindowLoadFittingDelay_seconds &&                          Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          //we should be done fitting' proceed to the next state                          State = ArmState.MoveItems;                          fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                          fittingMgr.Close();                          Logging.Log("Arm: Done fitting");                      }                      else Logging.Log("Arm: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastArmAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count);                      break;                    case ArmState.OpenDroneBay:                      // Is cargo open?                      if (droneBay.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenDroneBayOfActiveShip);                          break;                      }                         if (!droneBay.IsReady)                          break;                         Logging.Log("Arm: Moving drones");                      State = ArmState.MoveDrones;                      break;                     case ArmState.MoveDrones:                      var drone = ammoHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (!string.IsNullOrEmpty(Settings.Instance.AmmoHangar))                          drone = corpHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      else                          drone = itemHangar.Items.FirstOrDefault(i => i.TypeId == Settings.Instance.DroneTypeId);                      if (drone == null || drone.Stacksize < 1)                      {                          Logging.Log("Arm: Out of drones");                          State = ArmState.NotEnoughDrones;                          break;                      }                         var neededDrones = Math.Floor((droneBay.Capacity - droneBay.UsedCapacity)/drone.Volume);                      Logging.Log("neededDrones: " + neededDrones);                      if (neededDrones == 0 && ((Settings.Instance.UseFittingManager && DefaultFittingFound) && !(UseMissionShip && !(Cache.Instance.ChangeMissionShipFittings))))                      {                          Logging.Log("Arm: Fitting");                          State = ArmState.OpenFittingWindow;                          break;                      }                      else if (neededDrones == 0)                      {                          State = ArmState.MoveItems;                          break;                      }                        // Move needed drones                      droneBay.Add(drone' (int)Math.Min(neededDrones' drone.Stacksize));                      break;                    case ArmState.MoveItems:                      var bringItem = Cache.Instance.BringMissionItem;                      if (string.IsNullOrEmpty(bringItem))                          _missionItemMoved = true;                        if (!_missionItemMoved)                      {                          var missionItem = (corpHangar ?? itemHangar).Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                          if (missionItem == null)                              missionItem = itemHangar.Items.FirstOrDefault(i => (i.TypeName ?? string.Empty).ToLower() == bringItem);                            if (missionItem != null)                          {                              Logging.Log("Arm: Moving [" + missionItem.TypeName + "]");                                cargo.Add(missionItem' 1);                              _missionItemMoved = true;                              break;                          }                      }                        var itemMoved = false;                      if (Cache.Instance.missionAmmo.Count() != 0)                      {                          AmmoToLoad = new List<Ammo>(Cache.Instance.missionAmmo);                      }                      foreach (var item in ammoHangar.Items.OrderBy(i => i.Quantity))                      {                          if (item.ItemId <= 0)                              continue;                            var ammo = AmmoToLoad.FirstOrDefault(a => a.TypeId == item.TypeId);                          if (ammo == null)                              continue;                            Logging.Log("Arm: Moving [" + item.TypeName + "]");                            var moveQuantity = Math.Min(item.Quantity' ammo.Quantity);                          moveQuantity = Math.Max(moveQuantity' 1);                          cargo.Add(item' moveQuantity);                            ammo.Quantity -= moveQuantity;                          if (ammo.Quantity <= 0)                          {                              Cache.Instance.missionAmmo.RemoveAll(a => a.TypeId == item.TypeId);                              AmmoToLoad.RemoveAll(a => a.TypeId == item.TypeId);                          }                          itemMoved = true;                          break;                      }                        if (AmmoToLoad.Count == 0 && _missionItemMoved)                      {                          _lastArmAction = DateTime.Now;                            Logging.Log("Arm: Waiting for items");                          State = ArmState.WaitForItems;                      }                      else if (!itemMoved)                      {                          if (AmmoToLoad.Count > 0)                              foreach (var ammo in AmmoToLoad)                              {                                  Logging.Log("Arm: Missing ammo with TypeId [" + ammo.TypeId + "]");                              }                            if (!_missionItemMoved)                              Logging.Log("Arm: Missing mission item [" + bringItem + "]");                            State = ArmState.NotEnoughAmmo;                      }                      break;                    case ArmState.WaitForItems:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastArmAction).TotalSeconds < (int)Time.Armstate_WaitforItemstoMove_seconds)                          break;                        if (cargo.Items.Count == 0)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          // Close the drone bay' its not required in space.                          if (droneBay.IsReady)                              droneBay.Window.Close();                            Logging.Log("Arm: Done");                            //reload the ammo setting for combat                          try                          {                              var mission = Cache.Instance.DirectEve.AgentMissions.FirstOrDefault(m => m.AgentId == AgentId);                              if (mission == null)                                  return;                                var missionName = Cache.Instance.FilterPath(mission.Name);                              var missionXmlPath = Path.Combine(Settings.Instance.MissionsPath' missionName + ".xml");                              var missionXml = XDocument.Load(missionXmlPath);                              Cache.Instance.missionAmmo = new List<Ammo>();                              var ammoTypes = missionXml.Root.Element("missionammo");                              if (ammoTypes != null)                                  foreach (var ammo in ammoTypes.Elements("ammo"))                                      Cache.Instance.missionAmmo.Add(new Ammo(ammo));                          }                          catch (Exception e)                          {                              Logging.Log("Arms.WaitForItems: Unable to load missionammo from mission XML: no XML found' " + e.Message);                              Cache.Instance.missionAmmo = new List<Ammo>();                          }                            State = ArmState.Done;                          break;                      }                        // Note' there's no unlock here as we *always* want our ammo!                      break;              }
Missing Default,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,PerformAction,The following switch statement is missing a default case: switch (action.State)              {                  case ActionState.Activate:                      ActivateAction(action);                      break;                    case ActionState.ClearPocket:                      ClearPocketAction(action);                      break;                    case ActionState.SalvageBookmark:                      BookmarkPocketForSalvaging();                        _currentAction++;                      break;                    case ActionState.Done:                      // Tell the drones module to retract drones                      Cache.Instance.IsMissionPocketDone = true;                        // We do not switch to "done" status if we still have drones out                      if (Cache.Instance.ActiveDrones.Count() > 0)                          return;                        // Add bookmark (before we're done)                      if(Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons                      ReloadAll();                        State = AnomalyControllerState.Done;                      break;                    case ActionState.Kill:                      KillAction(action);                      break;                    case ActionState.MoveTo:                      MoveToAction(action);                      break;                    case ActionState.Loot:                      LootAction(action);                      break;                    case ActionState.LootItem:                      LootItemAction(action);                      break;                    case ActionState.Ignore:                      IgnoreAction(action);                      break;                    case ActionState.WaitUntilTargeted:                      WaitUntilTargeted(action);                      break;              }
Missing Default,Questor.Modules,AnomalyController,C:\repos\Da-Teach_Questor\Questor.Modules\AnomalyController.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case AnomalyControllerState.Idle:                  case AnomalyControllerState.Done:                  case AnomalyControllerState.Error:                      break;                    case AnomalyControllerState.Start:                      _pocket = 0;                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = AnomalyControllerState.LoadPocket;                      break;                    case AnomalyControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(0' _pocket' false));                        if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("AnomalyController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("AnomalyController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("AnomalyController: Action." + a);  					  					if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)  						Logging.Log("AnomalyController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);  						                      // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = AnomalyControllerState.ExecutePocketActions;                      break;                    case AnomalyControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("AnomalyController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = AnomalyControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("AnomalyController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("AnomalyController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case AnomalyControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("AnomalyController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = AnomalyControllerState.LoadPocket;                      }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("AnomalyController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = AnomalyControllerState.ExecutePocketActions;                      }                      break;              }
Missing Default,Questor.Modules,CourierMission,C:\repos\Da-Teach_Questor\Questor.Modules\CourierMission.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case CourierMissionState.Idle:                      break;                    case CourierMissionState.GotoPickupLocation:                      if (GotoMissionBookmark(Cache.Instance.AgentId' "Objective (Pick Up)"))                          State = CourierMissionState.PickupItem;                      break;                    case CourierMissionState.PickupItem:                      if (MoveItem(true))                          State = CourierMissionState.GotoDropOffLocation;                      break;                    case CourierMissionState.GotoDropOffLocation:                      if (GotoMissionBookmark(Cache.Instance.AgentId' "Objective (Drop Off)"))                          State = CourierMissionState.DropOffItem;                      break;                    case CourierMissionState.DropOffItem:                      if (MoveItem(false))                          State = CourierMissionState.Done;                      break;                    case CourierMissionState.Done:                      Logging.Log("CourierMissionState: Done");                      break;              }
Missing Default,Questor.Modules,SwitchShip,C:\repos\Da-Teach_Questor\Questor.Modules\SwitchShip.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case SwitchShipState.Idle:                        break;                  case SwitchShipState.Done:                      break;                    case SwitchShipState.Begin:                      State = SwitchShipState.OpenShipHangar;                      break;                    case SwitchShipState.OpenShipHangar:                      // Is the ship hangar open?                      if (shipHangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenShipHangar);                          break;                      }                        if (!shipHangar.IsReady)                          break;                        Logging.Log("SwitchShip: Activating combat ship");                        State = SwitchShipState.ActivateCombatShip;                        break;                    case SwitchShipState.ActivateCombatShip:                      var shipName = Settings.Instance.CombatShipName.ToLower();                        if ((!string.IsNullOrEmpty(shipName) && Cache.Instance.DirectEve.ActiveShip.GivenName.ToLower() != shipName))                      {                          if (DateTime.Now.Subtract(_lastSwitchShipAction).TotalSeconds > (int)Time.SwitchShipsDelay_seconds)                          {                              var ships = Cache.Instance.DirectEve.GetShipHangar().Items;                              foreach (var ship in ships.Where(ship => ship.GivenName.ToLower() == shipName))                              {                                  Logging.Log("Arm: Making [" + ship.GivenName + "] active");                                    ship.ActivateShip();                                  Logging.Log("SwitchShip: Activated");                                  _lastSwitchShipAction = DateTime.Now;                                  return;                              }                          }                      }                      if (Settings.Instance.UseFittingManager)                          State = SwitchShipState.OpenFittingWindow;                      else                          State = SwitchShipState.Done;                        break;                      case SwitchShipState.OpenFittingWindow:                      //let's check first if we need to change fitting at all                      Logging.Log("SwitchShip: Fitting: " + DefaultFitting + " - currentFit: " + Cache.Instance.currentFit);                      if (DefaultFitting.Equals(Cache.Instance.currentFit))                      {                          Logging.Log("SwitchShip: Current fit is correct - no change necessary");                          State = SwitchShipState.Done;                      }                      else                      {                          Cache.Instance.DirectEve.OpenFitingManager();                          State = SwitchShipState.WaitForFittingWindow;                      }                      break;                    case SwitchShipState.WaitForFittingWindow:                        var fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                      //open it again ?                      if (fittingMgr == null)                      {                          Logging.Log("SwitchShip: Opening fitting manager");                          Cache.Instance.DirectEve.OpenFitingManager();                      }                      //check if it's ready                      else if (fittingMgr.IsReady)                      {                          State = SwitchShipState.ChoseFitting;                      }                      break;                    case SwitchShipState.ChoseFitting:                      fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                        Logging.Log("SwitchShip: Looking for fitting " + DefaultFitting);                      foreach (var fitting in fittingMgr.Fittings)                      {                          //ok found it                          var ship = Cache.Instance.DirectEve.ActiveShip;                          if (DefaultFitting.ToLower().Equals(fitting.Name.ToLower()) && fitting.ShipTypeId == ship.TypeId)                          {                              Logging.Log("SwitchShip: Found fitting " + fitting.Name);                              //switch to the requested fitting for the current mission                              fitting.Fit();                              _lastSwitchShipAction = DateTime.Now;                              Cache.Instance.currentFit = fitting.Name;                              State = SwitchShipState.WaitForFitting;                              break;                          }                        }                      State = SwitchShipState.Done;                      fittingMgr.Close();                      break;                    case SwitchShipState.WaitForFitting:                      //let's wait 10 seconds                      if (DateTime.Now.Subtract(_lastSwitchShipAction).TotalMilliseconds > (int)Time.FittingWindowLoadFittingDelay_seconds &&                          Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          //we should be done fitting' proceed to the next state                          State = SwitchShipState.Done;                          fittingMgr = Cache.Instance.DirectEve.Windows.OfType<DirectFittingManagerWindow>().FirstOrDefault();                          fittingMgr.Close();                          Logging.Log("SwitchShip: Done fitting");                      }                      else Logging.Log("SwitchShip: Waiting for fitting. time elapsed = " + DateTime.Now.Subtract(_lastSwitchShipAction).TotalMilliseconds + " locked items = " + Cache.Instance.DirectEve.GetLockedItems().Count);                      break;                    case SwitchShipState.NotEnoughAmmo:                      Logging.Log("SwitchShip: Out of Ammo' checking a solution ...");                      break;              }
Missing Default,Questor.Modules,Drones,C:\repos\Da-Teach_Questor\Questor.Modules\Drones.cs,ProcessState,The following switch statement is missing a default case: switch (State)             {                 case DroneState.WaitingForTargets:                     // Are we in the right state ?                     if (Cache.Instance.ActiveDrones.Count() > 0)                     {                         // Apparently not' we have drones out' go into fight mode                         State = DroneState.Fighting;                         break;                     }                      // Should we launch drones?                     var launch = true;                     // Always launch if we're scrambled                     if (!Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe))                     {                         // Are we done with this mission pocket?                         launch &= !Cache.Instance.IsMissionPocketDone;                          // If above minimums                         launch &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage >= Settings.Instance.DroneMinimumShieldPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage >= Settings.Instance.DroneMinimumArmorPct;                         launch &= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage >= Settings.Instance.DroneMinimumCapacitorPct;                          // yes if there are targets to kill                          launch &= Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.CategoryId == (int)CategoryID.Entity && e.IsNpc && !e.IsContainer && e.GroupId != (int)Group.LargeCollidableStructure && e.Distance < Settings.Instance.DroneControlRange) > 0;                          // If drones get aggro'd within 30 seconds' then wait (5 * _recallCount + 5) seconds since the last recall                          if (_lastLaunch < _lastRecall && _lastRecall.Subtract(_lastLaunch).TotalSeconds < 30)                         {                             if (_lastRecall.AddSeconds(5 * _recallCount + 5) < DateTime.Now)                             {                                 // Increase recall count and allow the launch                                 _recallCount++;                                  // Never let _recallCount go above 5                                 if (_recallCount > 5)                                     _recallCount = 5;                             }                             else                             {                                 // Do not launch the drones until the delay has passed                                 launch = false;                             }                         }                         else // Drones have been out for more then 30s                              _recallCount = 0;                     }                      if (launch)                     {                         // Reset launch tries                         _launchTries = 0;                         _lastLaunch = DateTime.Now;                         State = DroneState.Launch;                     }                     break;                  case DroneState.Launch:                     // Launch all drones                     recall = false;                      _launchTimeout = DateTime.Now;                     Cache.Instance.DirectEve.ActiveShip.LaunchAllDrones();                     State = DroneState.Launching;                     break;                  case DroneState.Launching:                     // We haven't launched anything yet' keep waiting                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 10)                         {                             // Relaunch if tries < 10                             if (_launchTries < 10)                             {                                 _launchTries++;                                 State = DroneState.Launch;                                 break;                             }                             else                                 State = DroneState.OutOfDrones;                         }                         break;                     }                      // Are we done launching?                     if (_lastDroneCount == Cache.Instance.ActiveDrones.Count())                         State = DroneState.Fighting;                     break;                  case DroneState.OutOfDrones:                     //if (DateTime.Now.Subtract(_launchTimeout).TotalSeconds > 1000)                     //{                     //    State = DroneState.WaitingForTargets;                     //}                     break;                 case DroneState.Fighting:                     // Should we recall our drones? This is a possible list of reasons why we should                                           // Are we done (for now) ?                      if (Cache.Instance.TargetedBy.Count(e => !e.IsSentry && e.IsNpc && e.Distance < Settings.Instance.DroneControlRange) == 0)                     {                         Logging.Log("Drones: Recalling drones because no NPC is targeting us within dronerange");                         recall = true;                     }                      if (Cache.Instance.IsMissionPocketDone)                     {                         Logging.Log("Drones: Recalling drones because we are done with this pocket.");                         recall = true;                     }                     else if (_shieldPctTotal > GetShieldPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost shields! [Old: " + _shieldPctTotal.ToString("N2") + "][New: " + GetShieldPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_armorPctTotal > GetArmorPctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost armor! [Old:" + _armorPctTotal.ToString("N2") + "][New: " + GetArmorPctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (_structurePctTotal > GetStructurePctTotal())                     {                         Logging.Log("Drones: Recalling drones because we have lost structure! [Old:" + _structurePctTotal.ToString("N2") + "][New: " + GetStructurePctTotal().ToString("N2") + "]");                         recall = true;                     }                     else if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                     {                         // Did we lose a drone? (this should be covered by total's as well though)                         Logging.Log("Drones: Recalling drones because we have lost a drone! [Old:" + _lastDroneCount + "][New: " + Cache.Instance.ActiveDrones.Count() + "]");                         recall = true;                     }                     else                     {                         // Default to long range recall                         var lowShieldWarning = Settings.Instance.LongRangeDroneRecallShieldPct;                         var lowArmorWarning = Settings.Instance.LongRangeDroneRecallArmorPct;                         var lowCapWarning = Settings.Instance.LongRangeDroneRecallCapacitorPct;                          if (Cache.Instance.ActiveDrones.Average(d => d.Distance) < (Settings.Instance.DroneControlRange/2d))                         {                             lowShieldWarning = Settings.Instance.DroneRecallShieldPct;                             lowArmorWarning = Settings.Instance.DroneRecallArmorPct;                             lowCapWarning = Settings.Instance.DroneRecallCapacitorPct;                         }                          if (Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < lowShieldWarning)                         {                             Logging.Log("Drones: Recalling drones due to shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + lowShieldWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < lowArmorWarning)                         {                             Logging.Log("Drones: Recalling drones due to armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + lowArmorWarning + "%] minimum");                             recall = true;                         }                         else if (Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < lowCapWarning)                         {                             Logging.Log("Drones: Recalling drones due to capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + lowCapWarning + "%] minimum");                             recall = true;                         }                     }                      if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         Logging.Log("Drones: Apparently we have lost all our drones");                         recall = true;                     }                     else                     {                         var isPanicking = false;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct;                         isPanicking |= Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct;                         if (Cache.Instance.PriorityTargets.Any(pt => pt.IsWarpScramblingMe) && recall)                         {                             Logging.Log("Drones: Overriding drone recall' we are scrambled!");                             recall = false;                         }                     }                      // Recall or engage                     if (recall)                         State = DroneState.Recalling;                     else                     {                         EngageTarget();                          // We lost a drone and did not recall' assume panicking and launch (if any) additional drones                         if (Cache.Instance.ActiveDrones.Count() < _lastDroneCount)                             State = DroneState.Launch;                     }                     break;                  case DroneState.Recalling:                     // Are we done?                     if (Cache.Instance.ActiveDrones.Count() == 0)                     {                         _lastRecall = DateTime.Now;                         recall = false;                          State = DroneState.WaitingForTargets;                         break;                     }                      // Give recall command every 5 seconds                     if (DateTime.Now.Subtract(_lastRecallCommand).TotalSeconds > 5)                     {                         Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.CmdDronesReturnToBay);                         _lastRecallCommand = DateTime.Now;                     }                     break;             }
Missing Default,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,PerformAction,The following switch statement is missing a default case: switch (action.State)              {                  case ActionState.Activate:                      ActivateAction(action);                      break;                    case ActionState.ClearPocket:                      ClearPocketAction(action);                      break;                    case ActionState.SalvageBookmark:                      BookmarkPocketForSalvaging();                        _currentAction++;                      break;                    case ActionState.Done:                      // Tell the drones module to retract drones                      Cache.Instance.IsMissionPocketDone = true;                        // We do not switch to "done" status if we still have drones out                      if (Cache.Instance.ActiveDrones.Count() > 0)                          return;                        // Add bookmark (before we're done)                      if (Settings.Instance.CreateSalvageBookmarks)                          BookmarkPocketForSalvaging();                        // Reload weapons                      if (DateTime.Now.Subtract(_lastReload).TotalSeconds > 20)                      {                          Logging.Log("MissionController: ReloadAll: Reload because ActionState is Done - Reloading Weapons.");                          ReloadAll();                          _lastReload = DateTime.Now;                      }                        State = MissionControllerState.Done;                      break;                    case ActionState.Kill:                      KillAction(action);                      break;                    case ActionState.KillOnce:                      KillOnceAction(action);                      break;                    case ActionState.AttackClosestByName:                      AttackClosestByNameAction(action);                      break;                    case ActionState.AttackClosest:                      AttackClosestAction(action);                      break;                    case ActionState.MoveTo:                      MoveToAction(action);                      break;                    case ActionState.MoveToBackground:                      MoveToBackgroundAction(action);                      break;                                    case ActionState.ClearWithinWeaponsRangeOnly:                      ClearWithinWeaponsRangeOnlyAction(action);                      break;                    case ActionState.Loot:                      LootAction(action);                      break;                    case ActionState.LootItem:                      LootItemAction(action);                      break;                    case ActionState.Ignore:                      IgnoreAction(action);                      break;                    case ActionState.WaitUntilTargeted:                      WaitUntilTargeted(action);                      break;              }
Missing Default,Questor.Modules,MissionController,C:\repos\Da-Teach_Questor\Questor.Modules\MissionController.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case MissionControllerState.Idle:                      break;                  case MissionControllerState.Done:                      LogStatistics();                        if (!Cache.Instance.NormalApproch)                          Cache.Instance.NormalApproch = true;                        Cache.Instance.IgnoreTargets.Clear();                      break;                  case MissionControllerState.Error:                      break;                    case MissionControllerState.Start:                      _pocket = 0;                      // Update statistic values                      Wealth = Cache.Instance.DirectEve.Me.Wealth;                      StartedPocket = DateTime.Now;                        // Reload the items needed for this mission from the XML file                      Cache.Instance.RefreshMissionItems(AgentId);                        // Update x/y/z so that NextPocket wont think we are there yet because its checking (very) old x/y/z cords                      _lastX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                      _lastY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                      _lastZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                        State = MissionControllerState.LoadPocket;                      break;                    case MissionControllerState.LoadPocket:                      _pocketActions.Clear();                      _pocketActions.AddRange(Cache.Instance.LoadMissionActions(AgentId' _pocket' true));                        //                      // LogStatistics();                      //                      if (_pocketActions.Count == 0)                      {                          // No Pocket action' load default actions                          Logging.Log("MissionController: No mission actions specified' loading default actions");                            // Wait for 30 seconds to be targeted                          _pocketActions.Add(new Action {State = ActionState.WaitUntilTargeted});                          _pocketActions[0].AddParameter("timeout"' "15");                            // Clear the Pocket                          _pocketActions.Add(new Action {State = ActionState.ClearPocket});                            // Is there a gate?                          var gates = Cache.Instance.EntitiesByName("Acceleration Gate");                          if (gates != null && gates.Count() > 0)                          {                              // Activate it (Activate action also moves to the gate)                              _pocketActions.Add(new Action {State = ActionState.Activate});                              _pocketActions[_pocketActions.Count - 1].AddParameter("target"' "Acceleration Gate");                          }                          else // No' were done                              _pocketActions.Add(new Action {State = ActionState.Done});                            // TODO: Check mission HTML to see if we need to pickup any items                          // Not a priority' apparently retrieving HTML causes a lot of crashes                      }                        Logging.Log("MissionController: Pocket loaded' executing the following actions");                      foreach (var a in _pocketActions)                          Logging.Log("MissionController: Action." + a);                        if (Cache.Instance.OrbitDistance != Settings.Instance.OrbitDistance)                      {                          if (Cache.Instance.OrbitDistance == 0)                          {                              Cache.Instance.OrbitDistance = Settings.Instance.OrbitDistance;                              Logging.Log("MissionController: Using default orbit distance: " + Cache.Instance.OrbitDistance + " (as the custom one was 0)");                          }                          else                              Logging.Log("MissionController: Using custom orbit distance: " + Cache.Instance.OrbitDistance);                      }                        // Reset pocket information                      _currentAction = 0;                      Cache.Instance.IsMissionPocketDone = false;                      Cache.Instance.IgnoreTargets.Clear();                        State = MissionControllerState.ExecutePocketActions;                      break;                    case MissionControllerState.ExecutePocketActions:                      if (_currentAction >= _pocketActions.Count)                      {                          // No more actions' but we're not done?!?!?!                          Logging.Log("MissionController: We're out of actions but did not process a 'Done' or 'Activate' action");                            State = MissionControllerState.Error;                          break;                      }                        var action = _pocketActions[_currentAction];                      if (action.ToString() != Cache.Instance.CurrentPocketAction)                      {                          Cache.Instance.CurrentPocketAction = action.ToString();                      }                      var currentAction = _currentAction;                      PerformAction(action);                        if (currentAction != _currentAction)                      {                          Logging.Log("MissionController: Finished Action." + action);                            if (_currentAction < _pocketActions.Count)                          {                              action = _pocketActions[_currentAction];                              Logging.Log("MissionController: Starting Action." + action);                          }                      }                        if (Settings.Instance.DebugStates)                          Logging.Log("Action.State = " + action);                      break;                    case MissionControllerState.NextPocket:                      var distance = Cache.Instance.DistanceFromMe(_lastX' _lastY' _lastZ);                      if (distance > (int)Distance.NextPocketDistance)                      {                          Logging.Log("MissionController: We've moved to the next Pocket [" + Math.Round(distance/1000'0) + "k away]");                            // If we moved more then 100km' assume next Pocket                          _pocket++;                          State = MissionControllerState.LoadPocket;                          LogStatistics();                                                }                      else if (DateTime.Now.Subtract(_lastActivateAction).TotalMinutes > 2)                      {                          Logging.Log("MissionController: We've timed out' retry last action");                            // We have reached a timeout' revert to ExecutePocketActions (e.g. most likely Activate)                          State = MissionControllerState.ExecutePocketActions;                      }                      break;              }
Missing Default,Questor.Modules,Panic,C:\repos\Da-Teach_Questor\Questor.Modules\Panic.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case PanicState.Normal:                      if (!Cache.Instance.InSpace)                      {                          _lastDockedorJumping = DateTime.Now;                      }                        if (DateTime.Now.AddSeconds(3) > _lastDockedorJumping)                      {                          if (Cache.Instance.DirectEve.ActiveShip.Entity != null)                          {                              _lastNormalX = Cache.Instance.DirectEve.ActiveShip.Entity.X;                              _lastNormalY = Cache.Instance.DirectEve.ActiveShip.Entity.Y;                              _lastNormalZ = Cache.Instance.DirectEve.ActiveShip.Entity.Z;                          }                            if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          {                              Logging.Log("Panic: You are in a Capsule' you must have died :(");                              State = PanicState.StartPanicking;                          }                          else if (InMission && Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage < Settings.Instance.MinimumCapacitorPct && Cache.Instance.DirectEve.ActiveShip.GroupId != 31)                          {                              // Only check for cap-panic while in a mission' not while doing anything else                              Logging.Log("Panic: Start panicking' capacitor [" + Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage + "%] below [" + Settings.Instance.MinimumCapacitorPct + "%]");                              //Questor.panic_attempts_this_mission;                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ShieldPercentage < Settings.Instance.MinimumShieldPct)                          {                              Logging.Log("Panic: Start panicking' shield [" + Cache.Instance.DirectEve.ActiveShip.ShieldPercentage + "%] below [" + Settings.Instance.MinimumShieldPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                          else if (Cache.Instance.InSpace && Cache.Instance.DirectEve.ActiveShip.ArmorPercentage < Settings.Instance.MinimumArmorPct)                          {                              Logging.Log("Panic: Start panicking' armor [" + Cache.Instance.DirectEve.ActiveShip.ArmorPercentage + "%] below [" + Settings.Instance.MinimumArmorPct + "%]");                              Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                              Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                              State = PanicState.StartPanicking;                          }                            _delayedResume = false;                          if (InMission)                          {                              var frigates = Cache.Instance.Entities.Count(e => e.IsFrigate && e.IsPlayer);                              var cruisers = Cache.Instance.Entities.Count(e => e.IsCruiser && e.IsPlayer);                              var battlecruisers = Cache.Instance.Entities.Count(e => e.IsBattlecruiser && e.IsPlayer);                              var battleships = Cache.Instance.Entities.Count(e => e.IsBattleship && e.IsPlayer);                                if (Settings.Instance.FrigateInvasionLimit > 0 && frigates >= Settings.Instance.FrigateInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + frigates + "] frigates");                              }                                if (Settings.Instance.CruiserInvasionLimit > 0 && cruisers >= Settings.Instance.CruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + cruisers + "] cruisers");                              }                                if (Settings.Instance.BattlecruiserInvasionLimit > 0 && battlecruisers >= Settings.Instance.BattlecruiserInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battlecruisers + "] battlecruisers");                              }                                if (Settings.Instance.BattleshipInvasionLimit > 0 && battleships >= Settings.Instance.BattleshipInvasionLimit)                              {                                  _delayedResume = true;                                    Cache.Instance.panic_attempts_this_mission = (Cache.Instance.panic_attempts_this_mission + 1);                                  Cache.Instance.panic_attempts_this_pocket = (Cache.Instance.panic_attempts_this_pocket + 1);                                  State = PanicState.StartPanicking;                                  Logging.Log("Panic: Start panicking' mission invaded by [" + battleships + "] battleships");                              }                                if (_delayedResume)                              {                                  _randomDelay = (Settings.Instance.InvasionRandomDelay > 0 ? _random.Next(Settings.Instance.InvasionRandomDelay) : 0);                                  _randomDelay += Settings.Instance.InvasionMinimumDelay;                              }                          }                            Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                          if (Settings.Instance.SpeedTank)                          {                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWebbingMe)' Priority.Webbing);                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTargetPaintingMe)' Priority.TargetPainting);                          }                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsNeutralizingMe)' Priority.Neutralizing);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsJammingMe)' Priority.Jamming);                          Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsSensorDampeningMe)' Priority.Dampening);                          if (Cache.Instance.Modules.Any(m => m.IsTurret))                              Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsTrackingDisruptingMe)' Priority.TrackingDisrupting);                      }                      break;                    // NOTE: The difference between Panicking and StartPanicking is that the bot will move to "Panic" state once in warp & Panicking                   //       and the bot wont go into Panic mode while still "StartPanicking"                  case PanicState.StartPanicking:                  case PanicState.Panicking:                      // Add any warp scramblers to the priority list                      Cache.Instance.AddPriorityTargets(Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe)' Priority.WarpScrambler);                        // Failsafe' in theory would/should never happen                      if (State == PanicState.Panicking && Cache.Instance.TargetedBy.Any(t => t.IsWarpScramblingMe))                      {                          // Resume is the only state that will make Questor revert to combat mode                          State = PanicState.Resume;                          return;                      }                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: Entered a station' lower panic mode");                          State = PanicState.Panic;                      }                        // Once we have warped off 500km' assume we are "safer"                      if (State == PanicState.StartPanicking && Cache.Instance.DistanceFromMe(_lastNormalX' _lastNormalY' _lastNormalZ) > (int)Distance.PanicDistanceToConsiderSafelyWarpedOff)                      {                          Logging.Log("Panic: We've warped off");                          State = PanicState.Panicking;                      }                        // We leave the panicking state once we actually start warping off                      var station = Cache.Instance.Stations.FirstOrDefault();                      if (station != null)                      {                          if (Cache.Instance.InWarp)                              break;                            if (station.Distance > (int)Distance.WarptoDistance)                          {                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5)                              {                                  Logging.Log("Panic: Warping to [" + station.Name + "] which is [" + Math.Round(station.Distance / 1000' 0) + "k away]");                                  station.WarpTo();                                  _lastWarpTo = DateTime.Now;                              }                          }                          else if (DateTime.Now.Subtract(_lastDock).TotalSeconds > 5)                          {                              station.Dock();                              _lastDock = DateTime.Now;                          }                          break;                      }                        // What is this you say?  No star?                      if (Cache.Instance.Star == null)                          break;                        if (Cache.Instance.Star.Distance > (int)Distance.WeCanWarpToStarFromHere)                      {                          if (Cache.Instance.InWarp)                              break;                            if (Cache.Instance.TargetedBy.Where(t => t.IsWarpScramblingMe).Count() > 0)                          {                              Logging.Log("Panic: We are still warp scrambled!"); //This runs every 'tick' so we should see it every 1.5 seconds or so                              _lastWarpScrambled = DateTime.Now;                          }                          else                              if (DateTime.Now.Subtract(_lastWarpTo).TotalSeconds > 5 | DateTime.Now.Subtract(_lastWarpScrambled).TotalSeconds < 10) //this will effectively spam warpto as soon as you are free of warp disruption if you were warp disrupted in the past 10 seconds                          {                              Logging.Log("Panic: Warping to [" + Cache.Instance.Star.Name + "] which is [" + Math.Round(Cache.Instance.Star.Distance/1000' 0) + "k away]");                              Cache.Instance.Star.WarpTo();                              _lastWarpTo = DateTime.Now;                          }                                                }                      else                      {                          Logging.Log("Panic: At the star' lower panic mode");                          State = PanicState.Panic;                      }                      break;                    case PanicState.Panic:                      // Do not resume until you're no longer in a capsule                      if (Cache.Instance.DirectEve.ActiveShip.GroupId == (int)Group.Capsule)                          break;                        if (Cache.Instance.InStation)                      {                          Logging.Log("Panic: We're in a station' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        var isSafe = Cache.Instance.DirectEve.ActiveShip.CapacitorPercentage > Settings.Instance.SafeCapacitorPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ShieldPercentage > Settings.Instance.SafeShieldPct;                      isSafe &= Cache.Instance.DirectEve.ActiveShip.ArmorPercentage > Settings.Instance.SafeArmorPct;                      if (isSafe)                      {                          Logging.Log("Panic: We've recovered' resume mission");                          State = _delayedResume ? PanicState.DelayedResume : PanicState.Resume;                      }                        if (State == PanicState.DelayedResume)                      {                          Logging.Log("Panic: Delaying resume for " + _randomDelay + " seconds");                          _resumeTime = DateTime.Now.AddSeconds(_randomDelay);                      }                      break;                    case PanicState.DelayedResume:                      if (DateTime.Now > _resumeTime)                          State = PanicState.Resume;                      break;                    case PanicState.Resume:                      // Don't do anything here                      break;              }
Missing Default,Questor.Modules,UnloadLoot,C:\repos\Da-Teach_Questor\Questor.Modules\UnloadLoot.cs,ProcessState,The following switch statement is missing a default case: switch (State)              {                  case UnloadLootState.Idle:                  case UnloadLootState.Done:                      break;                    case UnloadLootState.Begin:                      if (cargo.Items.Count == 0)                          State = UnloadLootState.Done;                      Logging.Log("UnloadLoot: Opening station hangar");                      State = UnloadLootState.OpenItemHangar;                      break;                    case UnloadLootState.OpenItemHangar:                      // Is the hangar open?                      if (itemshangar.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenHangarFloor);                          break;                      }                        // Not ready yet                      if (!itemshangar.IsReady)                          break;                        Logging.Log("UnloadLoot: Opening ship's cargo");                      State = UnloadLootState.OpenShipsCargo;                      break;                    case UnloadLootState.OpenShipsCargo:                      // Is cargo open?                      if (cargo.Window == null)                      {                          // No' command it to open                          Cache.Instance.DirectEve.ExecuteCommand(DirectCmd.OpenCargoHoldOfActiveShip);                          break;                      }                        if (!cargo.IsReady)                          break;                        if (corpAmmoHangar != null || corpLootHangar != null)                      {                          //Logging.Log("UnloadLoot: Opening corporation hangar");                          State = UnloadLootState.OpenCorpHangar;                      }                      else                      {                          //Logging.Log("UnloadLoot: CommonMissionCompletionitems");                          State = UnloadLootState.MoveCommonMissionCompletionitems;                      }                      break;                    case UnloadLootState.OpenCorpHangar:                      // Is cargo open?                      var corpHangar = corpAmmoHangar ?? corpLootHangar;                      if (corpHangar != null)                      {                          if (corpHangar.Window == null)                          {                              // No' command it to open                              Logging.Log("UnloadLoot: Opening corporation hangar");                              Cache.Instance.DirectEve.OpenCorporationHangar();                              break;                          }                            if (!corpHangar.IsReady)                              break;                      }                        Logging.Log("UnloadLoot: Moving Common Mission Completion items");                      State = UnloadLootState.MoveCommonMissionCompletionitems;                      break;                                    case UnloadLootState.MoveCommonMissionCompletionitems:                      var CommonMissionCompletionItemHangar = itemshangar;                      //                      // how do we get IsMissionItem to work for us here? (see ItemCache)                      // Zbikoki's Hacker Card 28260' Reports 3814' Gate Key 2076' Militants 25373' Marines 3810' i.groupid == 314 (Misc Mission Items' mainly for storylines) and i.GroupId == 283 (Misc Mission Items' mainly for storylines)                      //                      var ItemsToMove = cargo.Items.Where(i => i.TypeId == 17192 || i.TypeId == 2076 || i.TypeId == 3814 || i.TypeId == 17206 || i.TypeId == 28260 || i.GroupId == 283 || i.GroupId == 314);                                            CommonMissionCompletionItemHangar.Add(ItemsToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Moving Common Mission Completion Items to Local hangar");                      State = UnloadLootState.MoveLoot;                      break;                    case UnloadLootState.MoveLoot:                      var lootHangar = corpLootHangar ?? lootContainer ?? itemshangar;                        var lootToMove = cargo.Items.Where(i => (i.TypeName ?? string.Empty).ToLower() != Cache.Instance.BringMissionItem && !Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId));                      LootValue = 0;                      foreach (var item in lootToMove)                      {                          if (!Cache.Instance.InvTypesById.ContainsKey(item.TypeId))                              continue;                            var invType = Cache.Instance.InvTypesById[item.TypeId];                          LootValue += (invType.MedianBuy ?? 0)*Math.Max(item.Quantity' 1);                      }                        // Move loot to the loot hangar                      lootHangar.Add(lootToMove);                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Loot was worth an estimated [" + LootValue.ToString("#'##0") + "] isk in buy-orders");                        //Move bookmarks to the bookmarks hangar                      if (!string.IsNullOrEmpty(Settings.Instance.BookmarkHangar) && Settings.Instance.CreateSalvageBookmarks == true)                      {                          Logging.Log("UnloadLoot: Creating salvage bookmarks in hangar");                          var bookmarks = Cache.Instance.BookmarksByLabel(Settings.Instance.BookmarkPrefix + " ");                          List<long> salvageBMs = new List<long>();                          foreach (DirectBookmark bookmark in bookmarks)                          {                              salvageBMs.Add((long)bookmark.BookmarkId);                              if (salvageBMs.Count == 5)                              {                                  itemshangar.AddBookmarks(salvageBMs);                                  salvageBMs.Clear();                              }                          }                          if (salvageBMs.Count > 0)                          {                              itemshangar.AddBookmarks(salvageBMs);                              salvageBMs.Clear();                          }                      }                        Logging.Log("UnloadLoot: Moving ammo");                      State = UnloadLootState.MoveAmmo;                      break;                    case UnloadLootState.MoveAmmo:                      // Wait 5 seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        var ammoHangar = corpAmmoHangar ?? itemshangar;                        // Move the mission item & ammo to the ammo hangar                      ammoHangar.Add(cargo.Items.Where(i => ((i.TypeName ?? string.Empty).ToLower() == Cache.Instance.BringMissionItem || Settings.Instance.Ammo.Any(a => a.TypeId == i.TypeId))));                      _lastAction = DateTime.Now;                        Logging.Log("UnloadLoot: Waiting for items to move");                      State = UnloadLootState.WaitForMove;                      break;                    case UnloadLootState.WaitForMove:                      if (cargo.Items.Count != 0)                      {                          _lastAction = DateTime.Now;                          break;                      }                        // Wait x seconds after moving                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 2)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          if (corpBookmarkHangar != null && Settings.Instance.CreateSalvageBookmarks)                          {                              Logging.Log("UnloadLoot: Moving salvage bookmarks to corp hangar");                              corpBookmarkHangar.Add(itemshangar.Items.Where(i => i.TypeId == 51));                          }                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Moving items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Stacking items");                          State = UnloadLootState.StackItemsHangar;                          break;                      }                      break;                    case UnloadLootState.StackItemsHangar:                      // Don't stack until 5 seconds after the cargo has cleared                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                          // Stack everything                      if(corpAmmoHangar == null || corpLootHangar == null || lootContainer == null) // Only stack if we moved something                      {                          itemshangar.StackAll();                          _lastAction = DateTime.Now;                      }                        State = UnloadLootState.StackItemsCorpAmmo;                      break;                    case UnloadLootState.StackItemsCorpAmmo:                      if (Settings.Instance.AmmoHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpAmmoHangar != null)                          {                              corpAmmoHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsCorpLoot;                      break;                    case UnloadLootState.StackItemsCorpLoot:                      if (Settings.Instance.LootHangar != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (corpLootHangar != null)                          {                              corpLootHangar.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.StackItemsLootContainer;                      break;                    case UnloadLootState.StackItemsLootContainer:                      if (Settings.Instance.LootContainer != string.Empty)                      {                          // Don't stack until 5 seconds after the cargo has cleared                          if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                              break;                            // Stack everything                          if (lootContainer != null)                          {                              lootContainer.StackAll();                              _lastAction = DateTime.Now;                          }                      }                      State = UnloadLootState.WaitForStacking;                      break;                    case UnloadLootState.WaitForStacking:                      // Wait 5 seconds after stacking                      if (DateTime.Now.Subtract(_lastAction).TotalSeconds < 5)                          break;                        if (Cache.Instance.DirectEve.GetLockedItems().Count == 0)                      {                          Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                        if (DateTime.Now.Subtract(_lastAction).TotalSeconds > 120)                      {                          Logging.Log("UnloadLoot: Stacking items timed out' clearing item locks");                          Cache.Instance.DirectEve.UnlockItems();                            Logging.Log("UnloadLoot: Done");                          State = UnloadLootState.Done;                          break;                      }                      break;              }
