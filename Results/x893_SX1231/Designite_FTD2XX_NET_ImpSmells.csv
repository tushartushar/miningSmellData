Implementation smell,Namespace,Class,File,Method,Description
Long Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The method has 104 lines of code.
Long Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The method has 100 lines of code.
Long Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The method has 110 lines of code.
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,Cyclomatic complexity of the method is 8
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,Cyclomatic complexity of the method is 8
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,Cyclomatic complexity of the method is 8
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,Cyclomatic complexity of the method is 8
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,Cyclomatic complexity of the method is 21
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,Cyclomatic complexity of the method is 10
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,Cyclomatic complexity of the method is 9
Complex Method,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ErrorHandler,Cyclomatic complexity of the method is 45
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetNumberOfDevices,The length of the statement  "		tFT_CreateDeviceInfoList FT_CreateDeviceInfoList = (tFT_CreateDeviceInfoList)Marshal.GetDelegateForFunctionPointer (pFT_CreateDeviceInfoList' typeof(tFT_CreateDeviceInfoList)); " is 176.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceList,The length of the statement  "		tFT_CreateDeviceInfoList FT_CreateDeviceInfoList = (tFT_CreateDeviceInfoList)Marshal.GetDelegateForFunctionPointer (pFT_CreateDeviceInfoList' typeof(tFT_CreateDeviceInfoList)); " is 176.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceList,The length of the statement  "		tFT_GetDeviceInfoDetail FT_GetDeviceInfoDetail = (tFT_GetDeviceInfoDetail)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfoDetail' typeof(tFT_GetDeviceInfoDetail)); " is 171.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceList,The length of the statement  "				ftStatus = FT_GetDeviceInfoDetail (i' ref devicelist [i].Flags' ref devicelist [i].Type' ref devicelist [i].ID' ref devicelist [i].LocId' sernum' desc' ref devicelist [i].ftHandle); " is 181.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The length of the statement  "	if ((pFT_Open != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) { " is 151.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The length of the statement  "		tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The length of the statement  "		tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The length of the statement  "		tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The length of the statement  "	if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) { " is 153.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The length of the statement  "		tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The length of the statement  "		tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The length of the statement  "		tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The length of the statement  "	if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) { " is 153.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The length of the statement  "		tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The length of the statement  "		tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The length of the statement  "		tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The length of the statement  "	if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) { " is 153.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The length of the statement  "		tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The length of the statement  "		tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The length of the statement  "		tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ResetDevice,The length of the statement  "		tFT_ResetDevice FT_ResetDevice = (tFT_ResetDevice)Marshal.GetDelegateForFunctionPointer (pFT_ResetDevice' typeof(tFT_ResetDevice)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetEventNotification,The length of the statement  "		tFT_SetEventNotification FT_SetEventNotification = (tFT_SetEventNotification)Marshal.GetDelegateForFunctionPointer (pFT_SetEventNotification' typeof(tFT_SetEventNotification)); " is 176.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,StopInTask,The length of the statement  "		tFT_StopInTask FT_StopInTask = (tFT_StopInTask)Marshal.GetDelegateForFunctionPointer (pFT_StopInTask' typeof(tFT_StopInTask)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,RestartInTask,The length of the statement  "		tFT_RestartInTask FT_RestartInTask = (tFT_RestartInTask)Marshal.GetDelegateForFunctionPointer (pFT_RestartInTask' typeof(tFT_RestartInTask)); " is 141.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ResetPort,The length of the statement  "		tFT_ResetPort FT_ResetPort = (tFT_ResetPort)Marshal.GetDelegateForFunctionPointer (pFT_ResetPort' typeof(tFT_ResetPort)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,CyclePort,The length of the statement  "		tFT_CyclePort FT_CyclePort = (tFT_CyclePort)Marshal.GetDelegateForFunctionPointer (pFT_CyclePort' typeof(tFT_CyclePort)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "		tFT_SetBitMode FT_SetBitMode = (tFT_SetBitMode)Marshal.GetDelegateForFunctionPointer (pFT_SetBitMode' typeof(tFT_SetBitMode)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "				if ((BitMode & (FT_BIT_MODES.FT_BIT_MODE_ASYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_MPSSE | FT_BIT_MODES.FT_BIT_MODE_SYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_MCU_HOST | FT_BIT_MODES.FT_BIT_MODE_FAST_SERIAL)) == 0) { " is 212.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "				if ((BitMode & (FT_BIT_MODES.FT_BIT_MODE_ASYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_SYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_CBUS_BITBANG)) == 0) { " is 144.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "				if ((BitMode & (FT_BIT_MODES.FT_BIT_MODE_ASYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_MPSSE | FT_BIT_MODES.FT_BIT_MODE_SYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_MCU_HOST | FT_BIT_MODES.FT_BIT_MODE_FAST_SERIAL | FT_BIT_MODES.FT_BIT_MODE_SYNC_FIFO)) == 0) { " is 249.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "				if (((BitMode == FT_BIT_MODES.FT_BIT_MODE_MCU_HOST) | (BitMode == FT_BIT_MODES.FT_BIT_MODE_SYNC_FIFO)) & (InterfaceIdentifier != "A")) { " is 136.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBitMode,The length of the statement  "				if ((BitMode & (FT_BIT_MODES.FT_BIT_MODE_ASYNC_BITBANG | FT_BIT_MODES.FT_BIT_MODE_MPSSE | FT_BIT_MODES.FT_BIT_MODE_SYNC_BITBANG)) == 0) { " is 137.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetPinStates,The length of the statement  "		tFT_GetBitMode FT_GetBitMode = (tFT_GetBitMode)Marshal.GetDelegateForFunctionPointer (pFT_GetBitMode' typeof(tFT_GetBitMode)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The length of the statement  "		tFT_EEPROM_Read FT_EEPROM_Read = (tFT_EEPROM_Read)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Read' typeof(tFT_EEPROM_Read)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The length of the statement  "			ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The length of the statement  "		tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The length of the statement  "		tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The length of the statement  "			ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber); " is 124.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,EEReadUserArea,The length of the statement  "		tFT_EE_UASize FT_EE_UASize = (tFT_EE_UASize)Marshal.GetDelegateForFunctionPointer (pFT_EE_UASize' typeof(tFT_EE_UASize)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,EEReadUserArea,The length of the statement  "		tFT_EE_UARead FT_EE_UARead = (tFT_EE_UARead)Marshal.GetDelegateForFunctionPointer (pFT_EE_UARead' typeof(tFT_EE_UARead)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,EEWriteUserArea,The length of the statement  "		tFT_EE_UASize FT_EE_UASize = (tFT_EE_UASize)Marshal.GetDelegateForFunctionPointer (pFT_EE_UASize' typeof(tFT_EE_UASize)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,EEWriteUserArea,The length of the statement  "		tFT_EE_UAWrite FT_EE_UAWrite = (tFT_EE_UAWrite)Marshal.GetDelegateForFunctionPointer (pFT_EE_UAWrite' typeof(tFT_EE_UAWrite)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceType,The length of the statement  "		tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo)); " is 141.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceID,The length of the statement  "		tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo)); " is 141.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDescription,The length of the statement  "		tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo)); " is 141.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetSerialNumber,The length of the statement  "		tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo)); " is 141.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetRxBytesAvailable,The length of the statement  "		tFT_GetQueueStatus FT_GetQueueStatus = (tFT_GetQueueStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetQueueStatus' typeof(tFT_GetQueueStatus)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetTxBytesWaiting,The length of the statement  "		tFT_GetStatus FT_GetStatus = (tFT_GetStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetStatus' typeof(tFT_GetStatus)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetEventType,The length of the statement  "		tFT_GetStatus FT_GetStatus = (tFT_GetStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetStatus' typeof(tFT_GetStatus)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetModemStatus,The length of the statement  "		tFT_GetModemStatus FT_GetModemStatus = (tFT_GetModemStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetModemStatus' typeof(tFT_GetModemStatus)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetLineStatus,The length of the statement  "		tFT_GetModemStatus FT_GetModemStatus = (tFT_GetModemStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetModemStatus' typeof(tFT_GetModemStatus)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBaudRate,The length of the statement  "		tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetDataCharacteristics,The length of the statement  "		tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetFlowControl,The length of the statement  "		tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl)); " is 146.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetTimeouts,The length of the statement  "		tFT_SetTimeouts FT_SetTimeouts = (tFT_SetTimeouts)Marshal.GetDelegateForFunctionPointer (pFT_SetTimeouts' typeof(tFT_SetTimeouts)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBreak,The length of the statement  "		tFT_SetBreakOn FT_SetBreakOn = (tFT_SetBreakOn)Marshal.GetDelegateForFunctionPointer (pFT_SetBreakOn' typeof(tFT_SetBreakOn)); " is 126.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetBreak,The length of the statement  "		tFT_SetBreakOff FT_SetBreakOff = (tFT_SetBreakOff)Marshal.GetDelegateForFunctionPointer (pFT_SetBreakOff' typeof(tFT_SetBreakOff)); " is 131.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetResetPipeRetryCount,The length of the statement  "		tFT_SetResetPipeRetryCount FT_SetResetPipeRetryCount = (tFT_SetResetPipeRetryCount)Marshal.GetDelegateForFunctionPointer (pFT_SetResetPipeRetryCount' typeof(tFT_SetResetPipeRetryCount)); " is 186.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDriverVersion,The length of the statement  "		tFT_GetDriverVersion FT_GetDriverVersion = (tFT_GetDriverVersion)Marshal.GetDelegateForFunctionPointer (pFT_GetDriverVersion' typeof(tFT_GetDriverVersion)); " is 156.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetLibraryVersion,The length of the statement  "		tFT_GetLibraryVersion FT_GetLibraryVersion = (tFT_GetLibraryVersion)Marshal.GetDelegateForFunctionPointer (pFT_GetLibraryVersion' typeof(tFT_GetLibraryVersion)); " is 161.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetDeadmanTimeout,The length of the statement  "		tFT_SetDeadmanTimeout FT_SetDeadmanTimeout = (tFT_SetDeadmanTimeout)Marshal.GetDelegateForFunctionPointer (pFT_SetDeadmanTimeout' typeof(tFT_SetDeadmanTimeout)); " is 161.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The length of the statement  "		tFT_SetLatencyTimer FT_SetLatencyTimer = (tFT_SetLatencyTimer)Marshal.GetDelegateForFunctionPointer (pFT_SetLatencyTimer' typeof(tFT_SetLatencyTimer)); " is 151.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetLatency,The length of the statement  "		tFT_GetLatencyTimer FT_GetLatencyTimer = (tFT_GetLatencyTimer)Marshal.GetDelegateForFunctionPointer (pFT_GetLatencyTimer' typeof(tFT_GetLatencyTimer)); " is 151.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,InTransferSize,The length of the statement  "		tFT_SetUSBParameters FT_SetUSBParameters = (tFT_SetUSBParameters)Marshal.GetDelegateForFunctionPointer (pFT_SetUSBParameters' typeof(tFT_SetUSBParameters)); " is 156.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetCharacters,The length of the statement  "			ftStatus = FT_SetChars (ftHandle' EventChar' Convert.ToByte (EventCharEnable)' ErrorChar' Convert.ToByte (ErrorCharEnable)); " is 124.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,EEUserAreaSize,The length of the statement  "		tFT_EE_UASize FT_EE_UASize = (tFT_EE_UASize)Marshal.GetDelegateForFunctionPointer (pFT_EE_UASize' typeof(tFT_EE_UASize)); " is 121.
Long Statement,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetCOMPort,The length of the statement  "		tFT_GetComPortNumber FT_GetComPortNumber = (tFT_GetComPortNumber)Marshal.GetDelegateForFunctionPointer (pFT_GetComPortNumber' typeof(tFT_GetComPortNumber)); " is 156.
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceList,The following statement contains a magic number: if ((pFT_CreateDeviceInfoList != IntPtr.Zero) & (pFT_GetDeviceInfoDetail != IntPtr.Zero)) {  	UInt32 devcount = 0;  	tFT_CreateDeviceInfoList FT_CreateDeviceInfoList = (tFT_CreateDeviceInfoList)Marshal.GetDelegateForFunctionPointer (pFT_CreateDeviceInfoList' typeof(tFT_CreateDeviceInfoList));  	tFT_GetDeviceInfoDetail FT_GetDeviceInfoDetail = (tFT_GetDeviceInfoDetail)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfoDetail' typeof(tFT_GetDeviceInfoDetail));  	// Call FT_CreateDeviceInfoList  	ftStatus = FT_CreateDeviceInfoList (ref devcount);  	// Allocate the required storage for our list  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (devcount > 0) {  		// Check the size of the buffer passed in is big enough  		if (devicelist.Length < devcount) {  			// Buffer not big enough  			ftErrorCondition = FT_ERROR.FT_BUFFER_SIZE;  			// Throw exception  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Instantiate the array elements as FT_DEVICE_INFO_NODE  		for (UInt32 i = 0; i < devcount; i++) {  			devicelist [i] = new FT_DEVICE_INFO_NODE ();  			// Call FT_GetDeviceInfoDetail  			ftStatus = FT_GetDeviceInfoDetail (i' ref devicelist [i].Flags' ref devicelist [i].Type' ref devicelist [i].ID' ref devicelist [i].LocId' sernum' desc' ref devicelist [i].ftHandle);  			// Convert byte arrays to strings  			devicelist [i].SerialNumber = Encoding.ASCII.GetString (sernum);  			devicelist [i].Description = Encoding.ASCII.GetString (desc);  			// Trim strings to first occurrence of a null terminator character  			devicelist [i].SerialNumber = devicelist [i].SerialNumber.Substring (0' devicelist [i].SerialNumber.IndexOf ("\0"));  			devicelist [i].Description = devicelist [i].Description.Substring (0' devicelist [i].Description.IndexOf ("\0"));  		}  	}  }  else {  	if (pFT_CreateDeviceInfoList == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_CreateDeviceInfoList.");  	}  	if (pFT_GetDeviceInfoDetail == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfoListDetail.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceList,The following statement contains a magic number: if ((pFT_CreateDeviceInfoList != IntPtr.Zero) & (pFT_GetDeviceInfoDetail != IntPtr.Zero)) {  	UInt32 devcount = 0;  	tFT_CreateDeviceInfoList FT_CreateDeviceInfoList = (tFT_CreateDeviceInfoList)Marshal.GetDelegateForFunctionPointer (pFT_CreateDeviceInfoList' typeof(tFT_CreateDeviceInfoList));  	tFT_GetDeviceInfoDetail FT_GetDeviceInfoDetail = (tFT_GetDeviceInfoDetail)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfoDetail' typeof(tFT_GetDeviceInfoDetail));  	// Call FT_CreateDeviceInfoList  	ftStatus = FT_CreateDeviceInfoList (ref devcount);  	// Allocate the required storage for our list  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (devcount > 0) {  		// Check the size of the buffer passed in is big enough  		if (devicelist.Length < devcount) {  			// Buffer not big enough  			ftErrorCondition = FT_ERROR.FT_BUFFER_SIZE;  			// Throw exception  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Instantiate the array elements as FT_DEVICE_INFO_NODE  		for (UInt32 i = 0; i < devcount; i++) {  			devicelist [i] = new FT_DEVICE_INFO_NODE ();  			// Call FT_GetDeviceInfoDetail  			ftStatus = FT_GetDeviceInfoDetail (i' ref devicelist [i].Flags' ref devicelist [i].Type' ref devicelist [i].ID' ref devicelist [i].LocId' sernum' desc' ref devicelist [i].ftHandle);  			// Convert byte arrays to strings  			devicelist [i].SerialNumber = Encoding.ASCII.GetString (sernum);  			devicelist [i].Description = Encoding.ASCII.GetString (desc);  			// Trim strings to first occurrence of a null terminator character  			devicelist [i].SerialNumber = devicelist [i].SerialNumber.Substring (0' devicelist [i].SerialNumber.IndexOf ("\0"));  			devicelist [i].Description = devicelist [i].Description.Substring (0' devicelist [i].Description.IndexOf ("\0"));  		}  	}  }  else {  	if (pFT_CreateDeviceInfoList == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_CreateDeviceInfoList.");  	}  	if (pFT_GetDeviceInfoDetail == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfoListDetail.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The following statement contains a magic number: if ((pFT_Open != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) {  	tFT_Open FT_Open = (tFT_Open)Marshal.GetDelegateForFunctionPointer (pFT_Open' typeof(tFT_Open));  	tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics));  	tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl));  	tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate));  	// Call FT_Open  	ftStatus = FT_Open (index' ref ftHandle);  	// Appears that the handle value can be non-NULL on a fail' so set it explicitly  	if (ftStatus != FT_STATUS.FT_OK)  		ftHandle = IntPtr.Zero;  	if (ftHandle != IntPtr.Zero) {  		// Initialise port data characteristics  		byte WordLength = FT_DATA_BITS.FT_BITS_8;  		byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  		byte Parity = FT_PARITY.FT_PARITY_NONE;  		ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  		// Initialise to no flow control  		UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  		byte Xon = 0x11;  		byte Xoff = 0x13;  		ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  		// Initialise Baud rate  		UInt32 BaudRate = 9600;  		ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  	}  }  else {  	if (pFT_Open == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_Open.");  	}  	if (pFT_SetDataCharacteristics == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetDataCharacteristics.");  	}  	if (pFT_SetFlowControl == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetFlowControl.");  	}  	if (pFT_SetBaudRate == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetBaudRate.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByIndex,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	// Initialise port data characteristics  	byte WordLength = FT_DATA_BITS.FT_BITS_8;  	byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  	byte Parity = FT_PARITY.FT_PARITY_NONE;  	ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  	// Initialise to no flow control  	UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  	byte Xon = 0x11;  	byte Xoff = 0x13;  	ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  	// Initialise Baud rate  	UInt32 BaudRate = 9600;  	ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The following statement contains a magic number: if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) {  	tFT_OpenEx FT_OpenEx = (tFT_OpenEx)Marshal.GetDelegateForFunctionPointer (pFT_OpenEx' typeof(tFT_OpenEx));  	tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics));  	tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl));  	tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate));  	// Call FT_OpenEx  	ftStatus = FT_OpenEx (serialnumber' FT_OPEN_BY_SERIAL_NUMBER' ref ftHandle);  	// Appears that the handle value can be non-NULL on a fail' so set it explicitly  	if (ftStatus != FT_STATUS.FT_OK)  		ftHandle = IntPtr.Zero;  	if (ftHandle != IntPtr.Zero) {  		// Initialise port data characteristics  		byte WordLength = FT_DATA_BITS.FT_BITS_8;  		byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  		byte Parity = FT_PARITY.FT_PARITY_NONE;  		ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  		// Initialise to no flow control  		UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  		byte Xon = 0x11;  		byte Xoff = 0x13;  		ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  		// Initialise Baud rate  		UInt32 BaudRate = 9600;  		ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  	}  }  else {  	if (pFT_OpenEx == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_OpenEx.");  	}  	if (pFT_SetDataCharacteristics == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetDataCharacteristics.");  	}  	if (pFT_SetFlowControl == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetFlowControl.");  	}  	if (pFT_SetBaudRate == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetBaudRate.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenBySerialNumber,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	// Initialise port data characteristics  	byte WordLength = FT_DATA_BITS.FT_BITS_8;  	byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  	byte Parity = FT_PARITY.FT_PARITY_NONE;  	ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  	// Initialise to no flow control  	UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  	byte Xon = 0x11;  	byte Xoff = 0x13;  	ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  	// Initialise Baud rate  	UInt32 BaudRate = 9600;  	ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The following statement contains a magic number: if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) {  	tFT_OpenEx FT_OpenEx = (tFT_OpenEx)Marshal.GetDelegateForFunctionPointer (pFT_OpenEx' typeof(tFT_OpenEx));  	tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics));  	tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl));  	tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate));  	// Call FT_OpenEx  	ftStatus = FT_OpenEx (description' FT_OPEN_BY_DESCRIPTION' ref ftHandle);  	// Appears that the handle value can be non-NULL on a fail' so set it explicitly  	if (ftStatus != FT_STATUS.FT_OK)  		ftHandle = IntPtr.Zero;  	if (ftHandle != IntPtr.Zero) {  		// Initialise port data characteristics  		byte WordLength = FT_DATA_BITS.FT_BITS_8;  		byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  		byte Parity = FT_PARITY.FT_PARITY_NONE;  		ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  		// Initialise to no flow control  		UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  		byte Xon = 0x11;  		byte Xoff = 0x13;  		ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  		// Initialise Baud rate  		UInt32 BaudRate = 9600;  		ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  	}  }  else {  	if (pFT_OpenEx == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_OpenEx.");  	}  	if (pFT_SetDataCharacteristics == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetDataCharacteristics.");  	}  	if (pFT_SetFlowControl == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetFlowControl.");  	}  	if (pFT_SetBaudRate == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetBaudRate.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByDescription,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	// Initialise port data characteristics  	byte WordLength = FT_DATA_BITS.FT_BITS_8;  	byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  	byte Parity = FT_PARITY.FT_PARITY_NONE;  	ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  	// Initialise to no flow control  	UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  	byte Xon = 0x11;  	byte Xoff = 0x13;  	ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  	// Initialise Baud rate  	UInt32 BaudRate = 9600;  	ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The following statement contains a magic number: if ((pFT_OpenEx != IntPtr.Zero) & (pFT_SetDataCharacteristics != IntPtr.Zero) & (pFT_SetFlowControl != IntPtr.Zero) & (pFT_SetBaudRate != IntPtr.Zero)) {  	tFT_OpenExLoc FT_OpenEx = (tFT_OpenExLoc)Marshal.GetDelegateForFunctionPointer (pFT_OpenEx' typeof(tFT_OpenExLoc));  	tFT_SetDataCharacteristics FT_SetDataCharacteristics = (tFT_SetDataCharacteristics)Marshal.GetDelegateForFunctionPointer (pFT_SetDataCharacteristics' typeof(tFT_SetDataCharacteristics));  	tFT_SetFlowControl FT_SetFlowControl = (tFT_SetFlowControl)Marshal.GetDelegateForFunctionPointer (pFT_SetFlowControl' typeof(tFT_SetFlowControl));  	tFT_SetBaudRate FT_SetBaudRate = (tFT_SetBaudRate)Marshal.GetDelegateForFunctionPointer (pFT_SetBaudRate' typeof(tFT_SetBaudRate));  	// Call FT_OpenEx  	ftStatus = FT_OpenEx (location' FT_OPEN_BY_LOCATION' ref ftHandle);  	// Appears that the handle value can be non-NULL on a fail' so set it explicitly  	if (ftStatus != FT_STATUS.FT_OK)  		ftHandle = IntPtr.Zero;  	if (ftHandle != IntPtr.Zero) {  		// Initialise port data characteristics  		byte WordLength = FT_DATA_BITS.FT_BITS_8;  		byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  		byte Parity = FT_PARITY.FT_PARITY_NONE;  		ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  		// Initialise to no flow control  		UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  		byte Xon = 0x11;  		byte Xoff = 0x13;  		ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  		// Initialise Baud rate  		UInt32 BaudRate = 9600;  		ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  	}  }  else {  	if (pFT_OpenEx == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_OpenEx.");  	}  	if (pFT_SetDataCharacteristics == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetDataCharacteristics.");  	}  	if (pFT_SetFlowControl == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetFlowControl.");  	}  	if (pFT_SetBaudRate == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetBaudRate.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,OpenByLocation,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	// Initialise port data characteristics  	byte WordLength = FT_DATA_BITS.FT_BITS_8;  	byte StopBits = FT_STOP_BITS.FT_STOP_BITS_1;  	byte Parity = FT_PARITY.FT_PARITY_NONE;  	ftStatus = FT_SetDataCharacteristics (ftHandle' WordLength' StopBits' Parity);  	// Initialise to no flow control  	UInt16 FlowControl = FT_FLOW_CONTROL.FT_FLOW_NONE;  	byte Xon = 0x11;  	byte Xoff = 0x13;  	ftStatus = FT_SetFlowControl (ftHandle' FlowControl' Xon' Xoff);  	// Initialise Baud rate  	UInt32 BaudRate = 9600;  	ftStatus = FT_SetBaudRate (ftHandle' BaudRate);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232b.VendorID = eedata.VendorID;  		ee232b.ProductID = eedata.ProductID;  		ee232b.MaxPower = eedata.MaxPower;  		ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// B specific fields  		ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  		ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  		ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  		ee232b.USBVersion = eedata.USBVersion;  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232b.VendorID = eedata.VendorID;  		ee232b.ProductID = eedata.ProductID;  		ee232b.MaxPower = eedata.MaxPower;  		ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// B specific fields  		ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  		ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  		ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  		ee232b.USBVersion = eedata.USBVersion;  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232b.VendorID = eedata.VendorID;  		ee232b.ProductID = eedata.ProductID;  		ee232b.MaxPower = eedata.MaxPower;  		ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// B specific fields  		ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  		ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  		ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  		ee232b.USBVersion = eedata.USBVersion;  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232b.VendorID = eedata.VendorID;  		ee232b.ProductID = eedata.ProductID;  		ee232b.MaxPower = eedata.MaxPower;  		ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// B specific fields  		ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  		ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  		ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  		ee232b.USBVersion = eedata.USBVersion;  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232b.VendorID = eedata.VendorID;  		ee232b.ProductID = eedata.ProductID;  		ee232b.MaxPower = eedata.MaxPower;  		ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// B specific fields  		ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  		ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  		ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  		ee232b.USBVersion = eedata.USBVersion;  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232b.VendorID = eedata.VendorID;  	ee232b.ProductID = eedata.ProductID;  	ee232b.MaxPower = eedata.MaxPower;  	ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// B specific fields  	ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  	ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  	ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  	ee232b.USBVersion = eedata.USBVersion;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232b.VendorID = eedata.VendorID;  	ee232b.ProductID = eedata.ProductID;  	ee232b.MaxPower = eedata.MaxPower;  	ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// B specific fields  	ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  	ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  	ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  	ee232b.USBVersion = eedata.USBVersion;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232b.VendorID = eedata.VendorID;  	ee232b.ProductID = eedata.ProductID;  	ee232b.MaxPower = eedata.MaxPower;  	ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// B specific fields  	ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  	ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  	ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  	ee232b.USBVersion = eedata.USBVersion;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232b.VendorID = eedata.VendorID;  	ee232b.ProductID = eedata.ProductID;  	ee232b.MaxPower = eedata.MaxPower;  	ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// B specific fields  	ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  	ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  	ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  	ee232b.USBVersion = eedata.USBVersion;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232b.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232b.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232b.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232b.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232b.VendorID = eedata.VendorID;  	ee232b.ProductID = eedata.ProductID;  	ee232b.MaxPower = eedata.MaxPower;  	ee232b.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232b.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// B specific fields  	ee232b.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable);  	ee232b.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable);  	ee232b.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable);  	ee232b.USBVersion = eedata.USBVersion;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232BEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232.VendorID = eedata.VendorID;  		ee2232.ProductID = eedata.ProductID;  		ee2232.MaxPower = eedata.MaxPower;  		ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232 specific fields  		ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  		ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  		ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  		ee2232.USBVersion = eedata.USBVersion5;  		ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  		ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  		ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  		ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  		ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  		ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  		ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  		ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  		ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  		ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232.VendorID = eedata.VendorID;  		ee2232.ProductID = eedata.ProductID;  		ee2232.MaxPower = eedata.MaxPower;  		ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232 specific fields  		ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  		ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  		ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  		ee2232.USBVersion = eedata.USBVersion5;  		ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  		ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  		ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  		ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  		ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  		ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  		ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  		ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  		ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  		ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232.VendorID = eedata.VendorID;  		ee2232.ProductID = eedata.ProductID;  		ee2232.MaxPower = eedata.MaxPower;  		ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232 specific fields  		ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  		ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  		ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  		ee2232.USBVersion = eedata.USBVersion5;  		ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  		ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  		ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  		ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  		ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  		ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  		ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  		ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  		ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  		ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232.VendorID = eedata.VendorID;  		ee2232.ProductID = eedata.ProductID;  		ee2232.MaxPower = eedata.MaxPower;  		ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232 specific fields  		ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  		ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  		ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  		ee2232.USBVersion = eedata.USBVersion5;  		ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  		ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  		ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  		ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  		ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  		ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  		ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  		ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  		ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  		ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232.VendorID = eedata.VendorID;  		ee2232.ProductID = eedata.ProductID;  		ee2232.MaxPower = eedata.MaxPower;  		ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232 specific fields  		ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  		ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  		ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  		ee2232.USBVersion = eedata.USBVersion5;  		ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  		ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  		ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  		ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  		ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  		ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  		ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  		ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  		ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  		ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232.VendorID = eedata.VendorID;  	ee2232.ProductID = eedata.ProductID;  	ee2232.MaxPower = eedata.MaxPower;  	ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232 specific fields  	ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  	ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  	ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  	ee2232.USBVersion = eedata.USBVersion5;  	ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  	ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  	ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  	ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  	ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  	ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  	ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  	ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  	ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  	ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232.VendorID = eedata.VendorID;  	ee2232.ProductID = eedata.ProductID;  	ee2232.MaxPower = eedata.MaxPower;  	ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232 specific fields  	ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  	ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  	ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  	ee2232.USBVersion = eedata.USBVersion5;  	ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  	ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  	ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  	ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  	ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  	ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  	ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  	ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  	ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  	ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232.VendorID = eedata.VendorID;  	ee2232.ProductID = eedata.ProductID;  	ee2232.MaxPower = eedata.MaxPower;  	ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232 specific fields  	ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  	ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  	ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  	ee2232.USBVersion = eedata.USBVersion5;  	ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  	ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  	ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  	ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  	ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  	ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  	ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  	ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  	ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  	ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232.VendorID = eedata.VendorID;  	ee2232.ProductID = eedata.ProductID;  	ee2232.MaxPower = eedata.MaxPower;  	ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232 specific fields  	ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  	ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  	ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  	ee2232.USBVersion = eedata.USBVersion5;  	ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  	ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  	ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  	ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  	ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  	ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  	ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  	ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  	ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  	ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232.VendorID = eedata.VendorID;  	ee2232.ProductID = eedata.ProductID;  	ee2232.MaxPower = eedata.MaxPower;  	ee2232.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232 specific fields  	ee2232.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable5);  	ee2232.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable5);  	ee2232.USBVersionEnable = Convert.ToBoolean (eedata.USBVersionEnable5);  	ee2232.USBVersion = eedata.USBVersion5;  	ee2232.AIsHighCurrent = Convert.ToBoolean (eedata.AIsHighCurrent);  	ee2232.BIsHighCurrent = Convert.ToBoolean (eedata.BIsHighCurrent);  	ee2232.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo);  	ee2232.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar);  	ee2232.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer);  	ee2232.AIsVCP = Convert.ToBoolean (eedata.AIsVCP);  	ee2232.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo);  	ee2232.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar);  	ee2232.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer);  	ee2232.BIsVCP = Convert.ToBoolean (eedata.BIsVCP);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232EEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232r.VendorID = eedata.VendorID;  		ee232r.ProductID = eedata.ProductID;  		ee232r.MaxPower = eedata.MaxPower;  		ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232R specific fields  		ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  		ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  		ee232r.EndpointSize = eedata.EndpointSize;  		ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  		ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  		ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  		ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  		ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  		ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  		ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  		ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  		ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  		ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  		ee232r.Cbus0 = eedata.Cbus0;  		ee232r.Cbus1 = eedata.Cbus1;  		ee232r.Cbus2 = eedata.Cbus2;  		ee232r.Cbus3 = eedata.Cbus3;  		ee232r.Cbus4 = eedata.Cbus4;  		ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232r.VendorID = eedata.VendorID;  		ee232r.ProductID = eedata.ProductID;  		ee232r.MaxPower = eedata.MaxPower;  		ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232R specific fields  		ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  		ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  		ee232r.EndpointSize = eedata.EndpointSize;  		ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  		ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  		ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  		ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  		ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  		ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  		ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  		ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  		ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  		ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  		ee232r.Cbus0 = eedata.Cbus0;  		ee232r.Cbus1 = eedata.Cbus1;  		ee232r.Cbus2 = eedata.Cbus2;  		ee232r.Cbus3 = eedata.Cbus3;  		ee232r.Cbus4 = eedata.Cbus4;  		ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232r.VendorID = eedata.VendorID;  		ee232r.ProductID = eedata.ProductID;  		ee232r.MaxPower = eedata.MaxPower;  		ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232R specific fields  		ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  		ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  		ee232r.EndpointSize = eedata.EndpointSize;  		ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  		ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  		ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  		ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  		ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  		ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  		ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  		ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  		ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  		ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  		ee232r.Cbus0 = eedata.Cbus0;  		ee232r.Cbus1 = eedata.Cbus1;  		ee232r.Cbus2 = eedata.Cbus2;  		ee232r.Cbus3 = eedata.Cbus3;  		ee232r.Cbus4 = eedata.Cbus4;  		ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232r.VendorID = eedata.VendorID;  		ee232r.ProductID = eedata.ProductID;  		ee232r.MaxPower = eedata.MaxPower;  		ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232R specific fields  		ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  		ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  		ee232r.EndpointSize = eedata.EndpointSize;  		ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  		ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  		ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  		ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  		ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  		ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  		ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  		ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  		ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  		ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  		ee232r.Cbus0 = eedata.Cbus0;  		ee232r.Cbus1 = eedata.Cbus1;  		ee232r.Cbus2 = eedata.Cbus2;  		ee232r.Cbus3 = eedata.Cbus3;  		ee232r.Cbus4 = eedata.Cbus4;  		ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232r.VendorID = eedata.VendorID;  		ee232r.ProductID = eedata.ProductID;  		ee232r.MaxPower = eedata.MaxPower;  		ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232R specific fields  		ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  		ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  		ee232r.EndpointSize = eedata.EndpointSize;  		ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  		ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  		ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  		ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  		ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  		ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  		ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  		ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  		ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  		ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  		ee232r.Cbus0 = eedata.Cbus0;  		ee232r.Cbus1 = eedata.Cbus1;  		ee232r.Cbus2 = eedata.Cbus2;  		ee232r.Cbus3 = eedata.Cbus3;  		ee232r.Cbus4 = eedata.Cbus4;  		ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232r.VendorID = eedata.VendorID;  	ee232r.ProductID = eedata.ProductID;  	ee232r.MaxPower = eedata.MaxPower;  	ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232R specific fields  	ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  	ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  	ee232r.EndpointSize = eedata.EndpointSize;  	ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  	ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  	ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  	ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  	ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  	ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  	ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  	ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  	ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  	ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  	ee232r.Cbus0 = eedata.Cbus0;  	ee232r.Cbus1 = eedata.Cbus1;  	ee232r.Cbus2 = eedata.Cbus2;  	ee232r.Cbus3 = eedata.Cbus3;  	ee232r.Cbus4 = eedata.Cbus4;  	ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232r.VendorID = eedata.VendorID;  	ee232r.ProductID = eedata.ProductID;  	ee232r.MaxPower = eedata.MaxPower;  	ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232R specific fields  	ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  	ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  	ee232r.EndpointSize = eedata.EndpointSize;  	ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  	ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  	ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  	ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  	ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  	ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  	ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  	ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  	ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  	ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  	ee232r.Cbus0 = eedata.Cbus0;  	ee232r.Cbus1 = eedata.Cbus1;  	ee232r.Cbus2 = eedata.Cbus2;  	ee232r.Cbus3 = eedata.Cbus3;  	ee232r.Cbus4 = eedata.Cbus4;  	ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232r.VendorID = eedata.VendorID;  	ee232r.ProductID = eedata.ProductID;  	ee232r.MaxPower = eedata.MaxPower;  	ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232R specific fields  	ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  	ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  	ee232r.EndpointSize = eedata.EndpointSize;  	ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  	ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  	ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  	ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  	ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  	ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  	ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  	ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  	ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  	ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  	ee232r.Cbus0 = eedata.Cbus0;  	ee232r.Cbus1 = eedata.Cbus1;  	ee232r.Cbus2 = eedata.Cbus2;  	ee232r.Cbus3 = eedata.Cbus3;  	ee232r.Cbus4 = eedata.Cbus4;  	ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232r.VendorID = eedata.VendorID;  	ee232r.ProductID = eedata.ProductID;  	ee232r.MaxPower = eedata.MaxPower;  	ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232R specific fields  	ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  	ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  	ee232r.EndpointSize = eedata.EndpointSize;  	ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  	ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  	ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  	ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  	ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  	ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  	ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  	ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  	ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  	ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  	ee232r.Cbus0 = eedata.Cbus0;  	ee232r.Cbus1 = eedata.Cbus1;  	ee232r.Cbus2 = eedata.Cbus2;  	ee232r.Cbus3 = eedata.Cbus3;  	ee232r.Cbus4 = eedata.Cbus4;  	ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232r.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232r.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232r.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232r.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232r.VendorID = eedata.VendorID;  	ee232r.ProductID = eedata.ProductID;  	ee232r.MaxPower = eedata.MaxPower;  	ee232r.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232r.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232R specific fields  	ee232r.UseExtOsc = Convert.ToBoolean (eedata.UseExtOsc);  	ee232r.HighDriveIOs = Convert.ToBoolean (eedata.HighDriveIOs);  	ee232r.EndpointSize = eedata.EndpointSize;  	ee232r.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableR);  	ee232r.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableR);  	ee232r.InvertTXD = Convert.ToBoolean (eedata.InvertTXD);  	ee232r.InvertRXD = Convert.ToBoolean (eedata.InvertRXD);  	ee232r.InvertRTS = Convert.ToBoolean (eedata.InvertRTS);  	ee232r.InvertCTS = Convert.ToBoolean (eedata.InvertCTS);  	ee232r.InvertDTR = Convert.ToBoolean (eedata.InvertDTR);  	ee232r.InvertDSR = Convert.ToBoolean (eedata.InvertDSR);  	ee232r.InvertDCD = Convert.ToBoolean (eedata.InvertDCD);  	ee232r.InvertRI = Convert.ToBoolean (eedata.InvertRI);  	ee232r.Cbus0 = eedata.Cbus0;  	ee232r.Cbus1 = eedata.Cbus1;  	ee232r.Cbus2 = eedata.Cbus2;  	ee232r.Cbus3 = eedata.Cbus3;  	ee232r.Cbus4 = eedata.Cbus4;  	ee232r.RIsD2XX = Convert.ToBoolean (eedata.RIsD2XX);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232REEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232h.VendorID = eedata.VendorID;  		ee2232h.ProductID = eedata.ProductID;  		ee2232h.MaxPower = eedata.MaxPower;  		ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232H specific fields  		ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  		ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  		ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  		ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  		ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  		ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  		ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  		ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  		ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  		ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  		ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  		ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  		ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  		ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  		ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  		ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  		ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  		ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  		ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  		ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  		ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  		ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  		ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232h.VendorID = eedata.VendorID;  		ee2232h.ProductID = eedata.ProductID;  		ee2232h.MaxPower = eedata.MaxPower;  		ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232H specific fields  		ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  		ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  		ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  		ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  		ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  		ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  		ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  		ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  		ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  		ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  		ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  		ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  		ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  		ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  		ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  		ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  		ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  		ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  		ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  		ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  		ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  		ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  		ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232h.VendorID = eedata.VendorID;  		ee2232h.ProductID = eedata.ProductID;  		ee2232h.MaxPower = eedata.MaxPower;  		ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232H specific fields  		ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  		ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  		ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  		ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  		ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  		ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  		ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  		ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  		ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  		ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  		ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  		ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  		ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  		ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  		ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  		ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  		ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  		ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  		ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  		ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  		ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  		ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  		ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232h.VendorID = eedata.VendorID;  		ee2232h.ProductID = eedata.ProductID;  		ee2232h.MaxPower = eedata.MaxPower;  		ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232H specific fields  		ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  		ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  		ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  		ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  		ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  		ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  		ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  		ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  		ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  		ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  		ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  		ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  		ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  		ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  		ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  		ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  		ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  		ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  		ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  		ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  		ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  		ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  		ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee2232h.VendorID = eedata.VendorID;  		ee2232h.ProductID = eedata.ProductID;  		ee2232h.MaxPower = eedata.MaxPower;  		ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 2232H specific fields  		ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  		ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  		ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  		ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  		ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  		ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  		ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  		ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  		ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  		ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  		ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  		ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  		ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  		ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  		ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  		ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  		ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  		ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  		ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  		ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  		ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  		ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  		ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232h.VendorID = eedata.VendorID;  	ee2232h.ProductID = eedata.ProductID;  	ee2232h.MaxPower = eedata.MaxPower;  	ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232H specific fields  	ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  	ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  	ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  	ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  	ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  	ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  	ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  	ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  	ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  	ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  	ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  	ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  	ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  	ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  	ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  	ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  	ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  	ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  	ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  	ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  	ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  	ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  	ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232h.VendorID = eedata.VendorID;  	ee2232h.ProductID = eedata.ProductID;  	ee2232h.MaxPower = eedata.MaxPower;  	ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232H specific fields  	ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  	ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  	ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  	ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  	ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  	ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  	ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  	ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  	ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  	ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  	ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  	ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  	ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  	ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  	ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  	ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  	ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  	ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  	ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  	ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  	ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  	ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  	ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232h.VendorID = eedata.VendorID;  	ee2232h.ProductID = eedata.ProductID;  	ee2232h.MaxPower = eedata.MaxPower;  	ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232H specific fields  	ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  	ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  	ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  	ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  	ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  	ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  	ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  	ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  	ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  	ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  	ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  	ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  	ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  	ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  	ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  	ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  	ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  	ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  	ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  	ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  	ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  	ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  	ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232h.VendorID = eedata.VendorID;  	ee2232h.ProductID = eedata.ProductID;  	ee2232h.MaxPower = eedata.MaxPower;  	ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232H specific fields  	ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  	ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  	ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  	ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  	ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  	ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  	ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  	ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  	ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  	ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  	ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  	ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  	ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  	ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  	ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  	ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  	ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  	ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  	ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  	ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  	ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  	ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  	ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee2232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee2232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee2232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee2232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee2232h.VendorID = eedata.VendorID;  	ee2232h.ProductID = eedata.ProductID;  	ee2232h.MaxPower = eedata.MaxPower;  	ee2232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee2232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 2232H specific fields  	ee2232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable7);  	ee2232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable7);  	ee2232h.ALSlowSlew = Convert.ToBoolean (eedata.ALSlowSlew);  	ee2232h.ALSchmittInput = Convert.ToBoolean (eedata.ALSchmittInput);  	ee2232h.ALDriveCurrent = eedata.ALDriveCurrent;  	ee2232h.AHSlowSlew = Convert.ToBoolean (eedata.AHSlowSlew);  	ee2232h.AHSchmittInput = Convert.ToBoolean (eedata.AHSchmittInput);  	ee2232h.AHDriveCurrent = eedata.AHDriveCurrent;  	ee2232h.BLSlowSlew = Convert.ToBoolean (eedata.BLSlowSlew);  	ee2232h.BLSchmittInput = Convert.ToBoolean (eedata.BLSchmittInput);  	ee2232h.BLDriveCurrent = eedata.BLDriveCurrent;  	ee2232h.BHSlowSlew = Convert.ToBoolean (eedata.BHSlowSlew);  	ee2232h.BHSchmittInput = Convert.ToBoolean (eedata.BHSchmittInput);  	ee2232h.BHDriveCurrent = eedata.BHDriveCurrent;  	ee2232h.IFAIsFifo = Convert.ToBoolean (eedata.IFAIsFifo7);  	ee2232h.IFAIsFifoTar = Convert.ToBoolean (eedata.IFAIsFifoTar7);  	ee2232h.IFAIsFastSer = Convert.ToBoolean (eedata.IFAIsFastSer7);  	ee2232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP7);  	ee2232h.IFBIsFifo = Convert.ToBoolean (eedata.IFBIsFifo7);  	ee2232h.IFBIsFifoTar = Convert.ToBoolean (eedata.IFBIsFifoTar7);  	ee2232h.IFBIsFastSer = Convert.ToBoolean (eedata.IFBIsFastSer7);  	ee2232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP7);  	ee2232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnable);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: eedata.Version = 3;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT2232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee4232h.VendorID = eedata.VendorID;  		ee4232h.ProductID = eedata.ProductID;  		ee4232h.MaxPower = eedata.MaxPower;  		ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 4232H specific fields  		ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  		ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  		ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  		ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  		ee4232h.ADriveCurrent = eedata.ADriveCurrent;  		ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  		ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  		ee4232h.BDriveCurrent = eedata.BDriveCurrent;  		ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  		ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  		ee4232h.CDriveCurrent = eedata.CDriveCurrent;  		ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  		ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  		ee4232h.DDriveCurrent = eedata.DDriveCurrent;  		ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  		ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  		ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  		ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  		ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  		ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  		ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  		ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee4232h.VendorID = eedata.VendorID;  		ee4232h.ProductID = eedata.ProductID;  		ee4232h.MaxPower = eedata.MaxPower;  		ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 4232H specific fields  		ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  		ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  		ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  		ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  		ee4232h.ADriveCurrent = eedata.ADriveCurrent;  		ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  		ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  		ee4232h.BDriveCurrent = eedata.BDriveCurrent;  		ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  		ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  		ee4232h.CDriveCurrent = eedata.CDriveCurrent;  		ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  		ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  		ee4232h.DDriveCurrent = eedata.DDriveCurrent;  		ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  		ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  		ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  		ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  		ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  		ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  		ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  		ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee4232h.VendorID = eedata.VendorID;  		ee4232h.ProductID = eedata.ProductID;  		ee4232h.MaxPower = eedata.MaxPower;  		ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 4232H specific fields  		ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  		ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  		ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  		ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  		ee4232h.ADriveCurrent = eedata.ADriveCurrent;  		ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  		ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  		ee4232h.BDriveCurrent = eedata.BDriveCurrent;  		ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  		ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  		ee4232h.CDriveCurrent = eedata.CDriveCurrent;  		ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  		ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  		ee4232h.DDriveCurrent = eedata.DDriveCurrent;  		ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  		ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  		ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  		ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  		ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  		ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  		ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  		ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee4232h.VendorID = eedata.VendorID;  		ee4232h.ProductID = eedata.ProductID;  		ee4232h.MaxPower = eedata.MaxPower;  		ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 4232H specific fields  		ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  		ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  		ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  		ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  		ee4232h.ADriveCurrent = eedata.ADriveCurrent;  		ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  		ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  		ee4232h.BDriveCurrent = eedata.BDriveCurrent;  		ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  		ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  		ee4232h.CDriveCurrent = eedata.CDriveCurrent;  		ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  		ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  		ee4232h.DDriveCurrent = eedata.DDriveCurrent;  		ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  		ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  		ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  		ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  		ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  		ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  		ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  		ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee4232h.VendorID = eedata.VendorID;  		ee4232h.ProductID = eedata.ProductID;  		ee4232h.MaxPower = eedata.MaxPower;  		ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 4232H specific fields  		ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  		ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  		ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  		ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  		ee4232h.ADriveCurrent = eedata.ADriveCurrent;  		ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  		ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  		ee4232h.BDriveCurrent = eedata.BDriveCurrent;  		ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  		ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  		ee4232h.CDriveCurrent = eedata.CDriveCurrent;  		ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  		ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  		ee4232h.DDriveCurrent = eedata.DDriveCurrent;  		ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  		ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  		ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  		ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  		ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  		ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  		ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  		ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee4232h.VendorID = eedata.VendorID;  	ee4232h.ProductID = eedata.ProductID;  	ee4232h.MaxPower = eedata.MaxPower;  	ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 4232H specific fields  	ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  	ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  	ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  	ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  	ee4232h.ADriveCurrent = eedata.ADriveCurrent;  	ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  	ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  	ee4232h.BDriveCurrent = eedata.BDriveCurrent;  	ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  	ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  	ee4232h.CDriveCurrent = eedata.CDriveCurrent;  	ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  	ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  	ee4232h.DDriveCurrent = eedata.DDriveCurrent;  	ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  	ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  	ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  	ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  	ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  	ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  	ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  	ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee4232h.VendorID = eedata.VendorID;  	ee4232h.ProductID = eedata.ProductID;  	ee4232h.MaxPower = eedata.MaxPower;  	ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 4232H specific fields  	ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  	ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  	ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  	ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  	ee4232h.ADriveCurrent = eedata.ADriveCurrent;  	ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  	ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  	ee4232h.BDriveCurrent = eedata.BDriveCurrent;  	ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  	ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  	ee4232h.CDriveCurrent = eedata.CDriveCurrent;  	ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  	ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  	ee4232h.DDriveCurrent = eedata.DDriveCurrent;  	ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  	ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  	ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  	ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  	ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  	ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  	ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  	ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee4232h.VendorID = eedata.VendorID;  	ee4232h.ProductID = eedata.ProductID;  	ee4232h.MaxPower = eedata.MaxPower;  	ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 4232H specific fields  	ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  	ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  	ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  	ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  	ee4232h.ADriveCurrent = eedata.ADriveCurrent;  	ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  	ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  	ee4232h.BDriveCurrent = eedata.BDriveCurrent;  	ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  	ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  	ee4232h.CDriveCurrent = eedata.CDriveCurrent;  	ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  	ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  	ee4232h.DDriveCurrent = eedata.DDriveCurrent;  	ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  	ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  	ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  	ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  	ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  	ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  	ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  	ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee4232h.VendorID = eedata.VendorID;  	ee4232h.ProductID = eedata.ProductID;  	ee4232h.MaxPower = eedata.MaxPower;  	ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 4232H specific fields  	ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  	ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  	ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  	ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  	ee4232h.ADriveCurrent = eedata.ADriveCurrent;  	ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  	ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  	ee4232h.BDriveCurrent = eedata.BDriveCurrent;  	ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  	ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  	ee4232h.CDriveCurrent = eedata.CDriveCurrent;  	ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  	ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  	ee4232h.DDriveCurrent = eedata.DDriveCurrent;  	ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  	ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  	ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  	ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  	ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  	ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  	ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  	ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee4232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee4232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee4232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee4232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee4232h.VendorID = eedata.VendorID;  	ee4232h.ProductID = eedata.ProductID;  	ee4232h.MaxPower = eedata.MaxPower;  	ee4232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee4232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 4232H specific fields  	ee4232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnable8);  	ee4232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnable8);  	ee4232h.ASlowSlew = Convert.ToBoolean (eedata.ASlowSlew);  	ee4232h.ASchmittInput = Convert.ToBoolean (eedata.ASchmittInput);  	ee4232h.ADriveCurrent = eedata.ADriveCurrent;  	ee4232h.BSlowSlew = Convert.ToBoolean (eedata.BSlowSlew);  	ee4232h.BSchmittInput = Convert.ToBoolean (eedata.BSchmittInput);  	ee4232h.BDriveCurrent = eedata.BDriveCurrent;  	ee4232h.CSlowSlew = Convert.ToBoolean (eedata.CSlowSlew);  	ee4232h.CSchmittInput = Convert.ToBoolean (eedata.CSchmittInput);  	ee4232h.CDriveCurrent = eedata.CDriveCurrent;  	ee4232h.DSlowSlew = Convert.ToBoolean (eedata.DSlowSlew);  	ee4232h.DSchmittInput = Convert.ToBoolean (eedata.DSchmittInput);  	ee4232h.DDriveCurrent = eedata.DDriveCurrent;  	ee4232h.ARIIsTXDEN = Convert.ToBoolean (eedata.ARIIsTXDEN);  	ee4232h.BRIIsTXDEN = Convert.ToBoolean (eedata.BRIIsTXDEN);  	ee4232h.CRIIsTXDEN = Convert.ToBoolean (eedata.CRIIsTXDEN);  	ee4232h.DRIIsTXDEN = Convert.ToBoolean (eedata.DRIIsTXDEN);  	ee4232h.AIsVCP = Convert.ToBoolean (eedata.AIsVCP8);  	ee4232h.BIsVCP = Convert.ToBoolean (eedata.BIsVCP8);  	ee4232h.CIsVCP = Convert.ToBoolean (eedata.CIsVCP8);  	ee4232h.DIsVCP = Convert.ToBoolean (eedata.DIsVCP8);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: eedata.Version = 4;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT4232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232h.VendorID = eedata.VendorID;  		ee232h.ProductID = eedata.ProductID;  		ee232h.MaxPower = eedata.MaxPower;  		ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232H specific fields  		ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  		ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  		ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  		ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  		ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  		ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  		ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  		ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  		ee232h.Cbus0 = eedata.Cbus0H;  		ee232h.Cbus1 = eedata.Cbus1H;  		ee232h.Cbus2 = eedata.Cbus2H;  		ee232h.Cbus3 = eedata.Cbus3H;  		ee232h.Cbus4 = eedata.Cbus4H;  		ee232h.Cbus5 = eedata.Cbus5H;  		ee232h.Cbus6 = eedata.Cbus6H;  		ee232h.Cbus7 = eedata.Cbus7H;  		ee232h.Cbus8 = eedata.Cbus8H;  		ee232h.Cbus9 = eedata.Cbus9H;  		ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  		ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  		ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  		ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  		ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  		ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  		ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  		ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  		ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232h.VendorID = eedata.VendorID;  		ee232h.ProductID = eedata.ProductID;  		ee232h.MaxPower = eedata.MaxPower;  		ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232H specific fields  		ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  		ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  		ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  		ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  		ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  		ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  		ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  		ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  		ee232h.Cbus0 = eedata.Cbus0H;  		ee232h.Cbus1 = eedata.Cbus1H;  		ee232h.Cbus2 = eedata.Cbus2H;  		ee232h.Cbus3 = eedata.Cbus3H;  		ee232h.Cbus4 = eedata.Cbus4H;  		ee232h.Cbus5 = eedata.Cbus5H;  		ee232h.Cbus6 = eedata.Cbus6H;  		ee232h.Cbus7 = eedata.Cbus7H;  		ee232h.Cbus8 = eedata.Cbus8H;  		ee232h.Cbus9 = eedata.Cbus9H;  		ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  		ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  		ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  		ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  		ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  		ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  		ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  		ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  		ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232h.VendorID = eedata.VendorID;  		ee232h.ProductID = eedata.ProductID;  		ee232h.MaxPower = eedata.MaxPower;  		ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232H specific fields  		ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  		ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  		ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  		ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  		ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  		ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  		ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  		ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  		ee232h.Cbus0 = eedata.Cbus0H;  		ee232h.Cbus1 = eedata.Cbus1H;  		ee232h.Cbus2 = eedata.Cbus2H;  		ee232h.Cbus3 = eedata.Cbus3H;  		ee232h.Cbus4 = eedata.Cbus4H;  		ee232h.Cbus5 = eedata.Cbus5H;  		ee232h.Cbus6 = eedata.Cbus6H;  		ee232h.Cbus7 = eedata.Cbus7H;  		ee232h.Cbus8 = eedata.Cbus8H;  		ee232h.Cbus9 = eedata.Cbus9H;  		ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  		ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  		ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  		ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  		ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  		ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  		ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  		ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  		ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232h.VendorID = eedata.VendorID;  		ee232h.ProductID = eedata.ProductID;  		ee232h.MaxPower = eedata.MaxPower;  		ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232H specific fields  		ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  		ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  		ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  		ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  		ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  		ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  		ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  		ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  		ee232h.Cbus0 = eedata.Cbus0H;  		ee232h.Cbus1 = eedata.Cbus1H;  		ee232h.Cbus2 = eedata.Cbus2H;  		ee232h.Cbus3 = eedata.Cbus3H;  		ee232h.Cbus4 = eedata.Cbus4H;  		ee232h.Cbus5 = eedata.Cbus5H;  		ee232h.Cbus6 = eedata.Cbus6H;  		ee232h.Cbus7 = eedata.Cbus7H;  		ee232h.Cbus8 = eedata.Cbus8H;  		ee232h.Cbus9 = eedata.Cbus9H;  		ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  		ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  		ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  		ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  		ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  		ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  		ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  		ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  		ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Read != IntPtr.Zero) {  	tFT_EE_Read FT_EE_Read = (tFT_EE_Read)Marshal.GetDelegateForFunctionPointer (pFT_EE_Read' typeof(tFT_EE_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Call FT_EE_Read  		ftStatus = FT_EE_Read (ftHandle' eedata);  		// Retrieve string values  		ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  		ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  		ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  		ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		ee232h.VendorID = eedata.VendorID;  		ee232h.ProductID = eedata.ProductID;  		ee232h.MaxPower = eedata.MaxPower;  		ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  		ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  		// 232H specific fields  		ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  		ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  		ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  		ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  		ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  		ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  		ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  		ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  		ee232h.Cbus0 = eedata.Cbus0H;  		ee232h.Cbus1 = eedata.Cbus1H;  		ee232h.Cbus2 = eedata.Cbus2H;  		ee232h.Cbus3 = eedata.Cbus3H;  		ee232h.Cbus4 = eedata.Cbus4H;  		ee232h.Cbus5 = eedata.Cbus5H;  		ee232h.Cbus6 = eedata.Cbus6H;  		ee232h.Cbus7 = eedata.Cbus7H;  		ee232h.Cbus8 = eedata.Cbus8H;  		ee232h.Cbus9 = eedata.Cbus9H;  		ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  		ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  		ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  		ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  		ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  		ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  		ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  		ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  		ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232h.VendorID = eedata.VendorID;  	ee232h.ProductID = eedata.ProductID;  	ee232h.MaxPower = eedata.MaxPower;  	ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232H specific fields  	ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  	ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  	ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  	ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  	ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  	ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  	ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  	ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  	ee232h.Cbus0 = eedata.Cbus0H;  	ee232h.Cbus1 = eedata.Cbus1H;  	ee232h.Cbus2 = eedata.Cbus2H;  	ee232h.Cbus3 = eedata.Cbus3H;  	ee232h.Cbus4 = eedata.Cbus4H;  	ee232h.Cbus5 = eedata.Cbus5H;  	ee232h.Cbus6 = eedata.Cbus6H;  	ee232h.Cbus7 = eedata.Cbus7H;  	ee232h.Cbus8 = eedata.Cbus8H;  	ee232h.Cbus9 = eedata.Cbus9H;  	ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  	ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  	ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  	ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  	ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  	ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  	ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  	ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  	ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232h.VendorID = eedata.VendorID;  	ee232h.ProductID = eedata.ProductID;  	ee232h.MaxPower = eedata.MaxPower;  	ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232H specific fields  	ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  	ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  	ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  	ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  	ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  	ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  	ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  	ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  	ee232h.Cbus0 = eedata.Cbus0H;  	ee232h.Cbus1 = eedata.Cbus1H;  	ee232h.Cbus2 = eedata.Cbus2H;  	ee232h.Cbus3 = eedata.Cbus3H;  	ee232h.Cbus4 = eedata.Cbus4H;  	ee232h.Cbus5 = eedata.Cbus5H;  	ee232h.Cbus6 = eedata.Cbus6H;  	ee232h.Cbus7 = eedata.Cbus7H;  	ee232h.Cbus8 = eedata.Cbus8H;  	ee232h.Cbus9 = eedata.Cbus9H;  	ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  	ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  	ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  	ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  	ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  	ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  	ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  	ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  	ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232h.VendorID = eedata.VendorID;  	ee232h.ProductID = eedata.ProductID;  	ee232h.MaxPower = eedata.MaxPower;  	ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232H specific fields  	ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  	ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  	ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  	ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  	ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  	ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  	ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  	ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  	ee232h.Cbus0 = eedata.Cbus0H;  	ee232h.Cbus1 = eedata.Cbus1H;  	ee232h.Cbus2 = eedata.Cbus2H;  	ee232h.Cbus3 = eedata.Cbus3H;  	ee232h.Cbus4 = eedata.Cbus4H;  	ee232h.Cbus5 = eedata.Cbus5H;  	ee232h.Cbus6 = eedata.Cbus6H;  	ee232h.Cbus7 = eedata.Cbus7H;  	ee232h.Cbus8 = eedata.Cbus8H;  	ee232h.Cbus9 = eedata.Cbus9H;  	ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  	ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  	ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  	ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  	ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  	ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  	ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  	ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  	ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232h.VendorID = eedata.VendorID;  	ee232h.ProductID = eedata.ProductID;  	ee232h.MaxPower = eedata.MaxPower;  	ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232H specific fields  	ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  	ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  	ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  	ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  	ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  	ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  	ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  	ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  	ee232h.Cbus0 = eedata.Cbus0H;  	ee232h.Cbus1 = eedata.Cbus1H;  	ee232h.Cbus2 = eedata.Cbus2H;  	ee232h.Cbus3 = eedata.Cbus3H;  	ee232h.Cbus4 = eedata.Cbus4H;  	ee232h.Cbus5 = eedata.Cbus5H;  	ee232h.Cbus6 = eedata.Cbus6H;  	ee232h.Cbus7 = eedata.Cbus7H;  	ee232h.Cbus8 = eedata.Cbus8H;  	ee232h.Cbus9 = eedata.Cbus9H;  	ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  	ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  	ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  	ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  	ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  	ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  	ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  	ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  	ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Call FT_EE_Read  	ftStatus = FT_EE_Read (ftHandle' eedata);  	// Retrieve string values  	ee232h.Manufacturer = Marshal.PtrToStringAnsi (eedata.Manufacturer);  	ee232h.ManufacturerID = Marshal.PtrToStringAnsi (eedata.ManufacturerID);  	ee232h.Description = Marshal.PtrToStringAnsi (eedata.Description);  	ee232h.SerialNumber = Marshal.PtrToStringAnsi (eedata.SerialNumber);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	ee232h.VendorID = eedata.VendorID;  	ee232h.ProductID = eedata.ProductID;  	ee232h.MaxPower = eedata.MaxPower;  	ee232h.SelfPowered = Convert.ToBoolean (eedata.SelfPowered);  	ee232h.RemoteWakeup = Convert.ToBoolean (eedata.RemoteWakeup);  	// 232H specific fields  	ee232h.PullDownEnable = Convert.ToBoolean (eedata.PullDownEnableH);  	ee232h.SerNumEnable = Convert.ToBoolean (eedata.SerNumEnableH);  	ee232h.ACSlowSlew = Convert.ToBoolean (eedata.ACSlowSlewH);  	ee232h.ACSchmittInput = Convert.ToBoolean (eedata.ACSchmittInputH);  	ee232h.ACDriveCurrent = eedata.ACDriveCurrentH;  	ee232h.ADSlowSlew = Convert.ToBoolean (eedata.ADSlowSlewH);  	ee232h.ADSchmittInput = Convert.ToBoolean (eedata.ADSchmittInputH);  	ee232h.ADDriveCurrent = eedata.ADDriveCurrentH;  	ee232h.Cbus0 = eedata.Cbus0H;  	ee232h.Cbus1 = eedata.Cbus1H;  	ee232h.Cbus2 = eedata.Cbus2H;  	ee232h.Cbus3 = eedata.Cbus3H;  	ee232h.Cbus4 = eedata.Cbus4H;  	ee232h.Cbus5 = eedata.Cbus5H;  	ee232h.Cbus6 = eedata.Cbus6H;  	ee232h.Cbus7 = eedata.Cbus7H;  	ee232h.Cbus8 = eedata.Cbus8H;  	ee232h.Cbus9 = eedata.Cbus9H;  	ee232h.IsFifo = Convert.ToBoolean (eedata.IsFifoH);  	ee232h.IsFifoTar = Convert.ToBoolean (eedata.IsFifoTarH);  	ee232h.IsFastSer = Convert.ToBoolean (eedata.IsFastSerH);  	ee232h.IsFT1248 = Convert.ToBoolean (eedata.IsFT1248H);  	ee232h.FT1248Cpol = Convert.ToBoolean (eedata.FT1248CpolH);  	ee232h.FT1248Lsb = Convert.ToBoolean (eedata.FT1248LsbH);  	ee232h.FT1248FlowControl = Convert.ToBoolean (eedata.FT1248FlowControlH);  	ee232h.IsVCP = Convert.ToBoolean (eedata.IsVCPH);  	ee232h.PowerSaveEnable = Convert.ToBoolean (eedata.PowerSaveEnableH);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: eedata.Version = 5;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadFT232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Read != IntPtr.Zero) {  	tFT_EEPROM_Read FT_EEPROM_Read = (tFT_EEPROM_Read)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Read' typeof(tFT_EEPROM_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  		byte[] manufacturer = new byte[32];  		byte[] manufacturerID = new byte[16];  		byte[] description = new byte[64];  		byte[] serialNumber = new byte[16];  		eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common = eeHeader;  		// Calculate the size of our data structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		// Call FT_EEPROM_Read  		ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  		if (ftStatus == FT_STATUS.FT_OK) {  			// Get the data back from the pointer...  			eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  			// Retrieve string values  			System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  			eeX.Manufacturer = enc.GetString (manufacturer);  			eeX.ManufacturerID = enc.GetString (manufacturerID);  			eeX.Description = enc.GetString (description);  			eeX.SerialNumber = enc.GetString (serialNumber);  			// Map non-string elements to structure to be returned  			// Standard elements  			eeX.VendorID = eeData.common.VendorId;  			eeX.ProductID = eeData.common.ProductId;  			eeX.MaxPower = eeData.common.MaxPower;  			eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  			eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  			eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  			eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  			// X-Series specific fields  			// CBUS  			eeX.Cbus0 = eeData.Cbus0;  			eeX.Cbus1 = eeData.Cbus1;  			eeX.Cbus2 = eeData.Cbus2;  			eeX.Cbus3 = eeData.Cbus3;  			eeX.Cbus4 = eeData.Cbus4;  			eeX.Cbus5 = eeData.Cbus5;  			eeX.Cbus6 = eeData.Cbus6;  			// Drive Options  			eeX.ACDriveCurrent = eeData.ACDriveCurrent;  			eeX.ACSchmittInput = eeData.ACSchmittInput;  			eeX.ACSlowSlew = eeData.ACSlowSlew;  			eeX.ADDriveCurrent = eeData.ADDriveCurrent;  			eeX.ADSchmittInput = eeData.ADSchmittInput;  			eeX.ADSlowSlew = eeData.ADSlowSlew;  			// BCD  			eeX.BCDDisableSleep = eeData.BCDDisableSleep;  			eeX.BCDEnable = eeData.BCDEnable;  			eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  			// FT1248  			eeX.FT1248Cpol = eeData.FT1248Cpol;  			eeX.FT1248FlowControl = eeData.FT1248FlowControl;  			eeX.FT1248Lsb = eeData.FT1248Lsb;  			// I2C  			eeX.I2CDeviceId = eeData.I2CDeviceId;  			eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  			eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  			// RS232 Signals  			eeX.InvertCTS = eeData.InvertCTS;  			eeX.InvertDCD = eeData.InvertDCD;  			eeX.InvertDSR = eeData.InvertDSR;  			eeX.InvertDTR = eeData.InvertDTR;  			eeX.InvertRI = eeData.InvertRI;  			eeX.InvertRTS = eeData.InvertRTS;  			eeX.InvertRXD = eeData.InvertRXD;  			eeX.InvertTXD = eeData.InvertTXD;  			// Hardware Options  			eeX.PowerSaveEnable = eeData.PowerSaveEnable;  			eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  			// Driver Option  			eeX.IsVCP = eeData.DriverType;  		}  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Read != IntPtr.Zero) {  	tFT_EEPROM_Read FT_EEPROM_Read = (tFT_EEPROM_Read)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Read' typeof(tFT_EEPROM_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  		byte[] manufacturer = new byte[32];  		byte[] manufacturerID = new byte[16];  		byte[] description = new byte[64];  		byte[] serialNumber = new byte[16];  		eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common = eeHeader;  		// Calculate the size of our data structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		// Call FT_EEPROM_Read  		ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  		if (ftStatus == FT_STATUS.FT_OK) {  			// Get the data back from the pointer...  			eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  			// Retrieve string values  			System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  			eeX.Manufacturer = enc.GetString (manufacturer);  			eeX.ManufacturerID = enc.GetString (manufacturerID);  			eeX.Description = enc.GetString (description);  			eeX.SerialNumber = enc.GetString (serialNumber);  			// Map non-string elements to structure to be returned  			// Standard elements  			eeX.VendorID = eeData.common.VendorId;  			eeX.ProductID = eeData.common.ProductId;  			eeX.MaxPower = eeData.common.MaxPower;  			eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  			eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  			eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  			eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  			// X-Series specific fields  			// CBUS  			eeX.Cbus0 = eeData.Cbus0;  			eeX.Cbus1 = eeData.Cbus1;  			eeX.Cbus2 = eeData.Cbus2;  			eeX.Cbus3 = eeData.Cbus3;  			eeX.Cbus4 = eeData.Cbus4;  			eeX.Cbus5 = eeData.Cbus5;  			eeX.Cbus6 = eeData.Cbus6;  			// Drive Options  			eeX.ACDriveCurrent = eeData.ACDriveCurrent;  			eeX.ACSchmittInput = eeData.ACSchmittInput;  			eeX.ACSlowSlew = eeData.ACSlowSlew;  			eeX.ADDriveCurrent = eeData.ADDriveCurrent;  			eeX.ADSchmittInput = eeData.ADSchmittInput;  			eeX.ADSlowSlew = eeData.ADSlowSlew;  			// BCD  			eeX.BCDDisableSleep = eeData.BCDDisableSleep;  			eeX.BCDEnable = eeData.BCDEnable;  			eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  			// FT1248  			eeX.FT1248Cpol = eeData.FT1248Cpol;  			eeX.FT1248FlowControl = eeData.FT1248FlowControl;  			eeX.FT1248Lsb = eeData.FT1248Lsb;  			// I2C  			eeX.I2CDeviceId = eeData.I2CDeviceId;  			eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  			eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  			// RS232 Signals  			eeX.InvertCTS = eeData.InvertCTS;  			eeX.InvertDCD = eeData.InvertDCD;  			eeX.InvertDSR = eeData.InvertDSR;  			eeX.InvertDTR = eeData.InvertDTR;  			eeX.InvertRI = eeData.InvertRI;  			eeX.InvertRTS = eeData.InvertRTS;  			eeX.InvertRXD = eeData.InvertRXD;  			eeX.InvertTXD = eeData.InvertTXD;  			// Hardware Options  			eeX.PowerSaveEnable = eeData.PowerSaveEnable;  			eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  			// Driver Option  			eeX.IsVCP = eeData.DriverType;  		}  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Read != IntPtr.Zero) {  	tFT_EEPROM_Read FT_EEPROM_Read = (tFT_EEPROM_Read)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Read' typeof(tFT_EEPROM_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  		byte[] manufacturer = new byte[32];  		byte[] manufacturerID = new byte[16];  		byte[] description = new byte[64];  		byte[] serialNumber = new byte[16];  		eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common = eeHeader;  		// Calculate the size of our data structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		// Call FT_EEPROM_Read  		ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  		if (ftStatus == FT_STATUS.FT_OK) {  			// Get the data back from the pointer...  			eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  			// Retrieve string values  			System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  			eeX.Manufacturer = enc.GetString (manufacturer);  			eeX.ManufacturerID = enc.GetString (manufacturerID);  			eeX.Description = enc.GetString (description);  			eeX.SerialNumber = enc.GetString (serialNumber);  			// Map non-string elements to structure to be returned  			// Standard elements  			eeX.VendorID = eeData.common.VendorId;  			eeX.ProductID = eeData.common.ProductId;  			eeX.MaxPower = eeData.common.MaxPower;  			eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  			eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  			eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  			eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  			// X-Series specific fields  			// CBUS  			eeX.Cbus0 = eeData.Cbus0;  			eeX.Cbus1 = eeData.Cbus1;  			eeX.Cbus2 = eeData.Cbus2;  			eeX.Cbus3 = eeData.Cbus3;  			eeX.Cbus4 = eeData.Cbus4;  			eeX.Cbus5 = eeData.Cbus5;  			eeX.Cbus6 = eeData.Cbus6;  			// Drive Options  			eeX.ACDriveCurrent = eeData.ACDriveCurrent;  			eeX.ACSchmittInput = eeData.ACSchmittInput;  			eeX.ACSlowSlew = eeData.ACSlowSlew;  			eeX.ADDriveCurrent = eeData.ADDriveCurrent;  			eeX.ADSchmittInput = eeData.ADSchmittInput;  			eeX.ADSlowSlew = eeData.ADSlowSlew;  			// BCD  			eeX.BCDDisableSleep = eeData.BCDDisableSleep;  			eeX.BCDEnable = eeData.BCDEnable;  			eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  			// FT1248  			eeX.FT1248Cpol = eeData.FT1248Cpol;  			eeX.FT1248FlowControl = eeData.FT1248FlowControl;  			eeX.FT1248Lsb = eeData.FT1248Lsb;  			// I2C  			eeX.I2CDeviceId = eeData.I2CDeviceId;  			eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  			eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  			// RS232 Signals  			eeX.InvertCTS = eeData.InvertCTS;  			eeX.InvertDCD = eeData.InvertDCD;  			eeX.InvertDSR = eeData.InvertDSR;  			eeX.InvertDTR = eeData.InvertDTR;  			eeX.InvertRI = eeData.InvertRI;  			eeX.InvertRTS = eeData.InvertRTS;  			eeX.InvertRXD = eeData.InvertRXD;  			eeX.InvertTXD = eeData.InvertTXD;  			// Hardware Options  			eeX.PowerSaveEnable = eeData.PowerSaveEnable;  			eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  			// Driver Option  			eeX.IsVCP = eeData.DriverType;  		}  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Read != IntPtr.Zero) {  	tFT_EEPROM_Read FT_EEPROM_Read = (tFT_EEPROM_Read)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Read' typeof(tFT_EEPROM_Read));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to read  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  		byte[] manufacturer = new byte[32];  		byte[] manufacturerID = new byte[16];  		byte[] description = new byte[64];  		byte[] serialNumber = new byte[16];  		eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common = eeHeader;  		// Calculate the size of our data structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		// Call FT_EEPROM_Read  		ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  		if (ftStatus == FT_STATUS.FT_OK) {  			// Get the data back from the pointer...  			eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  			// Retrieve string values  			System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  			eeX.Manufacturer = enc.GetString (manufacturer);  			eeX.ManufacturerID = enc.GetString (manufacturerID);  			eeX.Description = enc.GetString (description);  			eeX.SerialNumber = enc.GetString (serialNumber);  			// Map non-string elements to structure to be returned  			// Standard elements  			eeX.VendorID = eeData.common.VendorId;  			eeX.ProductID = eeData.common.ProductId;  			eeX.MaxPower = eeData.common.MaxPower;  			eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  			eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  			eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  			eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  			// X-Series specific fields  			// CBUS  			eeX.Cbus0 = eeData.Cbus0;  			eeX.Cbus1 = eeData.Cbus1;  			eeX.Cbus2 = eeData.Cbus2;  			eeX.Cbus3 = eeData.Cbus3;  			eeX.Cbus4 = eeData.Cbus4;  			eeX.Cbus5 = eeData.Cbus5;  			eeX.Cbus6 = eeData.Cbus6;  			// Drive Options  			eeX.ACDriveCurrent = eeData.ACDriveCurrent;  			eeX.ACSchmittInput = eeData.ACSchmittInput;  			eeX.ACSlowSlew = eeData.ACSlowSlew;  			eeX.ADDriveCurrent = eeData.ADDriveCurrent;  			eeX.ADSchmittInput = eeData.ADSchmittInput;  			eeX.ADSlowSlew = eeData.ADSlowSlew;  			// BCD  			eeX.BCDDisableSleep = eeData.BCDDisableSleep;  			eeX.BCDEnable = eeData.BCDEnable;  			eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  			// FT1248  			eeX.FT1248Cpol = eeData.FT1248Cpol;  			eeX.FT1248FlowControl = eeData.FT1248FlowControl;  			eeX.FT1248Lsb = eeData.FT1248Lsb;  			// I2C  			eeX.I2CDeviceId = eeData.I2CDeviceId;  			eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  			eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  			// RS232 Signals  			eeX.InvertCTS = eeData.InvertCTS;  			eeX.InvertDCD = eeData.InvertDCD;  			eeX.InvertDSR = eeData.InvertDSR;  			eeX.InvertDTR = eeData.InvertDTR;  			eeX.InvertRI = eeData.InvertRI;  			eeX.InvertRTS = eeData.InvertRTS;  			eeX.InvertRXD = eeData.InvertRXD;  			eeX.InvertTXD = eeData.InvertTXD;  			// Hardware Options  			eeX.PowerSaveEnable = eeData.PowerSaveEnable;  			eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  			// Driver Option  			eeX.IsVCP = eeData.DriverType;  		}  	}  }  else {  	if (pFT_EE_Read == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Read.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  	byte[] manufacturer = new byte[32];  	byte[] manufacturerID = new byte[16];  	byte[] description = new byte[64];  	byte[] serialNumber = new byte[16];  	eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common = eeHeader;  	// Calculate the size of our data structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	// Call FT_EEPROM_Read  	ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	if (ftStatus == FT_STATUS.FT_OK) {  		// Get the data back from the pointer...  		eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  		// Retrieve string values  		System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  		eeX.Manufacturer = enc.GetString (manufacturer);  		eeX.ManufacturerID = enc.GetString (manufacturerID);  		eeX.Description = enc.GetString (description);  		eeX.SerialNumber = enc.GetString (serialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeX.VendorID = eeData.common.VendorId;  		eeX.ProductID = eeData.common.ProductId;  		eeX.MaxPower = eeData.common.MaxPower;  		eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  		eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  		eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  		eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeX.Cbus0 = eeData.Cbus0;  		eeX.Cbus1 = eeData.Cbus1;  		eeX.Cbus2 = eeData.Cbus2;  		eeX.Cbus3 = eeData.Cbus3;  		eeX.Cbus4 = eeData.Cbus4;  		eeX.Cbus5 = eeData.Cbus5;  		eeX.Cbus6 = eeData.Cbus6;  		// Drive Options  		eeX.ACDriveCurrent = eeData.ACDriveCurrent;  		eeX.ACSchmittInput = eeData.ACSchmittInput;  		eeX.ACSlowSlew = eeData.ACSlowSlew;  		eeX.ADDriveCurrent = eeData.ADDriveCurrent;  		eeX.ADSchmittInput = eeData.ADSchmittInput;  		eeX.ADSlowSlew = eeData.ADSlowSlew;  		// BCD  		eeX.BCDDisableSleep = eeData.BCDDisableSleep;  		eeX.BCDEnable = eeData.BCDEnable;  		eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  		// FT1248  		eeX.FT1248Cpol = eeData.FT1248Cpol;  		eeX.FT1248FlowControl = eeData.FT1248FlowControl;  		eeX.FT1248Lsb = eeData.FT1248Lsb;  		// I2C  		eeX.I2CDeviceId = eeData.I2CDeviceId;  		eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  		eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  		// RS232 Signals  		eeX.InvertCTS = eeData.InvertCTS;  		eeX.InvertDCD = eeData.InvertDCD;  		eeX.InvertDSR = eeData.InvertDSR;  		eeX.InvertDTR = eeData.InvertDTR;  		eeX.InvertRI = eeData.InvertRI;  		eeX.InvertRTS = eeData.InvertRTS;  		eeX.InvertRXD = eeData.InvertRXD;  		eeX.InvertTXD = eeData.InvertTXD;  		// Hardware Options  		eeX.PowerSaveEnable = eeData.PowerSaveEnable;  		eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  		// Driver Option  		eeX.IsVCP = eeData.DriverType;  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  	byte[] manufacturer = new byte[32];  	byte[] manufacturerID = new byte[16];  	byte[] description = new byte[64];  	byte[] serialNumber = new byte[16];  	eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common = eeHeader;  	// Calculate the size of our data structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	// Call FT_EEPROM_Read  	ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	if (ftStatus == FT_STATUS.FT_OK) {  		// Get the data back from the pointer...  		eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  		// Retrieve string values  		System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  		eeX.Manufacturer = enc.GetString (manufacturer);  		eeX.ManufacturerID = enc.GetString (manufacturerID);  		eeX.Description = enc.GetString (description);  		eeX.SerialNumber = enc.GetString (serialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeX.VendorID = eeData.common.VendorId;  		eeX.ProductID = eeData.common.ProductId;  		eeX.MaxPower = eeData.common.MaxPower;  		eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  		eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  		eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  		eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeX.Cbus0 = eeData.Cbus0;  		eeX.Cbus1 = eeData.Cbus1;  		eeX.Cbus2 = eeData.Cbus2;  		eeX.Cbus3 = eeData.Cbus3;  		eeX.Cbus4 = eeData.Cbus4;  		eeX.Cbus5 = eeData.Cbus5;  		eeX.Cbus6 = eeData.Cbus6;  		// Drive Options  		eeX.ACDriveCurrent = eeData.ACDriveCurrent;  		eeX.ACSchmittInput = eeData.ACSchmittInput;  		eeX.ACSlowSlew = eeData.ACSlowSlew;  		eeX.ADDriveCurrent = eeData.ADDriveCurrent;  		eeX.ADSchmittInput = eeData.ADSchmittInput;  		eeX.ADSlowSlew = eeData.ADSlowSlew;  		// BCD  		eeX.BCDDisableSleep = eeData.BCDDisableSleep;  		eeX.BCDEnable = eeData.BCDEnable;  		eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  		// FT1248  		eeX.FT1248Cpol = eeData.FT1248Cpol;  		eeX.FT1248FlowControl = eeData.FT1248FlowControl;  		eeX.FT1248Lsb = eeData.FT1248Lsb;  		// I2C  		eeX.I2CDeviceId = eeData.I2CDeviceId;  		eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  		eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  		// RS232 Signals  		eeX.InvertCTS = eeData.InvertCTS;  		eeX.InvertDCD = eeData.InvertDCD;  		eeX.InvertDSR = eeData.InvertDSR;  		eeX.InvertDTR = eeData.InvertDTR;  		eeX.InvertRI = eeData.InvertRI;  		eeX.InvertRTS = eeData.InvertRTS;  		eeX.InvertRXD = eeData.InvertRXD;  		eeX.InvertTXD = eeData.InvertTXD;  		// Hardware Options  		eeX.PowerSaveEnable = eeData.PowerSaveEnable;  		eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  		// Driver Option  		eeX.IsVCP = eeData.DriverType;  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  	byte[] manufacturer = new byte[32];  	byte[] manufacturerID = new byte[16];  	byte[] description = new byte[64];  	byte[] serialNumber = new byte[16];  	eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common = eeHeader;  	// Calculate the size of our data structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	// Call FT_EEPROM_Read  	ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	if (ftStatus == FT_STATUS.FT_OK) {  		// Get the data back from the pointer...  		eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  		// Retrieve string values  		System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  		eeX.Manufacturer = enc.GetString (manufacturer);  		eeX.ManufacturerID = enc.GetString (manufacturerID);  		eeX.Description = enc.GetString (description);  		eeX.SerialNumber = enc.GetString (serialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeX.VendorID = eeData.common.VendorId;  		eeX.ProductID = eeData.common.ProductId;  		eeX.MaxPower = eeData.common.MaxPower;  		eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  		eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  		eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  		eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeX.Cbus0 = eeData.Cbus0;  		eeX.Cbus1 = eeData.Cbus1;  		eeX.Cbus2 = eeData.Cbus2;  		eeX.Cbus3 = eeData.Cbus3;  		eeX.Cbus4 = eeData.Cbus4;  		eeX.Cbus5 = eeData.Cbus5;  		eeX.Cbus6 = eeData.Cbus6;  		// Drive Options  		eeX.ACDriveCurrent = eeData.ACDriveCurrent;  		eeX.ACSchmittInput = eeData.ACSchmittInput;  		eeX.ACSlowSlew = eeData.ACSlowSlew;  		eeX.ADDriveCurrent = eeData.ADDriveCurrent;  		eeX.ADSchmittInput = eeData.ADSchmittInput;  		eeX.ADSlowSlew = eeData.ADSlowSlew;  		// BCD  		eeX.BCDDisableSleep = eeData.BCDDisableSleep;  		eeX.BCDEnable = eeData.BCDEnable;  		eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  		// FT1248  		eeX.FT1248Cpol = eeData.FT1248Cpol;  		eeX.FT1248FlowControl = eeData.FT1248FlowControl;  		eeX.FT1248Lsb = eeData.FT1248Lsb;  		// I2C  		eeX.I2CDeviceId = eeData.I2CDeviceId;  		eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  		eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  		// RS232 Signals  		eeX.InvertCTS = eeData.InvertCTS;  		eeX.InvertDCD = eeData.InvertDCD;  		eeX.InvertDSR = eeData.InvertDSR;  		eeX.InvertDTR = eeData.InvertDTR;  		eeX.InvertRI = eeData.InvertRI;  		eeX.InvertRTS = eeData.InvertRTS;  		eeX.InvertRXD = eeData.InvertRXD;  		eeX.InvertTXD = eeData.InvertTXD;  		// Hardware Options  		eeX.PowerSaveEnable = eeData.PowerSaveEnable;  		eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  		// Driver Option  		eeX.IsVCP = eeData.DriverType;  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,ReadXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to read  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	FT_EEPROM_HEADER eeHeader = new FT_EEPROM_HEADER ();  	byte[] manufacturer = new byte[32];  	byte[] manufacturerID = new byte[16];  	byte[] description = new byte[64];  	byte[] serialNumber = new byte[16];  	eeHeader.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common = eeHeader;  	// Calculate the size of our data structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	// Call FT_EEPROM_Read  	ftStatus = FT_EEPROM_Read (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	if (ftStatus == FT_STATUS.FT_OK) {  		// Get the data back from the pointer...  		eeData = (FT_XSERIES_DATA)Marshal.PtrToStructure (eeDataMarshal' typeof(FT_XSERIES_DATA));  		// Retrieve string values  		System.Text.UTF8Encoding enc = new System.Text.UTF8Encoding ();  		eeX.Manufacturer = enc.GetString (manufacturer);  		eeX.ManufacturerID = enc.GetString (manufacturerID);  		eeX.Description = enc.GetString (description);  		eeX.SerialNumber = enc.GetString (serialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeX.VendorID = eeData.common.VendorId;  		eeX.ProductID = eeData.common.ProductId;  		eeX.MaxPower = eeData.common.MaxPower;  		eeX.SelfPowered = Convert.ToBoolean (eeData.common.SelfPowered);  		eeX.RemoteWakeup = Convert.ToBoolean (eeData.common.RemoteWakeup);  		eeX.SerNumEnable = Convert.ToBoolean (eeData.common.SerNumEnable);  		eeX.PullDownEnable = Convert.ToBoolean (eeData.common.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeX.Cbus0 = eeData.Cbus0;  		eeX.Cbus1 = eeData.Cbus1;  		eeX.Cbus2 = eeData.Cbus2;  		eeX.Cbus3 = eeData.Cbus3;  		eeX.Cbus4 = eeData.Cbus4;  		eeX.Cbus5 = eeData.Cbus5;  		eeX.Cbus6 = eeData.Cbus6;  		// Drive Options  		eeX.ACDriveCurrent = eeData.ACDriveCurrent;  		eeX.ACSchmittInput = eeData.ACSchmittInput;  		eeX.ACSlowSlew = eeData.ACSlowSlew;  		eeX.ADDriveCurrent = eeData.ADDriveCurrent;  		eeX.ADSchmittInput = eeData.ADSchmittInput;  		eeX.ADSlowSlew = eeData.ADSlowSlew;  		// BCD  		eeX.BCDDisableSleep = eeData.BCDDisableSleep;  		eeX.BCDEnable = eeData.BCDEnable;  		eeX.BCDForceCbusPWREN = eeData.BCDForceCbusPWREN;  		// FT1248  		eeX.FT1248Cpol = eeData.FT1248Cpol;  		eeX.FT1248FlowControl = eeData.FT1248FlowControl;  		eeX.FT1248Lsb = eeData.FT1248Lsb;  		// I2C  		eeX.I2CDeviceId = eeData.I2CDeviceId;  		eeX.I2CDisableSchmitt = eeData.I2CDisableSchmitt;  		eeX.I2CSlaveAddress = eeData.I2CSlaveAddress;  		// RS232 Signals  		eeX.InvertCTS = eeData.InvertCTS;  		eeX.InvertDCD = eeData.InvertDCD;  		eeX.InvertDSR = eeData.InvertDSR;  		eeX.InvertDTR = eeData.InvertDTR;  		eeX.InvertRI = eeData.InvertRI;  		eeX.InvertRTS = eeData.InvertRTS;  		eeX.InvertRXD = eeData.InvertRXD;  		eeX.InvertTXD = eeData.InvertTXD;  		// Hardware Options  		eeX.PowerSaveEnable = eeData.PowerSaveEnable;  		eeX.RS485EchoSuppress = eeData.RS485EchoSuppress;  		// Driver Option  		eeX.IsVCP = eeData.DriverType;  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232B or FT245B that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232b.Manufacturer.Length > 32)  			ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  		if (ee232b.ManufacturerID.Length > 16)  			ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  		if (ee232b.Description.Length > 64)  			ee232b.Description = ee232b.Description.Substring (0' 64);  		if (ee232b.SerialNumber.Length > 16)  			ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232b.VendorID;  		eedata.ProductID = ee232b.ProductID;  		eedata.MaxPower = ee232b.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  		// B specific fields  		eedata.Rev4 = Convert.ToByte (true);  		eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  		eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  		eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  		eedata.USBVersion = ee232b.USBVersion;  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232B or FT245B that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_BM) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232b.VendorID == 0x0000) | (ee232b.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232b.Manufacturer.Length > 32)  		ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  	if (ee232b.ManufacturerID.Length > 16)  		ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  	if (ee232b.Description.Length > 64)  		ee232b.Description = ee232b.Description.Substring (0' 64);  	if (ee232b.SerialNumber.Length > 16)  		ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232b.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232b.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232b.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232b.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232b.VendorID;  	eedata.ProductID = ee232b.ProductID;  	eedata.MaxPower = ee232b.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232b.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232b.RemoteWakeup);  	// B specific fields  	eedata.Rev4 = Convert.ToByte (true);  	eedata.PullDownEnable = Convert.ToByte (ee232b.PullDownEnable);  	eedata.SerNumEnable = Convert.ToByte (ee232b.SerNumEnable);  	eedata.USBVersionEnable = Convert.ToByte (ee232b.USBVersionEnable);  	eedata.USBVersion = ee232b.USBVersion;  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.Manufacturer.Length > 32)  	ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.Manufacturer.Length > 32)  	ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: ee232b.Manufacturer = ee232b.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.ManufacturerID.Length > 16)  	ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.ManufacturerID.Length > 16)  	ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: ee232b.ManufacturerID = ee232b.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.Description.Length > 64)  	ee232b.Description = ee232b.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.Description.Length > 64)  	ee232b.Description = ee232b.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: ee232b.Description = ee232b.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.SerialNumber.Length > 16)  	ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: if (ee232b.SerialNumber.Length > 16)  	ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232BEEPROM,The following statement contains a magic number: ee232b.SerialNumber = ee232b.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232 that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232.Manufacturer.Length > 32)  			ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  		if (ee2232.ManufacturerID.Length > 16)  			ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  		if (ee2232.Description.Length > 64)  			ee2232.Description = ee2232.Description.Substring (0' 64);  		if (ee2232.SerialNumber.Length > 16)  			ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232.VendorID;  		eedata.ProductID = ee2232.ProductID;  		eedata.MaxPower = ee2232.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  		// 2232 specific fields  		eedata.Rev5 = Convert.ToByte (true);  		eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  		eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  		eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  		eedata.USBVersion5 = ee2232.USBVersion;  		eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  		eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  		eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  		eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  		eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  		eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  		eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  		eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  		eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  		eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232 that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232.VendorID == 0x0000) | (ee2232.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232.Manufacturer.Length > 32)  		ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  	if (ee2232.ManufacturerID.Length > 16)  		ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  	if (ee2232.Description.Length > 64)  		ee2232.Description = ee2232.Description.Substring (0' 64);  	if (ee2232.SerialNumber.Length > 16)  		ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232.VendorID;  	eedata.ProductID = ee2232.ProductID;  	eedata.MaxPower = ee2232.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232.RemoteWakeup);  	// 2232 specific fields  	eedata.Rev5 = Convert.ToByte (true);  	eedata.PullDownEnable5 = Convert.ToByte (ee2232.PullDownEnable);  	eedata.SerNumEnable5 = Convert.ToByte (ee2232.SerNumEnable);  	eedata.USBVersionEnable5 = Convert.ToByte (ee2232.USBVersionEnable);  	eedata.USBVersion5 = ee2232.USBVersion;  	eedata.AIsHighCurrent = Convert.ToByte (ee2232.AIsHighCurrent);  	eedata.BIsHighCurrent = Convert.ToByte (ee2232.BIsHighCurrent);  	eedata.IFAIsFifo = Convert.ToByte (ee2232.IFAIsFifo);  	eedata.IFAIsFifoTar = Convert.ToByte (ee2232.IFAIsFifoTar);  	eedata.IFAIsFastSer = Convert.ToByte (ee2232.IFAIsFastSer);  	eedata.AIsVCP = Convert.ToByte (ee2232.AIsVCP);  	eedata.IFBIsFifo = Convert.ToByte (ee2232.IFBIsFifo);  	eedata.IFBIsFifoTar = Convert.ToByte (ee2232.IFBIsFifoTar);  	eedata.IFBIsFastSer = Convert.ToByte (ee2232.IFBIsFastSer);  	eedata.BIsVCP = Convert.ToByte (ee2232.BIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.Manufacturer.Length > 32)  	ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.Manufacturer.Length > 32)  	ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: ee2232.Manufacturer = ee2232.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.ManufacturerID.Length > 16)  	ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.ManufacturerID.Length > 16)  	ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: ee2232.ManufacturerID = ee2232.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.Description.Length > 64)  	ee2232.Description = ee2232.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.Description.Length > 64)  	ee2232.Description = ee2232.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: ee2232.Description = ee2232.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.SerialNumber.Length > 16)  	ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: if (ee2232.SerialNumber.Length > 16)  	ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232EEPROM,The following statement contains a magic number: ee2232.SerialNumber = ee2232.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232R or FT245R that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 2;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232r.Manufacturer.Length > 32)  			ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  		if (ee232r.ManufacturerID.Length > 16)  			ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  		if (ee232r.Description.Length > 64)  			ee232r.Description = ee232r.Description.Substring (0' 64);  		if (ee232r.SerialNumber.Length > 16)  			ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232r.VendorID;  		eedata.ProductID = ee232r.ProductID;  		eedata.MaxPower = ee232r.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  		// 232R specific fields  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  		eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  		// Override any endpoint size the user has selected and force 64 bytes  		// Some users have been known to wreck devices by setting 0 here...  		eedata.EndpointSize = 64;  		eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  		eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  		eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  		eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  		eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  		eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  		eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  		eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  		eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  		eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  		eedata.Cbus0 = ee232r.Cbus0;  		eedata.Cbus1 = ee232r.Cbus1;  		eedata.Cbus2 = ee232r.Cbus2;  		eedata.Cbus3 = ee232r.Cbus3;  		eedata.Cbus4 = ee232r.Cbus4;  		eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232R or FT245R that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232R) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232r.VendorID == 0x0000) | (ee232r.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 2;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232r.Manufacturer.Length > 32)  		ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  	if (ee232r.ManufacturerID.Length > 16)  		ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  	if (ee232r.Description.Length > 64)  		ee232r.Description = ee232r.Description.Substring (0' 64);  	if (ee232r.SerialNumber.Length > 16)  		ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232r.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232r.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232r.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232r.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232r.VendorID;  	eedata.ProductID = ee232r.ProductID;  	eedata.MaxPower = ee232r.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232r.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232r.RemoteWakeup);  	// 232R specific fields  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.UseExtOsc = Convert.ToByte (ee232r.UseExtOsc);  	eedata.HighDriveIOs = Convert.ToByte (ee232r.HighDriveIOs);  	// Override any endpoint size the user has selected and force 64 bytes  	// Some users have been known to wreck devices by setting 0 here...  	eedata.EndpointSize = 64;  	eedata.PullDownEnableR = Convert.ToByte (ee232r.PullDownEnable);  	eedata.SerNumEnableR = Convert.ToByte (ee232r.SerNumEnable);  	eedata.InvertTXD = Convert.ToByte (ee232r.InvertTXD);  	eedata.InvertRXD = Convert.ToByte (ee232r.InvertRXD);  	eedata.InvertRTS = Convert.ToByte (ee232r.InvertRTS);  	eedata.InvertCTS = Convert.ToByte (ee232r.InvertCTS);  	eedata.InvertDTR = Convert.ToByte (ee232r.InvertDTR);  	eedata.InvertDSR = Convert.ToByte (ee232r.InvertDSR);  	eedata.InvertDCD = Convert.ToByte (ee232r.InvertDCD);  	eedata.InvertRI = Convert.ToByte (ee232r.InvertRI);  	eedata.Cbus0 = ee232r.Cbus0;  	eedata.Cbus1 = ee232r.Cbus1;  	eedata.Cbus2 = ee232r.Cbus2;  	eedata.Cbus3 = ee232r.Cbus3;  	eedata.Cbus4 = ee232r.Cbus4;  	eedata.RIsD2XX = Convert.ToByte (ee232r.RIsD2XX);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.Version = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.Manufacturer.Length > 32)  	ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.Manufacturer.Length > 32)  	ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: ee232r.Manufacturer = ee232r.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.ManufacturerID.Length > 16)  	ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.ManufacturerID.Length > 16)  	ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: ee232r.ManufacturerID = ee232r.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.Description.Length > 64)  	ee232r.Description = ee232r.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.Description.Length > 64)  	ee232r.Description = ee232r.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: ee232r.Description = ee232r.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.SerialNumber.Length > 16)  	ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: if (ee232r.SerialNumber.Length > 16)  	ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: ee232r.SerialNumber = ee232r.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232REEPROM,The following statement contains a magic number: eedata.EndpointSize = 64;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT2232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 3;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee2232h.Manufacturer.Length > 32)  			ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  		if (ee2232h.ManufacturerID.Length > 16)  			ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  		if (ee2232h.Description.Length > 64)  			ee2232h.Description = ee2232h.Description.Substring (0' 64);  		if (ee2232h.SerialNumber.Length > 16)  			ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee2232h.VendorID;  		eedata.ProductID = ee2232h.ProductID;  		eedata.MaxPower = ee2232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  		// 2232H specific fields  		eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  		eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  		eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  		eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  		eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  		eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  		eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  		eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  		eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  		eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  		eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  		eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  		eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  		eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  		eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  		eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  		eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  		eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  		eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  		eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  		eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  		eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  		eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT2232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_2232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee2232h.VendorID == 0x0000) | (ee2232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 3;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee2232h.Manufacturer.Length > 32)  		ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  	if (ee2232h.ManufacturerID.Length > 16)  		ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  	if (ee2232h.Description.Length > 64)  		ee2232h.Description = ee2232h.Description.Substring (0' 64);  	if (ee2232h.SerialNumber.Length > 16)  		ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee2232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee2232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee2232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee2232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee2232h.VendorID;  	eedata.ProductID = ee2232h.ProductID;  	eedata.MaxPower = ee2232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee2232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee2232h.RemoteWakeup);  	// 2232H specific fields  	eedata.PullDownEnable7 = Convert.ToByte (ee2232h.PullDownEnable);  	eedata.SerNumEnable7 = Convert.ToByte (ee2232h.SerNumEnable);  	eedata.ALSlowSlew = Convert.ToByte (ee2232h.ALSlowSlew);  	eedata.ALSchmittInput = Convert.ToByte (ee2232h.ALSchmittInput);  	eedata.ALDriveCurrent = ee2232h.ALDriveCurrent;  	eedata.AHSlowSlew = Convert.ToByte (ee2232h.AHSlowSlew);  	eedata.AHSchmittInput = Convert.ToByte (ee2232h.AHSchmittInput);  	eedata.AHDriveCurrent = ee2232h.AHDriveCurrent;  	eedata.BLSlowSlew = Convert.ToByte (ee2232h.BLSlowSlew);  	eedata.BLSchmittInput = Convert.ToByte (ee2232h.BLSchmittInput);  	eedata.BLDriveCurrent = ee2232h.BLDriveCurrent;  	eedata.BHSlowSlew = Convert.ToByte (ee2232h.BHSlowSlew);  	eedata.BHSchmittInput = Convert.ToByte (ee2232h.BHSchmittInput);  	eedata.BHDriveCurrent = ee2232h.BHDriveCurrent;  	eedata.IFAIsFifo7 = Convert.ToByte (ee2232h.IFAIsFifo);  	eedata.IFAIsFifoTar7 = Convert.ToByte (ee2232h.IFAIsFifoTar);  	eedata.IFAIsFastSer7 = Convert.ToByte (ee2232h.IFAIsFastSer);  	eedata.AIsVCP7 = Convert.ToByte (ee2232h.AIsVCP);  	eedata.IFBIsFifo7 = Convert.ToByte (ee2232h.IFBIsFifo);  	eedata.IFBIsFifoTar7 = Convert.ToByte (ee2232h.IFBIsFifoTar);  	eedata.IFBIsFastSer7 = Convert.ToByte (ee2232h.IFBIsFastSer);  	eedata.BIsVCP7 = Convert.ToByte (ee2232h.BIsVCP);  	eedata.PowerSaveEnable = Convert.ToByte (ee2232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: eedata.Version = 3;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.Manufacturer.Length > 32)  	ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.Manufacturer.Length > 32)  	ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: ee2232h.Manufacturer = ee2232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.ManufacturerID.Length > 16)  	ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.ManufacturerID.Length > 16)  	ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: ee2232h.ManufacturerID = ee2232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.Description.Length > 64)  	ee2232h.Description = ee2232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.Description.Length > 64)  	ee2232h.Description = ee2232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: ee2232h.Description = ee2232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.SerialNumber.Length > 16)  	ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: if (ee2232h.SerialNumber.Length > 16)  	ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT2232HEEPROM,The following statement contains a magic number: ee2232h.SerialNumber = ee2232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT4232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 4;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee4232h.Manufacturer.Length > 32)  			ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  		if (ee4232h.ManufacturerID.Length > 16)  			ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  		if (ee4232h.Description.Length > 64)  			ee4232h.Description = ee4232h.Description.Substring (0' 64);  		if (ee4232h.SerialNumber.Length > 16)  			ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee4232h.VendorID;  		eedata.ProductID = ee4232h.ProductID;  		eedata.MaxPower = ee4232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  		// 4232H specific fields  		eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  		eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  		eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  		eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  		eedata.ADriveCurrent = ee4232h.ADriveCurrent;  		eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  		eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  		eedata.BDriveCurrent = ee4232h.BDriveCurrent;  		eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  		eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  		eedata.CDriveCurrent = ee4232h.CDriveCurrent;  		eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  		eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  		eedata.DDriveCurrent = ee4232h.DDriveCurrent;  		eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  		eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  		eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  		eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  		eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  		eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  		eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  		eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT4232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_4232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee4232h.VendorID == 0x0000) | (ee4232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 4;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee4232h.Manufacturer.Length > 32)  		ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  	if (ee4232h.ManufacturerID.Length > 16)  		ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  	if (ee4232h.Description.Length > 64)  		ee4232h.Description = ee4232h.Description.Substring (0' 64);  	if (ee4232h.SerialNumber.Length > 16)  		ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee4232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee4232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee4232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee4232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee4232h.VendorID;  	eedata.ProductID = ee4232h.ProductID;  	eedata.MaxPower = ee4232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee4232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee4232h.RemoteWakeup);  	// 4232H specific fields  	eedata.PullDownEnable8 = Convert.ToByte (ee4232h.PullDownEnable);  	eedata.SerNumEnable8 = Convert.ToByte (ee4232h.SerNumEnable);  	eedata.ASlowSlew = Convert.ToByte (ee4232h.ASlowSlew);  	eedata.ASchmittInput = Convert.ToByte (ee4232h.ASchmittInput);  	eedata.ADriveCurrent = ee4232h.ADriveCurrent;  	eedata.BSlowSlew = Convert.ToByte (ee4232h.BSlowSlew);  	eedata.BSchmittInput = Convert.ToByte (ee4232h.BSchmittInput);  	eedata.BDriveCurrent = ee4232h.BDriveCurrent;  	eedata.CSlowSlew = Convert.ToByte (ee4232h.CSlowSlew);  	eedata.CSchmittInput = Convert.ToByte (ee4232h.CSchmittInput);  	eedata.CDriveCurrent = ee4232h.CDriveCurrent;  	eedata.DSlowSlew = Convert.ToByte (ee4232h.DSlowSlew);  	eedata.DSchmittInput = Convert.ToByte (ee4232h.DSchmittInput);  	eedata.DDriveCurrent = ee4232h.DDriveCurrent;  	eedata.ARIIsTXDEN = Convert.ToByte (ee4232h.ARIIsTXDEN);  	eedata.BRIIsTXDEN = Convert.ToByte (ee4232h.BRIIsTXDEN);  	eedata.CRIIsTXDEN = Convert.ToByte (ee4232h.CRIIsTXDEN);  	eedata.DRIIsTXDEN = Convert.ToByte (ee4232h.DRIIsTXDEN);  	eedata.AIsVCP8 = Convert.ToByte (ee4232h.AIsVCP);  	eedata.BIsVCP8 = Convert.ToByte (ee4232h.BIsVCP);  	eedata.CIsVCP8 = Convert.ToByte (ee4232h.CIsVCP);  	eedata.DIsVCP8 = Convert.ToByte (ee4232h.DIsVCP);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: eedata.Version = 4;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.Manufacturer.Length > 32)  	ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.Manufacturer.Length > 32)  	ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: ee4232h.Manufacturer = ee4232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.ManufacturerID.Length > 16)  	ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.ManufacturerID.Length > 16)  	ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: ee4232h.ManufacturerID = ee4232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.Description.Length > 64)  	ee4232h.Description = ee4232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.Description.Length > 64)  	ee4232h.Description = ee4232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: ee4232h.Description = ee4232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.SerialNumber.Length > 16)  	ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: if (ee4232h.SerialNumber.Length > 16)  	ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT4232HEEPROM,The following statement contains a magic number: ee4232h.SerialNumber = ee4232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (pFT_EE_Program != IntPtr.Zero) {  	tFT_EE_Program FT_EE_Program = (tFT_EE_Program)Marshal.GetDelegateForFunctionPointer (pFT_EE_Program' typeof(tFT_EE_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  		// Set up structure headers  		eedata.Signature1 = 0x00000000;  		eedata.Signature2 = 0xFFFFFFFF;  		eedata.Version = 5;  		// Allocate space from unmanaged heap  		eedata.Manufacturer = Marshal.AllocHGlobal (32);  		eedata.ManufacturerID = Marshal.AllocHGlobal (16);  		eedata.Description = Marshal.AllocHGlobal (64);  		eedata.SerialNumber = Marshal.AllocHGlobal (16);  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (ee232h.Manufacturer.Length > 32)  			ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  		if (ee232h.ManufacturerID.Length > 16)  			ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  		if (ee232h.Description.Length > 64)  			ee232h.Description = ee232h.Description.Substring (0' 64);  		if (ee232h.SerialNumber.Length > 16)  			ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  		// Set string values  		eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  		eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  		eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  		eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  		// Map non-string elements to structure  		// Standard elements  		eedata.VendorID = ee232h.VendorID;  		eedata.ProductID = ee232h.ProductID;  		eedata.MaxPower = ee232h.MaxPower;  		eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  		eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  		// 232H specific fields  		eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  		eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  		eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  		eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  		eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  		eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  		eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  		eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  		eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  		eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  		eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  		eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  		eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  		eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  		eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  		eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  		eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  		eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  		eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  		eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  		eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  		eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  		eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  		eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  		eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  		eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  		eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  		// Call FT_EE_Program  		ftStatus = FT_EE_Program (ftHandle' eedata);  		// Free unmanaged buffers  		Marshal.FreeHGlobal (eedata.Manufacturer);  		Marshal.FreeHGlobal (eedata.ManufacturerID);  		Marshal.FreeHGlobal (eedata.Description);  		Marshal.FreeHGlobal (eedata.SerialNumber);  	}  }  else {  	if (pFT_EE_Program == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_EE_Program.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_232H) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((ee232h.VendorID == 0x0000) | (ee232h.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_PROGRAM_DATA eedata = new FT_PROGRAM_DATA ();  	// Set up structure headers  	eedata.Signature1 = 0x00000000;  	eedata.Signature2 = 0xFFFFFFFF;  	eedata.Version = 5;  	// Allocate space from unmanaged heap  	eedata.Manufacturer = Marshal.AllocHGlobal (32);  	eedata.ManufacturerID = Marshal.AllocHGlobal (16);  	eedata.Description = Marshal.AllocHGlobal (64);  	eedata.SerialNumber = Marshal.AllocHGlobal (16);  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (ee232h.Manufacturer.Length > 32)  		ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  	if (ee232h.ManufacturerID.Length > 16)  		ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  	if (ee232h.Description.Length > 64)  		ee232h.Description = ee232h.Description.Substring (0' 64);  	if (ee232h.SerialNumber.Length > 16)  		ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  	// Set string values  	eedata.Manufacturer = Marshal.StringToHGlobalAnsi (ee232h.Manufacturer);  	eedata.ManufacturerID = Marshal.StringToHGlobalAnsi (ee232h.ManufacturerID);  	eedata.Description = Marshal.StringToHGlobalAnsi (ee232h.Description);  	eedata.SerialNumber = Marshal.StringToHGlobalAnsi (ee232h.SerialNumber);  	// Map non-string elements to structure  	// Standard elements  	eedata.VendorID = ee232h.VendorID;  	eedata.ProductID = ee232h.ProductID;  	eedata.MaxPower = ee232h.MaxPower;  	eedata.SelfPowered = Convert.ToUInt16 (ee232h.SelfPowered);  	eedata.RemoteWakeup = Convert.ToUInt16 (ee232h.RemoteWakeup);  	// 232H specific fields  	eedata.PullDownEnableH = Convert.ToByte (ee232h.PullDownEnable);  	eedata.SerNumEnableH = Convert.ToByte (ee232h.SerNumEnable);  	eedata.ACSlowSlewH = Convert.ToByte (ee232h.ACSlowSlew);  	eedata.ACSchmittInputH = Convert.ToByte (ee232h.ACSchmittInput);  	eedata.ACDriveCurrentH = Convert.ToByte (ee232h.ACDriveCurrent);  	eedata.ADSlowSlewH = Convert.ToByte (ee232h.ADSlowSlew);  	eedata.ADSchmittInputH = Convert.ToByte (ee232h.ADSchmittInput);  	eedata.ADDriveCurrentH = Convert.ToByte (ee232h.ADDriveCurrent);  	eedata.Cbus0H = Convert.ToByte (ee232h.Cbus0);  	eedata.Cbus1H = Convert.ToByte (ee232h.Cbus1);  	eedata.Cbus2H = Convert.ToByte (ee232h.Cbus2);  	eedata.Cbus3H = Convert.ToByte (ee232h.Cbus3);  	eedata.Cbus4H = Convert.ToByte (ee232h.Cbus4);  	eedata.Cbus5H = Convert.ToByte (ee232h.Cbus5);  	eedata.Cbus6H = Convert.ToByte (ee232h.Cbus6);  	eedata.Cbus7H = Convert.ToByte (ee232h.Cbus7);  	eedata.Cbus8H = Convert.ToByte (ee232h.Cbus8);  	eedata.Cbus9H = Convert.ToByte (ee232h.Cbus9);  	eedata.IsFifoH = Convert.ToByte (ee232h.IsFifo);  	eedata.IsFifoTarH = Convert.ToByte (ee232h.IsFifoTar);  	eedata.IsFastSerH = Convert.ToByte (ee232h.IsFastSer);  	eedata.IsFT1248H = Convert.ToByte (ee232h.IsFT1248);  	eedata.FT1248CpolH = Convert.ToByte (ee232h.FT1248Cpol);  	eedata.FT1248LsbH = Convert.ToByte (ee232h.FT1248Lsb);  	eedata.FT1248FlowControlH = Convert.ToByte (ee232h.FT1248FlowControl);  	eedata.IsVCPH = Convert.ToByte (ee232h.IsVCP);  	eedata.PowerSaveEnableH = Convert.ToByte (ee232h.PowerSaveEnable);  	// Call FT_EE_Program  	ftStatus = FT_EE_Program (ftHandle' eedata);  	// Free unmanaged buffers  	Marshal.FreeHGlobal (eedata.Manufacturer);  	Marshal.FreeHGlobal (eedata.ManufacturerID);  	Marshal.FreeHGlobal (eedata.Description);  	Marshal.FreeHGlobal (eedata.SerialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: eedata.Version = 5;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: eedata.Manufacturer = Marshal.AllocHGlobal (32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: eedata.ManufacturerID = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: eedata.Description = Marshal.AllocHGlobal (64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: eedata.SerialNumber = Marshal.AllocHGlobal (16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.Manufacturer.Length > 32)  	ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.Manufacturer.Length > 32)  	ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: ee232h.Manufacturer = ee232h.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.ManufacturerID.Length > 16)  	ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.ManufacturerID.Length > 16)  	ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: ee232h.ManufacturerID = ee232h.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.Description.Length > 64)  	ee232h.Description = ee232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.Description.Length > 64)  	ee232h.Description = ee232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: ee232h.Description = ee232h.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.SerialNumber.Length > 16)  	ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: if (ee232h.SerialNumber.Length > 16)  	ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteFT232HEEPROM,The following statement contains a magic number: ee232h.SerialNumber = ee232h.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (pFT_EEPROM_Program != IntPtr.Zero) {  	tFT_EEPROM_Program FT_EEPROM_Program = (tFT_EEPROM_Program)Marshal.GetDelegateForFunctionPointer (pFT_EEPROM_Program' typeof(tFT_EEPROM_Program));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Check that it is an FT232H that we are trying to write  		GetDeviceType (ref DeviceType);  		if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  			// If it is not' throw an exception  			ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  			ErrorHandler (ftStatus' ftErrorCondition);  		}  		// Check for VID and PID of 0x0000  		if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  			// Do not allow users to program the device with VID or PID of 0x0000  			return FT_STATUS.FT_INVALID_PARAMETER;  		}  		FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  		// String manipulation...  		// Allocate space from unmanaged heap  		manufacturer = new byte[32];  		manufacturerID = new byte[16];  		description = new byte[64];  		serialNumber = new byte[16];  		// Check lengths of strings to make sure that they are within our limits  		// If not' trim them to make them our maximum length  		if (eeX.Manufacturer.Length > 32)  			eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  		if (eeX.ManufacturerID.Length > 16)  			eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  		if (eeX.Description.Length > 64)  			eeX.Description = eeX.Description.Substring (0' 64);  		if (eeX.SerialNumber.Length > 16)  			eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  		// Set string values  		System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  		manufacturer = encoding.GetBytes (eeX.Manufacturer);  		manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  		description = encoding.GetBytes (eeX.Description);  		serialNumber = encoding.GetBytes (eeX.SerialNumber);  		// Map non-string elements to structure to be returned  		// Standard elements  		eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  		eeData.common.VendorId = eeX.VendorID;  		eeData.common.ProductId = eeX.ProductID;  		eeData.common.MaxPower = eeX.MaxPower;  		eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  		eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  		eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  		eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  		// X-Series specific fields  		// CBUS  		eeData.Cbus0 = eeX.Cbus0;  		eeData.Cbus1 = eeX.Cbus1;  		eeData.Cbus2 = eeX.Cbus2;  		eeData.Cbus3 = eeX.Cbus3;  		eeData.Cbus4 = eeX.Cbus4;  		eeData.Cbus5 = eeX.Cbus5;  		eeData.Cbus6 = eeX.Cbus6;  		// Drive Options  		eeData.ACDriveCurrent = eeX.ACDriveCurrent;  		eeData.ACSchmittInput = eeX.ACSchmittInput;  		eeData.ACSlowSlew = eeX.ACSlowSlew;  		eeData.ADDriveCurrent = eeX.ADDriveCurrent;  		eeData.ADSchmittInput = eeX.ADSchmittInput;  		eeData.ADSlowSlew = eeX.ADSlowSlew;  		// BCD  		eeData.BCDDisableSleep = eeX.BCDDisableSleep;  		eeData.BCDEnable = eeX.BCDEnable;  		eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  		// FT1248  		eeData.FT1248Cpol = eeX.FT1248Cpol;  		eeData.FT1248FlowControl = eeX.FT1248FlowControl;  		eeData.FT1248Lsb = eeX.FT1248Lsb;  		// I2C  		eeData.I2CDeviceId = eeX.I2CDeviceId;  		eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  		eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  		// RS232 Signals  		eeData.InvertCTS = eeX.InvertCTS;  		eeData.InvertDCD = eeX.InvertDCD;  		eeData.InvertDSR = eeX.InvertDSR;  		eeData.InvertDTR = eeX.InvertDTR;  		eeData.InvertRI = eeX.InvertRI;  		eeData.InvertRTS = eeX.InvertRTS;  		eeData.InvertRXD = eeX.InvertRXD;  		eeData.InvertTXD = eeX.InvertTXD;  		// Hardware Options  		eeData.PowerSaveEnable = eeX.PowerSaveEnable;  		eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  		// Driver Option  		eeData.DriverType = eeX.IsVCP;  		// Check the size of the structure...  		int size = Marshal.SizeOf (eeData);  		// Allocate space for our pointer...  		IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  		Marshal.StructureToPtr (eeData' eeDataMarshal' false);  		ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Check that it is an FT232H that we are trying to write  	GetDeviceType (ref DeviceType);  	if (DeviceType != FT_DEVICE.FT_DEVICE_X_SERIES) {  		// If it is not' throw an exception  		ftErrorCondition = FT_ERROR.FT_INCORRECT_DEVICE;  		ErrorHandler (ftStatus' ftErrorCondition);  	}  	// Check for VID and PID of 0x0000  	if ((eeX.VendorID == 0x0000) | (eeX.ProductID == 0x0000)) {  		// Do not allow users to program the device with VID or PID of 0x0000  		return FT_STATUS.FT_INVALID_PARAMETER;  	}  	FT_XSERIES_DATA eeData = new FT_XSERIES_DATA ();  	// String manipulation...  	// Allocate space from unmanaged heap  	manufacturer = new byte[32];  	manufacturerID = new byte[16];  	description = new byte[64];  	serialNumber = new byte[16];  	// Check lengths of strings to make sure that they are within our limits  	// If not' trim them to make them our maximum length  	if (eeX.Manufacturer.Length > 32)  		eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  	if (eeX.ManufacturerID.Length > 16)  		eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  	if (eeX.Description.Length > 64)  		eeX.Description = eeX.Description.Substring (0' 64);  	if (eeX.SerialNumber.Length > 16)  		eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  	// Set string values  	System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding ();  	manufacturer = encoding.GetBytes (eeX.Manufacturer);  	manufacturerID = encoding.GetBytes (eeX.ManufacturerID);  	description = encoding.GetBytes (eeX.Description);  	serialNumber = encoding.GetBytes (eeX.SerialNumber);  	// Map non-string elements to structure to be returned  	// Standard elements  	eeData.common.deviceType = (uint)FT_DEVICE.FT_DEVICE_X_SERIES;  	eeData.common.VendorId = eeX.VendorID;  	eeData.common.ProductId = eeX.ProductID;  	eeData.common.MaxPower = eeX.MaxPower;  	eeData.common.SelfPowered = Convert.ToByte (eeX.SelfPowered);  	eeData.common.RemoteWakeup = Convert.ToByte (eeX.RemoteWakeup);  	eeData.common.SerNumEnable = Convert.ToByte (eeX.SerNumEnable);  	eeData.common.PullDownEnable = Convert.ToByte (eeX.PullDownEnable);  	// X-Series specific fields  	// CBUS  	eeData.Cbus0 = eeX.Cbus0;  	eeData.Cbus1 = eeX.Cbus1;  	eeData.Cbus2 = eeX.Cbus2;  	eeData.Cbus3 = eeX.Cbus3;  	eeData.Cbus4 = eeX.Cbus4;  	eeData.Cbus5 = eeX.Cbus5;  	eeData.Cbus6 = eeX.Cbus6;  	// Drive Options  	eeData.ACDriveCurrent = eeX.ACDriveCurrent;  	eeData.ACSchmittInput = eeX.ACSchmittInput;  	eeData.ACSlowSlew = eeX.ACSlowSlew;  	eeData.ADDriveCurrent = eeX.ADDriveCurrent;  	eeData.ADSchmittInput = eeX.ADSchmittInput;  	eeData.ADSlowSlew = eeX.ADSlowSlew;  	// BCD  	eeData.BCDDisableSleep = eeX.BCDDisableSleep;  	eeData.BCDEnable = eeX.BCDEnable;  	eeData.BCDForceCbusPWREN = eeX.BCDForceCbusPWREN;  	// FT1248  	eeData.FT1248Cpol = eeX.FT1248Cpol;  	eeData.FT1248FlowControl = eeX.FT1248FlowControl;  	eeData.FT1248Lsb = eeX.FT1248Lsb;  	// I2C  	eeData.I2CDeviceId = eeX.I2CDeviceId;  	eeData.I2CDisableSchmitt = eeX.I2CDisableSchmitt;  	eeData.I2CSlaveAddress = eeX.I2CSlaveAddress;  	// RS232 Signals  	eeData.InvertCTS = eeX.InvertCTS;  	eeData.InvertDCD = eeX.InvertDCD;  	eeData.InvertDSR = eeX.InvertDSR;  	eeData.InvertDTR = eeX.InvertDTR;  	eeData.InvertRI = eeX.InvertRI;  	eeData.InvertRTS = eeX.InvertRTS;  	eeData.InvertRXD = eeX.InvertRXD;  	eeData.InvertTXD = eeX.InvertTXD;  	// Hardware Options  	eeData.PowerSaveEnable = eeX.PowerSaveEnable;  	eeData.RS485EchoSuppress = eeX.RS485EchoSuppress;  	// Driver Option  	eeData.DriverType = eeX.IsVCP;  	// Check the size of the structure...  	int size = Marshal.SizeOf (eeData);  	// Allocate space for our pointer...  	IntPtr eeDataMarshal = Marshal.AllocHGlobal (size);  	Marshal.StructureToPtr (eeData' eeDataMarshal' false);  	ftStatus = FT_EEPROM_Program (ftHandle' eeDataMarshal' (uint)size' manufacturer' manufacturerID' description' serialNumber);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: manufacturer = new byte[32];  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: manufacturerID = new byte[16];  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: description = new byte[64];  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: serialNumber = new byte[16];  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.Manufacturer.Length > 32)  	eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.Manufacturer.Length > 32)  	eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: eeX.Manufacturer = eeX.Manufacturer.Substring (0' 32);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.ManufacturerID.Length > 16)  	eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.ManufacturerID.Length > 16)  	eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: eeX.ManufacturerID = eeX.ManufacturerID.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.Description.Length > 64)  	eeX.Description = eeX.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.Description.Length > 64)  	eeX.Description = eeX.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: eeX.Description = eeX.Description.Substring (0' 64);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.SerialNumber.Length > 16)  	eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: if (eeX.SerialNumber.Length > 16)  	eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,WriteXSeriesEEPROM,The following statement contains a magic number: eeX.SerialNumber = eeX.SerialNumber.Substring (0' 16);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceType,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceType,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceID,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDeviceID,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDescription,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  		Description = Encoding.ASCII.GetString (desc);  		Description = Description.Substring (0' Description.IndexOf ("\0"));  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetDescription,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  		Description = Encoding.ASCII.GetString (desc);  		Description = Description.Substring (0' Description.IndexOf ("\0"));  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetSerialNumber,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  		SerialNumber = Encoding.ASCII.GetString (sernum);  		SerialNumber = SerialNumber.Substring (0' SerialNumber.IndexOf ("\0"));  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetSerialNumber,The following statement contains a magic number: if (pFT_GetDeviceInfo != IntPtr.Zero) {  	tFT_GetDeviceInfo FT_GetDeviceInfo = (tFT_GetDeviceInfo)Marshal.GetDelegateForFunctionPointer (pFT_GetDeviceInfo' typeof(tFT_GetDeviceInfo));  	UInt32 DeviceID = 0;  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	byte[] sernum = new byte[16];  	byte[] desc = new byte[64];  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetDeviceInfo  		ftStatus = FT_GetDeviceInfo (ftHandle' ref DeviceType' ref DeviceID' sernum' desc' IntPtr.Zero);  		SerialNumber = Encoding.ASCII.GetString (sernum);  		SerialNumber = SerialNumber.Substring (0' SerialNumber.IndexOf ("\0"));  	}  }  else {  	if (pFT_GetDeviceInfo == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetDeviceInfo.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetLineStatus,The following statement contains a magic number: if (pFT_GetModemStatus != IntPtr.Zero) {  	tFT_GetModemStatus FT_GetModemStatus = (tFT_GetModemStatus)Marshal.GetDelegateForFunctionPointer (pFT_GetModemStatus' typeof(tFT_GetModemStatus));  	UInt32 ModemLineStatus = 0;  	if (ftHandle != IntPtr.Zero) {  		// Call FT_GetModemStatus  		ftStatus = FT_GetModemStatus (ftHandle' ref ModemLineStatus);  	}  	LineStatus = Convert.ToByte ((ModemLineStatus >> 8) & 0x000000FF);  }  else {  	if (pFT_GetModemStatus == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_GetModemStatus.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,GetLineStatus,The following statement contains a magic number: LineStatus = Convert.ToByte ((ModemLineStatus >> 8) & 0x000000FF);  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (pFT_SetLatencyTimer != IntPtr.Zero) {  	tFT_SetLatencyTimer FT_SetLatencyTimer = (tFT_SetLatencyTimer)Marshal.GetDelegateForFunctionPointer (pFT_SetLatencyTimer' typeof(tFT_SetLatencyTimer));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Set Bit Mode does not apply to FT8U232AM' FT8U245AM or FT8U100AX devices  		GetDeviceType (ref DeviceType);  		if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  			// Do not allow latency of 1ms or 0ms for older devices  			// since this can cause problems/lock up due to buffering mechanism  			if (Latency < 2)  				Latency = 2;  		}  		// Call FT_SetLatencyTimer  		ftStatus = FT_SetLatencyTimer (ftHandle' Latency);  	}  }  else {  	if (pFT_SetLatencyTimer == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetLatencyTimer.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (pFT_SetLatencyTimer != IntPtr.Zero) {  	tFT_SetLatencyTimer FT_SetLatencyTimer = (tFT_SetLatencyTimer)Marshal.GetDelegateForFunctionPointer (pFT_SetLatencyTimer' typeof(tFT_SetLatencyTimer));  	if (ftHandle != IntPtr.Zero) {  		FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  		// Set Bit Mode does not apply to FT8U232AM' FT8U245AM or FT8U100AX devices  		GetDeviceType (ref DeviceType);  		if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  			// Do not allow latency of 1ms or 0ms for older devices  			// since this can cause problems/lock up due to buffering mechanism  			if (Latency < 2)  				Latency = 2;  		}  		// Call FT_SetLatencyTimer  		ftStatus = FT_SetLatencyTimer (ftHandle' Latency);  	}  }  else {  	if (pFT_SetLatencyTimer == IntPtr.Zero) {  		MessageBox.Show ("Failed to load function FT_SetLatencyTimer.");  	}  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Set Bit Mode does not apply to FT8U232AM' FT8U245AM or FT8U100AX devices  	GetDeviceType (ref DeviceType);  	if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  		// Do not allow latency of 1ms or 0ms for older devices  		// since this can cause problems/lock up due to buffering mechanism  		if (Latency < 2)  			Latency = 2;  	}  	// Call FT_SetLatencyTimer  	ftStatus = FT_SetLatencyTimer (ftHandle' Latency);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (ftHandle != IntPtr.Zero) {  	FT_DEVICE DeviceType = FT_DEVICE.FT_DEVICE_UNKNOWN;  	// Set Bit Mode does not apply to FT8U232AM' FT8U245AM or FT8U100AX devices  	GetDeviceType (ref DeviceType);  	if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  		// Do not allow latency of 1ms or 0ms for older devices  		// since this can cause problems/lock up due to buffering mechanism  		if (Latency < 2)  			Latency = 2;  	}  	// Call FT_SetLatencyTimer  	ftStatus = FT_SetLatencyTimer (ftHandle' Latency);  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  	// Do not allow latency of 1ms or 0ms for older devices  	// since this can cause problems/lock up due to buffering mechanism  	if (Latency < 2)  		Latency = 2;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if ((DeviceType == FT_DEVICE.FT_DEVICE_BM) || (DeviceType == FT_DEVICE.FT_DEVICE_2232)) {  	// Do not allow latency of 1ms or 0ms for older devices  	// since this can cause problems/lock up due to buffering mechanism  	if (Latency < 2)  		Latency = 2;  }  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (Latency < 2)  	Latency = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: if (Latency < 2)  	Latency = 2;  
Magic Number,FTD2XX_NET,FTDI,C:\repos\x893_SX1231\FTD2XX_NET\FTDI.cs,SetLatency,The following statement contains a magic number: Latency = 2;  
