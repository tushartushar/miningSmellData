Implementation smell,Namespace,Class,File,Method,Description
Complex Method,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,DealWithMcid,Cyclomatic complexity of the method is 19
Complex Method,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,ConvertToXObject,Cyclomatic complexity of the method is 11
Complex Method,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,StructureItems,Cyclomatic complexity of the method is 11
Complex Method,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,ProcessStructElemKids,Cyclomatic complexity of the method is 16
Complex Method,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,Cyclomatic complexity of the method is 15
Complex Method,iTextSharp.text.pdf.ocg,OCGRemover,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGRemover.cs,RemoveLayers,Cyclomatic complexity of the method is 9
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,Cyclomatic complexity of the method is 19
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,WriteTextChunks,Cyclomatic complexity of the method is 8
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DrawOverlayText,Cyclomatic complexity of the method is 9
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ParseDAParam,Cyclomatic complexity of the method is 14
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,Cyclomatic complexity of the method is 9
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,Cyclomatic complexity of the method is 9
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,Cyclomatic complexity of the method is 21
Complex Method,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ProcessImage,Cyclomatic complexity of the method is 8
Complex Method,iTextSharp.text.pdf.util,PdfResourceCounter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\util\PdfResourceCounter.cs,LoopOver,Cyclomatic complexity of the method is 13
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,WriteTextChunks,The method has 7 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,GetUnscaledTextChunkWidth,The method has 5 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,InsertFormXObj,The method has 5 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DrawOverlayText,The method has 6 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,FilterStrokePath,The method has 7 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ApplyDash,The method has 5 parameters.
Long Parameter List,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,FilterCurrentPath,The method has 8 parameters.
Long Parameter List,iTextSharp.text.pdf.spatial.objects,NumberFormatArray,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\spatial\objects\NumberFormatArray.cs,NumberFormatArray,The method has 5 parameters.
Long Parameter List,iTextSharp.text.pdf.spatial.objects,NumberFormatArray,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\spatial\objects\NumberFormatArray.cs,NumberFormatArray,The method has 6 parameters.
Long Statement,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,Parse,The length of the statement  "				throw new DocumentException (MessageLocalization.GetComposedMessage ("could.not.flatten.file.untagged.annotations.found")); " is 123.
Long Statement,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,ConvertToXObject,The length of the statement  "	Rectangle rect = new Rectangle (array.GetAsNumber (0).FloatValue' array.GetAsNumber (1).FloatValue' array.GetAsNumber (2).FloatValue' array.GetAsNumber (3).FloatValue); " is 168.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The length of the statement  "	bool disableOutput = pathConstructionOperators.Contains (operatorStr) || pathPaintingOperators.Contains (operatorStr) || clippingPathOperators.Contains (operatorStr); " is 166.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The length of the statement  "	// key - number of a string in the TJ operator' value - number following the string; the first number without string (if it's presented) is stored under 0. " is 155.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The length of the statement  "				if (xObj is PRStream && xObj.GetAsName (PdfName.SUBTYPE) != null && xObj.GetAsName (PdfName.SUBTYPE).CompareTo (PdfName.FORM) == 0) { " is 133.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The length of the statement  "		WriteTextChunks (structuredTJoperands' chunks' canvas' gs.CharacterSpacing' gs.WordSpacing' gs.FontSize' gs.HorizontalScaling); " is 127.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,WriteTextChunks,The length of the statement  "		if (prevChunk != null && prevChunk.NumOfStrTextBelongsTo != textChunk.NumOfStrTextBelongsTo && structuredTJoperands != null) { " is 126.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,GetUnscaledTextChunkWidth,The length of the statement  "	float scaledChunkWidth = (chunk.EndX - chunk.StartX) * 100f + (characterSpacing + (IsSpace (chunk) ? wordSpacing : 0)) * horizontalScaling * 100f; " is 146.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The length of the statement  "		markedRectangles.Add (new Rectangle (annotRect.GetAsNumber (0).FloatValue' annotRect.GetAsNumber (1).FloatValue' annotRect.GetAsNumber (2).FloatValue' annotRect.GetAsNumber (3).FloatValue)); " is 190.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The length of the statement  "		cleanUpColor = new BaseColor (ic.GetAsNumber (0).FloatValue' ic.GetAsNumber (1).FloatValue' ic.GetAsNumber (2).FloatValue); " is 123.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The length of the statement  "		quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue)); " is 130.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The length of the statement  "				Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue); " is 189.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The length of the statement  "				DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT)); " is 169.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,RetrieveFontFromAcroForm,The length of the statement  "	PdfIndirectReference fontIndirReference = pdfStamper.Reader.AcroForm.GetAsDict (PdfName.DR).GetAsDict (PdfName.FONT).GetAsIndirectObject (fontName); " is 148.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ParseDAParam,The length of the statement  "	PRTokeniser tokeniser = new PRTokeniser (new RandomAccessFileOrArray (new RandomAccessSourceFactory ().CreateSource (DA.GetBytes ()))); " is 135.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The length of the statement  "		canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue); " is 154.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The length of the statement  "		canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue); " is 198.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The length of the statement  "		canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue); " is 162.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The length of the statement  "		canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue); " is 206.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,FilterStrokePath,The length of the statement  "	ClipperOffset offset = new ClipperOffset (miterLimit' PdfCleanUpProcessor.ArcTolerance * PdfCleanUpProcessor.FloatMultiplier); " is 126.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,GetRotatedSquareVertices,The length of the statement  "	AffineTransform.GetRotateInstance (angle).Transform (orthogonalSquareVertices' 0' rotatedSquareVertices' 0' rotatedSquareVertices.Length); " is 138.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,GetRotatedSquareVertices,The length of the statement  "	AffineTransform.GetTranslateInstance (squareCenter.GetX ()' squareCenter.GetY ()).Transform (rotatedSquareVertices' 0' rotatedSquareVertices' 0' orthogonalSquareVertices.Length); " is 178.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToIntPoints,The length of the statement  "		convertedPoints.Add (new IntPoint (PdfCleanUpProcessor.FloatMultiplier * point.GetX ()' PdfCleanUpProcessor.FloatMultiplier * point.GetY ())); " is 142.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToFloatPoints,The length of the statement  "		convertedPoints.Add (new Point2D.Float ((float)(point.X / PdfCleanUpProcessor.FloatMultiplier)' (float)(point.Y / PdfCleanUpProcessor.FloatMultiplier))); " is 153.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,CalcImageRect,The length of the statement  "	Point2D[] points = TransformPoints (ctm' false' new Point (0' 0)' new Point (0' 1)' new Point (1' 0)' new Point (1' 1)); " is 120.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,TransformIntersection,The length of the statement  "	Point2D[] points = TransformPoints (imageCTM' true' new Point (rect.Left' rect.Bottom)' new Point (rect.Left' rect.Top)' new Point (rect.Right' rect.Bottom)' new Point (rect.Right' rect.Top)); " is 192.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,GetNextPoint,The length of the statement  "	return new Point2D.Float ((float)(segStart.GetX () + dist * unitVector.GetX ())' (float)(segStart.GetY () + dist * unitVector.GetY ())); " is 136.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ComponentwiseDiff,The length of the statement  "	return new Point2D.Float ((float)(minuend.GetX () - subtrahend.GetX ())' (float)(minuend.GetY () - subtrahend.GetY ())); " is 120.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,LiesOnSegment,The length of the statement  "	return point.GetX () >= Math.Min (segStart.GetX ()' segEnd.GetX ()) && point.GetX () <= Math.Max (segStart.GetX ()' segEnd.GetX ()) && point.GetY () >= Math.Min (segStart.GetY ()' segEnd.GetY ()) && point.GetY () <= Math.Max (segStart.GetY ()' segEnd.GetY ()); " is 260.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,TransformPoints,The length of the statement  "	AffineTransform t = new AffineTransform (transormationMatrix [Matrix.I11]' transormationMatrix [Matrix.I12]' transormationMatrix [Matrix.I21]' transormationMatrix [Matrix.I22]' transormationMatrix [Matrix.I31]' transormationMatrix [Matrix.I32]); " is 245.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,RenderText,The length of the statement  "		chunks.Add (new PdfCleanUpContentChunk.Text (ri.PdfString' baseline.GetStartPoint ()' baseline.GetEndPoint ()' isAllowed' strNumber)); " is 134.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The length of the statement  "		unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]); " is 133.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,RenderPath,The length of the statement  "		currentStrokePath = FilterCurrentPath (renderInfo.Ctm' true' -1' lineWidth' lineCapStyle' lineJoinStyle' miterLimit' lineDashPattern); " is 134.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,RenderPath,The length of the statement  "		currentFillPath = FilterCurrentPath (renderInfo.Ctm' false' renderInfo.Rule' lineWidth' lineCapStyle' lineJoinStyle' miterLimit' lineDashPattern); " is 146.
Long Statement,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,RenderPath,The length of the statement  "			newClippingPath = FilterCurrentPath (renderInfo.Ctm' false' clippingRule' lineWidth' lineCapStyle' lineJoinStyle' miterLimit' lineDashPattern); " is 143.
Complex Conditional,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,ToPdf,The conditional expression  "type != PdfObject.ARRAY && type != PdfObject.DICTIONARY && type != PdfObject.NAME && type != PdfObject.STRING"  is complex.
Virtual Method Call from Constructor,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,MCParser,The constructor "MCParser" calls a virtual method "PopulateOperators".
Virtual Method Call from Constructor,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,StructureItems,The constructor "StructureItems" calls a virtual method "ProcessStructElems".
Virtual Method Call from Constructor,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,StructureItems,The constructor "StructureItems" calls a virtual method "ProcessStructElems".
Virtual Method Call from Constructor,iTextSharp.text.pdf.spatial,Measure,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\spatial\Measure.cs,Measure,The constructor "Measure" calls a virtual method "GetSubType".
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: while (ps.Parse (operands).Count > 0) {  	PdfLiteral @operator = (PdfLiteral)operands [operands.Count - 1];  	ProcessOperator (this' @operator' operands);  	if ("BI".Equals (@operator.ToString ())) {  		int found = 0;  		int ch;  		bool immediateAfterBI = true;  		while ((ch = tokeniser.Read ()) != -1) {  			if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  				baos.WriteByte ((byte)ch);  			}  			immediateAfterBI = false;  			if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  				found++;  			} else if (found == 1 && ch == 'E') {  				found++;  			} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  				// this clause is needed if we have a white space character that is part of the image data  				// followed by a whitespace character that precedes the EI operator.  In this case' we need  				// to flush the first whitespace' then treat the current whitespace as the first potential  				// character for the end of stream check. Note that we don't increment 'found' here.  			} else if (found == 2 && ch == 'I') {  				found++;  			} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  				break;  			} else {  				found = 0;  			}  		}  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: while (ps.Parse (operands).Count > 0) {  	PdfLiteral @operator = (PdfLiteral)operands [operands.Count - 1];  	ProcessOperator (this' @operator' operands);  	if ("BI".Equals (@operator.ToString ())) {  		int found = 0;  		int ch;  		bool immediateAfterBI = true;  		while ((ch = tokeniser.Read ()) != -1) {  			if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  				baos.WriteByte ((byte)ch);  			}  			immediateAfterBI = false;  			if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  				found++;  			} else if (found == 1 && ch == 'E') {  				found++;  			} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  				// this clause is needed if we have a white space character that is part of the image data  				// followed by a whitespace character that precedes the EI operator.  In this case' we need  				// to flush the first whitespace' then treat the current whitespace as the first potential  				// character for the end of stream check. Note that we don't increment 'found' here.  			} else if (found == 2 && ch == 'I') {  				found++;  			} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  				break;  			} else {  				found = 0;  			}  		}  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if ("BI".Equals (@operator.ToString ())) {  	int found = 0;  	int ch;  	bool immediateAfterBI = true;  	while ((ch = tokeniser.Read ()) != -1) {  		if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  			baos.WriteByte ((byte)ch);  		}  		immediateAfterBI = false;  		if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  			found++;  		} else if (found == 1 && ch == 'E') {  			found++;  		} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  			// this clause is needed if we have a white space character that is part of the image data  			// followed by a whitespace character that precedes the EI operator.  In this case' we need  			// to flush the first whitespace' then treat the current whitespace as the first potential  			// character for the end of stream check. Note that we don't increment 'found' here.  		} else if (found == 2 && ch == 'I') {  			found++;  		} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  			break;  		} else {  			found = 0;  		}  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if ("BI".Equals (@operator.ToString ())) {  	int found = 0;  	int ch;  	bool immediateAfterBI = true;  	while ((ch = tokeniser.Read ()) != -1) {  		if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  			baos.WriteByte ((byte)ch);  		}  		immediateAfterBI = false;  		if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  			found++;  		} else if (found == 1 && ch == 'E') {  			found++;  		} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  			// this clause is needed if we have a white space character that is part of the image data  			// followed by a whitespace character that precedes the EI operator.  In this case' we need  			// to flush the first whitespace' then treat the current whitespace as the first potential  			// character for the end of stream check. Note that we don't increment 'found' here.  		} else if (found == 2 && ch == 'I') {  			found++;  		} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  			break;  		} else {  			found = 0;  		}  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: while ((ch = tokeniser.Read ()) != -1) {  	if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  		baos.WriteByte ((byte)ch);  	}  	immediateAfterBI = false;  	if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  		found++;  	} else if (found == 1 && ch == 'E') {  		found++;  	} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  		// this clause is needed if we have a white space character that is part of the image data  		// followed by a whitespace character that precedes the EI operator.  In this case' we need  		// to flush the first whitespace' then treat the current whitespace as the first potential  		// character for the end of stream check. Note that we don't increment 'found' here.  	} else if (found == 2 && ch == 'I') {  		found++;  	} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  		break;  	} else {  		found = 0;  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: while ((ch = tokeniser.Read ()) != -1) {  	if (!immediateAfterBI || !PRTokeniser.IsWhitespace (ch)) {  		baos.WriteByte ((byte)ch);  	}  	immediateAfterBI = false;  	if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  		found++;  	} else if (found == 1 && ch == 'E') {  		found++;  	} else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  		// this clause is needed if we have a white space character that is part of the image data  		// followed by a whitespace character that precedes the EI operator.  In this case' we need  		// to flush the first whitespace' then treat the current whitespace as the first potential  		// character for the end of stream check. Note that we don't increment 'found' here.  	} else if (found == 2 && ch == 'I') {  		found++;  	} else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  		break;  	} else {  		found = 0;  	}  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  	found++;  } else if (found == 1 && ch == 'E') {  	found++;  } else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 0 && PRTokeniser.IsWhitespace (ch)) {  	found++;  } else if (found == 1 && ch == 'E') {  	found++;  } else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 1 && ch == 'E') {  	found++;  } else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 1 && ch == 'E') {  	found++;  } else if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 1 && PRTokeniser.IsWhitespace (ch)) {  	// this clause is needed if we have a white space character that is part of the image data  	// followed by a whitespace character that precedes the EI operator.  In this case' we need  	// to flush the first whitespace' then treat the current whitespace as the first potential  	// character for the end of stream check. Note that we don't increment 'found' here.  } else if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 2 && ch == 'I') {  	found++;  } else if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.text.pdf.ocg,OCGParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\ocg\OCGParser.cs,Parse,The following statement contains a magic number: if (found == 3 && PRTokeniser.IsWhitespace (ch)) {  	break;  } else {  	found = 0;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The following statement contains a magic number: if ("Do" == operatorStr) {  	if (operands.Count == 2 && operands [0].IsName ()) {  		PdfDictionary xObjResources = cleanUpStrategy.Context.Resources.GetAsDict (PdfName.XOBJECT);  		if (xObjResources != null) {  			PdfStream xObj = xObjResources.GetAsStream ((PdfName)operands [0]);  			if (xObj is PRStream && xObj.GetAsName (PdfName.SUBTYPE) != null && xObj.GetAsName (PdfName.SUBTYPE).CompareTo (PdfName.FORM) == 0) {  				xFormStream = (PRStream)xObj;  				cleanUpStrategy.RegisterNewContext (xObj.GetAsDict (PdfName.RESOURCES)' null);  			}  		}  	}  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpContentOperator,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpContentOperator.cs,Invoke,The following statement contains a magic number: if (operands.Count == 2 && operands [0].IsName ()) {  	PdfDictionary xObjResources = cleanUpStrategy.Context.Resources.GetAsDict (PdfName.XOBJECT);  	if (xObjResources != null) {  		PdfStream xObj = xObjResources.GetAsStream ((PdfName)operands [0]);  		if (xObj is PRStream && xObj.GetAsName (PdfName.SUBTYPE) != null && xObj.GetAsName (PdfName.SUBTYPE).CompareTo (PdfName.FORM) == 0) {  			xFormStream = (PRStream)xObj;  			cleanUpStrategy.RegisterNewContext (xObj.GetAsDict (PdfName.RESOURCES)' null);  		}  	}  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: if (quadPoints.Size != 0) {  	markedRectangles.AddRange (TranslateQuadPointsToRectangles (quadPoints));  } else {  	PdfArray annotRect = annotDict.GetAsArray (PdfName.RECT);  	markedRectangles.Add (new Rectangle (annotRect.GetAsNumber (0).FloatValue' annotRect.GetAsNumber (1).FloatValue' annotRect.GetAsNumber (2).FloatValue' annotRect.GetAsNumber (3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: if (quadPoints.Size != 0) {  	markedRectangles.AddRange (TranslateQuadPointsToRectangles (quadPoints));  } else {  	PdfArray annotRect = annotDict.GetAsArray (PdfName.RECT);  	markedRectangles.Add (new Rectangle (annotRect.GetAsNumber (0).FloatValue' annotRect.GetAsNumber (1).FloatValue' annotRect.GetAsNumber (2).FloatValue' annotRect.GetAsNumber (3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: markedRectangles.Add (new Rectangle (annotRect.GetAsNumber (0).FloatValue' annotRect.GetAsNumber (1).FloatValue' annotRect.GetAsNumber (2).FloatValue' annotRect.GetAsNumber (3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: markedRectangles.Add (new Rectangle (annotRect.GetAsNumber (0).FloatValue' annotRect.GetAsNumber (1).FloatValue' annotRect.GetAsNumber (2).FloatValue' annotRect.GetAsNumber (3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: if (ic != null) {  	cleanUpColor = new BaseColor (ic.GetAsNumber (0).FloatValue' ic.GetAsNumber (1).FloatValue' ic.GetAsNumber (2).FloatValue);  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,ExtractLocationsFromRedactAnnot,The following statement contains a magic number: cleanUpColor = new BaseColor (ic.GetAsNumber (0).FloatValue' ic.GetAsNumber (1).FloatValue' ic.GetAsNumber (2).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: for (int i = 0; i < quadPoints.Size; i += 8) {  	rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  	quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: for (int i = 0; i < quadPoints.Size; i += 8) {  	rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  	quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: for (int i = 0; i < quadPoints.Size; i += 8) {  	rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  	quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: for (int i = 0; i < quadPoints.Size; i += 8) {  	rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  	quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: for (int i = 0; i < quadPoints.Size; i += 8) {  	rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  	quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: i += 8
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,TranslateQuadPointsToRectangles,The following statement contains a magic number: rectangles.Add (new Rectangle (quadPoints.GetAsNumber (i + 4).FloatValue' // QuadPoints have "Z" order  quadPoints.GetAsNumber (i + 5).FloatValue' quadPoints.GetAsNumber (i + 2).FloatValue' quadPoints.GetAsNumber (i + 3).FloatValue));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: for (int i = 0' j = 0; i < annotsArray.Size; ++i' ++j) {  	PdfIndirectReference annotIndRef = annotsArray.GetAsIndirectObject (i);  	PdfDictionary annotDict = annotsArray.GetAsDict (i);  	if (indirRefs.Contains (annotIndRef.ToString ()) || indirRefs.Contains (GetParentIndRefStr (annotDict))) {  		PdfStream formXObj = annotDict.GetAsStream (PdfName.RO);  		PdfString overlayText = annotDict.GetAsString (PdfName.OVERLAYTEXT);  		if (FillCleanedArea && formXObj != null) {  			PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  			Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  			InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  		} else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  			DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  		}  		annotsArray.Remove (i--);  		// array size is changed' so we need to decrease i  	}  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: for (int i = 0' j = 0; i < annotsArray.Size; ++i' ++j) {  	PdfIndirectReference annotIndRef = annotsArray.GetAsIndirectObject (i);  	PdfDictionary annotDict = annotsArray.GetAsDict (i);  	if (indirRefs.Contains (annotIndRef.ToString ()) || indirRefs.Contains (GetParentIndRefStr (annotDict))) {  		PdfStream formXObj = annotDict.GetAsStream (PdfName.RO);  		PdfString overlayText = annotDict.GetAsString (PdfName.OVERLAYTEXT);  		if (FillCleanedArea && formXObj != null) {  			PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  			Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  			InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  		} else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  			DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  		}  		annotsArray.Remove (i--);  		// array size is changed' so we need to decrease i  	}  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: if (indirRefs.Contains (annotIndRef.ToString ()) || indirRefs.Contains (GetParentIndRefStr (annotDict))) {  	PdfStream formXObj = annotDict.GetAsStream (PdfName.RO);  	PdfString overlayText = annotDict.GetAsString (PdfName.OVERLAYTEXT);  	if (FillCleanedArea && formXObj != null) {  		PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  		Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  		InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  	} else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  		DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  	}  	annotsArray.Remove (i--);  	// array size is changed' so we need to decrease i  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: if (indirRefs.Contains (annotIndRef.ToString ()) || indirRefs.Contains (GetParentIndRefStr (annotDict))) {  	PdfStream formXObj = annotDict.GetAsStream (PdfName.RO);  	PdfString overlayText = annotDict.GetAsString (PdfName.OVERLAYTEXT);  	if (FillCleanedArea && formXObj != null) {  		PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  		Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  		InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  	} else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  		DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  	}  	annotsArray.Remove (i--);  	// array size is changed' so we need to decrease i  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: if (FillCleanedArea && formXObj != null) {  	PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  	Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  	InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  } else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  	DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,DeleteRedactAnnots,The following statement contains a magic number: if (FillCleanedArea && formXObj != null) {  	PdfArray rectArray = annotDict.GetAsArray (PdfName.RECT);  	Rectangle annotRect = new Rectangle (rectArray.GetAsNumber (0).FloatValue' rectArray.GetAsNumber (1).FloatValue' rectArray.GetAsNumber (2).FloatValue' rectArray.GetAsNumber (3).FloatValue);  	InsertFormXObj (canvas' pageDict' formXObj' clippingRects [j]' annotRect);  } else if (FillCleanedArea && overlayText != null && overlayText.ToUnicodeString ().Length > 0) {  	DrawOverlayText (canvas' clippingRects [j]' overlayText' annotDict.GetAsString (PdfName.DA)' annotDict.GetAsNumber (PdfName.Q)' annotDict.GetAsBoolean (PdfName.REPEAT));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following statement contains a magic number: canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following statement contains a magic number: canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,FilterStrokePath,The following statement contains a magic number: offset.Execute (ref resultTree' lineWidth * PdfCleanUpProcessor.FloatMultiplier / 2);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,FilterStrokePath,The following statement contains a magic number: if (degenerateSubpaths.Count > 0) {  	if (endType == EndType.etOpenRound) {  		IList<Subpath> circles = ConvertToCircles (degenerateSubpaths' lineWidth / 2);  		offsetedPath.AddSubpaths (circles);  	} else if (endType == EndType.etOpenSquare && lineDashPattern != null) {  		IList<Subpath> squares = ConvertToSquares (degenerateSubpaths' lineWidth' sourcePath);  		offsetedPath.AddSubpaths (squares);  	}  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,FilterStrokePath,The following statement contains a magic number: if (endType == EndType.etOpenRound) {  	IList<Subpath> circles = ConvertToCircles (degenerateSubpaths' lineWidth / 2);  	offsetedPath.AddSubpaths (circles);  } else if (endType == EndType.etOpenSquare && lineDashPattern != null) {  	IList<Subpath> squares = ConvertToSquares (degenerateSubpaths' lineWidth' sourcePath);  	offsetedPath.AddSubpaths (squares);  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToCircles,The following statement contains a magic number: foreach (Subpath subpath in degenerateSubpaths) {  	BezierCurve[] circleSectors = ApproximateCircle (subpath.GetStartPoint ()' radius);  	Subpath circle = new Subpath ();  	circle.AddSegment (circleSectors [0]);  	circle.AddSegment (circleSectors [1]);  	circle.AddSegment (circleSectors [2]);  	circle.AddSegment (circleSectors [3]);  	circles.Add (circle);  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToCircles,The following statement contains a magic number: foreach (Subpath subpath in degenerateSubpaths) {  	BezierCurve[] circleSectors = ApproximateCircle (subpath.GetStartPoint ()' radius);  	Subpath circle = new Subpath ();  	circle.AddSegment (circleSectors [0]);  	circle.AddSegment (circleSectors [1]);  	circle.AddSegment (circleSectors [2]);  	circle.AddSegment (circleSectors [3]);  	circles.Add (circle);  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToCircles,The following statement contains a magic number: circle.AddSegment (circleSectors [2]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToCircles,The following statement contains a magic number: circle.AddSegment (circleSectors [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToSquares,The following statement contains a magic number: if (pathApprox.Count < 2) {  	return new List<Subpath> ();  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToSquares,The following statement contains a magic number: for (int i = 0; i < degenerateSubpaths.Count; ++i) {  	Point2D point = degenerateSubpaths [i].GetStartPoint ();  	while (!line.Contains (point)) {  		approxPt1 = approxPt2;  		approxIter.MoveNext ();  		approxPt2 = approxIter.Current;  		line = new StandardLine (approxPt1' approxPt2);  	}  	float slope = line.GetSlope ();  	double angle;  	if (!float.IsPositiveInfinity (slope)) {  		angle = Math.Atan (slope);  	} else {  		angle = Math.PI / 2;  	}  	squares.Add (ConstructSquare (point' widthHalf' angle));  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToSquares,The following statement contains a magic number: if (!float.IsPositiveInfinity (slope)) {  	angle = Math.Atan (slope);  } else {  	angle = Math.PI / 2;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConvertToSquares,The following statement contains a magic number: angle = Math.PI / 2;  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConstructSquare,The following statement contains a magic number: square.AddSegment (new Line (rotatedSquareVertices [1]' rotatedSquareVertices [2]));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConstructSquare,The following statement contains a magic number: square.AddSegment (new Line (rotatedSquareVertices [2]' rotatedSquareVertices [3]));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConstructSquare,The following statement contains a magic number: square.AddSegment (new Line (rotatedSquareVertices [2]' rotatedSquareVertices [3]));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ConstructSquare,The following statement contains a magic number: square.AddSegment (new Line (rotatedSquareVertices [3]' rotatedSquareVertices [0]));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ApproximateCircle,The following statement contains a magic number: approximation [2] = new BezierCurve (new List<Point2D> (new Point2D[] {  	new Point2D.Double (x' y - radius)'  	new Point2D.Double (x - radius * circleApproximationConst' y - radius)'  	new Point2D.Double (x - radius' y - radius * circleApproximationConst)'  	new Point2D.Double (x - radius' y)  }));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,ApproximateCircle,The following statement contains a magic number: approximation [3] = new BezierCurve (new List<Point2D> (new Point2D[] {  	new Point2D.Double (x - radius' y)'  	new Point2D.Double (x - radius' y + radius * circleApproximationConst)'  	new Point2D.Double (x - radius * circleApproximationConst' y + radius)'  	new Point2D.Double (x' y + radius)  }));  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,CalcImageRect,The following statement contains a magic number: return GetRectangle (points [0]' points [1]' points [2]' points [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,CalcImageRect,The following statement contains a magic number: return GetRectangle (points [0]' points [1]' points [2]' points [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,TransformIntersection,The following statement contains a magic number: return GetRectangle (points [0]' points [1]' points [2]' points [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,TransformIntersection,The following statement contains a magic number: return GetRectangle (points [0]' points [1]' points [2]' points [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Magic Number,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following statement contains a magic number: unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  
Missing Default,iTextSharp.text.pdf.mc,MCParser,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\MCParser.cs,DealWithMcid,The following switch statement is missing a default case: switch (check) {  case 1:  	LOGGER.Info ("Removed structure item from stack.");  	items.RemoveAt (i);  	return;  case 0:  	break;  }  
Missing Default,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,StructureItems,The following switch statement is missing a default case: switch (objecta.Type) {  case PdfObject.DICTIONARY:  	LOGGER.Info ("StructTreeRoot refers to dictionary");  	ProcessStructElems ((PdfDictionary)objecta' structTreeRoot.GetAsIndirectObject (PdfName.K));  	break;  case PdfObject.ARRAY:  	LOGGER.Info ("StructTreeRoot refers to array");  	PdfArray array = (PdfArray)objecta;  	for (int i = 0; i < array.Size; i++) {  		ProcessStructElems (array.GetAsDict (i)' array.GetAsIndirectObject (i));  	}  	break;  }  
Missing Default,iTextSharp.text.pdf.mc,StructureItems,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\mc\StructureItems.cs,ProcessStructElemKids,The following switch statement is missing a default case: switch (objecta.Type) {  case PdfObject.NUMBER:  	item = new StructureMCID (structElem.GetAsIndirectObject (PdfName.PG)' (PdfNumber)objecta);  	Add (item);  	LOGGER.Info ("Added " + item);  	break;  case PdfObject.ARRAY:  	PdfArray array = (PdfArray)objecta;  	for (int i = 0; i < array.Size; i++) {  		ProcessStructElemKids (structElem' array.GetAsIndirectObject (i)' array.GetDirectObject (i));  	}  	break;  case PdfObject.DICTIONARY:  	PdfDictionary dict = (PdfDictionary)objecta;  	if (dict.CheckType (PdfName.MCR)) {  		item = new StructureMCID (dict);  		Add (item);  		LOGGER.Info ("Added " + item);  	} else if (dict.CheckType (PdfName.OBJR)) {  		item = new StructureObject (structElem' refa' dict);  		Add (item);  		LOGGER.Info ("Added " + item);  	} else {  		ProcessStructElems (dict' refa);  	}  	break;  }  
Missing Default,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetFillColor,The following switch statement is missing a default case: switch (fillColorArgs.Count) {  case 1:  	canvas.SetGrayFill (((PdfNumber)fillColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)fillColorArgs [0]).FloatValue' ((PdfNumber)fillColorArgs [1]).FloatValue' ((PdfNumber)fillColorArgs [2]).FloatValue' ((PdfNumber)fillColorArgs [3]).FloatValue);  	break;  }  
Missing Default,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpProcessor,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpProcessor.cs,SetStrokeColor,The following switch statement is missing a default case: switch (strokeColorArgs.Count) {  case 1:  	canvas.SetGrayStroke (((PdfNumber)strokeColorArgs [0]).FloatValue);  	break;  case 3:  	canvas.SetRGBColorStrokeF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue);  	break;  case 4:  	canvas.SetCMYKColorFillF (((PdfNumber)strokeColorArgs [0]).FloatValue' ((PdfNumber)strokeColorArgs [1]).FloatValue' ((PdfNumber)strokeColorArgs [2]).FloatValue' ((PdfNumber)strokeColorArgs [3]).FloatValue);  	break;  }  
Missing Default,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,GetJoinType,The following switch statement is missing a default case: switch (lineJoinStyle) {  case PdfContentByte.LINE_JOIN_BEVEL:  	return JoinType.jtBevel;  case PdfContentByte.LINE_JOIN_MITER:  	return JoinType.jtMiter;  }  
Missing Default,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRegionFilter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRegionFilter.cs,GetEndType,The following switch statement is missing a default case: switch (lineCapStyle) {  case PdfContentByte.LINE_CAP_BUTT:  	return EndType.etOpenButt;  case PdfContentByte.LINE_CAP_PROJECTING_SQUARE:  	return EndType.etOpenSquare;  }  
Missing Default,iTextSharp.xtra.iTextSharp.text.pdf.pdfcleanup,PdfCleanUpRenderListener,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\pdfcleanup\PdfCleanUpRenderListener.cs,ModifyPath,The following switch statement is missing a default case: switch (renderInfo.Operation) {  case PathConstructionRenderInfo.MOVETO:  	unfilteredCurrentPath.MoveTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.LINETO:  	unfilteredCurrentPath.LineTo (segmentData [0]' segmentData [1]);  	break;  case PathConstructionRenderInfo.CURVE_123:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]' segmentData [4]' segmentData [5]);  	break;  case PathConstructionRenderInfo.CURVE_23:  	unfilteredCurrentPath.CurveTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CURVE_13:  	unfilteredCurrentPath.CurveFromTo (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  case PathConstructionRenderInfo.CLOSE:  	unfilteredCurrentPath.CloseSubpath ();  	break;  case PathConstructionRenderInfo.RECT:  	unfilteredCurrentPath.Rectangle (segmentData [0]' segmentData [1]' segmentData [2]' segmentData [3]);  	break;  }  
Missing Default,iTextSharp.text.pdf.util,PdfResourceCounter,F:\newReposMay17\itext_itextsharp\src\extras\iTextSharp.xtra\iTextSharp\text\pdf\util\PdfResourceCounter.cs,LoopOver,The following switch statement is missing a default case: switch (@object.Type) {  case PdfObject.ARRAY:  	PdfArray array = (PdfArray)@object;  	for (int i = 0; i < array.Size; i++) {  		Process (array.GetDirectObject (i));  	}  	break;  case PdfObject.DICTIONARY:  case PdfObject.STREAM:  	PdfDictionary dict = (PdfDictionary)@object;  	if (dict.IsPages ())  		break;  	foreach (PdfName name in dict.Keys) {  		Process (dict.GetDirectObject (name));  	}  	break;  }  
