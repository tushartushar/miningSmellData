Implementation smell,Namespace,Class,File,Method,Description
Long Method,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The method has 143 lines of code.
Complex Method,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,Cyclomatic complexity of the method is 9
Complex Method,Excavator.BinaryFile.PersonImage,PersonImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\PersonImage.cs,Map,Cyclomatic complexity of the method is 8
Long Statement,Excavator.BinaryFile,BinaryFileComponent,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\BinaryFileComponent.cs,TransformData,The length of the statement  "                var specificFileType = FileTypes.FirstOrDefault( t => selectedFile.Name.RemoveWhitespace().StartsWith( t.Name.RemoveWhitespace() ) ); " is 133.
Long Statement,Excavator.BinaryFile,BinaryFileComponent,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\BinaryFileComponent.cs,TransformData,The length of the statement  "                    LogException( "Binary File"' string.Format( "Unknown File: {0} does not start with the name of a known data map."' selectedFile.Name ) ); " is 137.
Long Statement,Excavator.BinaryFile,BinaryFileComponent,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\BinaryFileComponent.cs,LoadRockData,The length of the statement  "                if ( type.StorageEntityTypeId == FileSystemStorageTypeId && binaryTypeSettings.AllKeys.Any( k => type.Name.Equals( k ) ) ) " is 122.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The length of the statement  "                    attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName; " is 162.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The length of the statement  "                        var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) ); " is 124.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The length of the statement  "                        ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) ); " is 144.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,SaveFiles,The length of the statement  "                    var attributeValue = rockContext.AttributeValues.FirstOrDefault( p => p.AttributeId == entry.AttributeId && p.EntityId == entry.PersonId ); " is 139.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,SaveFiles,The length of the statement  "                    attributeValue = attributeValue ?? rockContext.AttributeValues.Local.FirstOrDefault( p => p.AttributeId == entry.AttributeId && p.EntityId == entry.PersonId ); " is 159.
Long Statement,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,SaveFiles,The length of the statement  "                    if ( attributeValue == null || attributeValue.CreatedDateTime < entry.File.CreatedDateTime || attributeValue.ForeignId < entry.File.ForeignId ) " is 143.
Long Statement,Excavator.BinaryFile,TransactionImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\TransactionImage.cs,Map,The length of the statement  "                        ReportProgress( percentComplete' string.Format( "{0:N0} transaction image files imported ({1}% complete)."' completedItems' percentComplete ) ); " is 144.
Long Statement,Excavator.BinaryFile.PersonImage,PersonImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\PersonImage.cs,Map,The length of the statement  "                    if ( !existingImageList.ContainsKey( personKeys.PersonId ) || existingImageList[personKeys.PersonId].Value < file.LastWriteTime.DateTime ) " is 138.
Long Statement,Excavator.BinaryFile.PersonImage,PersonImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\PersonImage.cs,Map,The length of the statement  "                        ReportProgress( percentComplete' string.Format( "{0:N0} person image files imported ({1}% complete)."' completedItems' percentComplete ) ); " is 139.
Magic Number,Excavator.BinaryFile,BinaryFileComponent,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\BinaryFileComponent.cs,LoadSchema,The following statement contains a magic number: foreach ( var document in previewFolder.Entries.Take( 50 ) )              {                  if ( document != null )                  {                      var entryItem = new DataNode();                      entryItem.Name = document.FullName;                      string content = new StreamReader( document.Open() ).ReadToEnd();                      entryItem.Value = Encoding.UTF8.GetBytes( content ) ?? null;                      entryItem.NodeType = typeof( byte[] );                      entryItem.Parent.Add( folderItem );                      folderItem.Children.Add( entryItem );                  }              }
Magic Number,Excavator.BinaryFile,BinaryFileComponent,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\BinaryFileComponent.cs,TransformData,The following statement contains a magic number: ReportProgress( 100' string.Format( "Completed import: {0:N0} records imported."' totalCount ) );
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: var percentage = ( totalRows - 1 ) / 100 + 1;
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: foreach ( var file in folder.Entries )              {                  var fileExtension = Path.GetExtension( file.Name );                  if ( FileTypeBlackList.Contains( fileExtension ) )                  {                      LogException( "Binary File Import"' string.Format( "{0} filetype not allowed ({1})"' fileExtension' file.Name ) );                      continue;                  }                    var parsedFileName = file.Name.Split( '_' );                  // Ministry docs should follow this pattern:                  // 0. Firstname                  // 1. Lastname                  // 2. ForeignId                  // 3. Filename                  // 4. Doc Id                    var personForeignId = parsedFileName[2].AsType<int?>();                  var personKeys = ImportedPeople.FirstOrDefault( p => p.PersonForeignId == personForeignId );                  if ( personKeys != null )                  {                      var attributeName = string.Empty;                      var documentForeignId = string.Empty;                      if ( parsedFileName.Count() > 4 )                      {                          attributeName = parsedFileName[3];                          documentForeignId = parsedFileName[4];                      }                      else                      {                          var nameWithoutExtension = parsedFileName[3].ReplaceLastOccurrence( fileExtension' string.Empty );                          attributeName = Regex.Replace( nameWithoutExtension' "\\d{4'}[.\\w]+$"' string.Empty );                          documentForeignId = Regex.Match( nameWithoutExtension' "\\d+$" ).Value;                      }                        // append "Document" to attribute name to create unique attributes                      // this matches core attribute "Background Check Document"                      attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName;                      var attributeKey = attributeName.RemoveSpecialCharacters();                        Attribute fileAttribute = null;                      var attributeBinaryFileType = ministryFileType;                      if ( !existingAttributes.ContainsKey( attributeKey ) )                      {                          fileAttribute = new Attribute                          {                              FieldTypeId = fileFieldTypeId'                              EntityTypeId = personEntityTypeId'                              EntityTypeQualifierColumn = string.Empty'                              EntityTypeQualifierValue = string.Empty'                              Key = attributeKey'                              Name = attributeName'                              Description = string.Format( "{0} created by binary file import"' attributeName )'                              IsGridColumn = false'                              IsMultiValue = false'                              IsRequired = false'                              AllowSearch = false'                              IsSystem = false'                              Order = 0                          };                            fileAttribute.AttributeQualifiers.Add( new AttributeQualifier()                          {                              Key = "binaryFileType"'                              Value = ministryFileType.Guid.ToString()                          } );                            lookupContext.Attributes.Add( fileAttribute );                          lookupContext.SaveChanges();                            existingAttributes.Add( fileAttribute.Key' fileAttribute );                      }                      else                      {                          // attribute already exists in Rock' override default file type with the Rock-specified file type                          fileAttribute = existingAttributes[attributeKey];                          var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) );                          if ( attributeBinaryFileTypeGuid != null )                          {                              attributeBinaryFileType = binaryFileTypeService.Get( attributeBinaryFileTypeGuid.Value.AsGuid() );                          }                      }                        var rockFile = new Rock.Model.BinaryFile                      {                          IsSystem = false'                          IsTemporary = false'                          MimeType = GetMIMEType( file.Name )'                          BinaryFileTypeId = attributeBinaryFileType.Id'                          FileName = file.Name'                          Description = string.Format( "Imported as {0}"' file.Name )'                          CreatedDateTime = file.LastWriteTime.DateTime'                          ModifiedDateTime = file.LastWriteTime.DateTime'                          CreatedByPersonAliasId = ImportPersonAliasId'                          ForeignKey = documentForeignId'                          ForeignId = documentForeignId.AsIntegerOrNull()                      };                        rockFile.SetStorageEntityTypeId( attributeBinaryFileType.StorageEntityTypeId );                      rockFile.StorageEntitySettings = emptyJsonObject;                        if ( attributeBinaryFileType.AttributeValues != null )                      {                          rockFile.StorageEntitySettings = attributeBinaryFileType.AttributeValues                              .ToDictionary( a => a.Key' v => v.Value.Value ).ToJson();                      }                        // use base stream instead of file stream to keep the byte[]                      // NOTE: if byte[] converts to a string it will corrupt the stream                      using ( var fileContent = new StreamReader( file.Open() ) )                      {                          rockFile.ContentStream = new MemoryStream( fileContent.BaseStream.ReadBytesToEnd() );                      }                        newFileList.Add( new DocumentKeys()                      {                          PersonId = personKeys.PersonId'                          AttributeId = fileAttribute.Id'                          File = rockFile                      } );                        completedItems++;                      if ( completedItems % percentage < 1 )                      {                          var percentComplete = completedItems / percentage;                          ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) );                      }                      else if ( completedItems % ReportingNumber < 1 )                      {                          SaveFiles( newFileList );                            // Reset list                          newFileList.Clear();                          ReportPartialProgress();                      }                  }              }
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: foreach ( var file in folder.Entries )              {                  var fileExtension = Path.GetExtension( file.Name );                  if ( FileTypeBlackList.Contains( fileExtension ) )                  {                      LogException( "Binary File Import"' string.Format( "{0} filetype not allowed ({1})"' fileExtension' file.Name ) );                      continue;                  }                    var parsedFileName = file.Name.Split( '_' );                  // Ministry docs should follow this pattern:                  // 0. Firstname                  // 1. Lastname                  // 2. ForeignId                  // 3. Filename                  // 4. Doc Id                    var personForeignId = parsedFileName[2].AsType<int?>();                  var personKeys = ImportedPeople.FirstOrDefault( p => p.PersonForeignId == personForeignId );                  if ( personKeys != null )                  {                      var attributeName = string.Empty;                      var documentForeignId = string.Empty;                      if ( parsedFileName.Count() > 4 )                      {                          attributeName = parsedFileName[3];                          documentForeignId = parsedFileName[4];                      }                      else                      {                          var nameWithoutExtension = parsedFileName[3].ReplaceLastOccurrence( fileExtension' string.Empty );                          attributeName = Regex.Replace( nameWithoutExtension' "\\d{4'}[.\\w]+$"' string.Empty );                          documentForeignId = Regex.Match( nameWithoutExtension' "\\d+$" ).Value;                      }                        // append "Document" to attribute name to create unique attributes                      // this matches core attribute "Background Check Document"                      attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName;                      var attributeKey = attributeName.RemoveSpecialCharacters();                        Attribute fileAttribute = null;                      var attributeBinaryFileType = ministryFileType;                      if ( !existingAttributes.ContainsKey( attributeKey ) )                      {                          fileAttribute = new Attribute                          {                              FieldTypeId = fileFieldTypeId'                              EntityTypeId = personEntityTypeId'                              EntityTypeQualifierColumn = string.Empty'                              EntityTypeQualifierValue = string.Empty'                              Key = attributeKey'                              Name = attributeName'                              Description = string.Format( "{0} created by binary file import"' attributeName )'                              IsGridColumn = false'                              IsMultiValue = false'                              IsRequired = false'                              AllowSearch = false'                              IsSystem = false'                              Order = 0                          };                            fileAttribute.AttributeQualifiers.Add( new AttributeQualifier()                          {                              Key = "binaryFileType"'                              Value = ministryFileType.Guid.ToString()                          } );                            lookupContext.Attributes.Add( fileAttribute );                          lookupContext.SaveChanges();                            existingAttributes.Add( fileAttribute.Key' fileAttribute );                      }                      else                      {                          // attribute already exists in Rock' override default file type with the Rock-specified file type                          fileAttribute = existingAttributes[attributeKey];                          var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) );                          if ( attributeBinaryFileTypeGuid != null )                          {                              attributeBinaryFileType = binaryFileTypeService.Get( attributeBinaryFileTypeGuid.Value.AsGuid() );                          }                      }                        var rockFile = new Rock.Model.BinaryFile                      {                          IsSystem = false'                          IsTemporary = false'                          MimeType = GetMIMEType( file.Name )'                          BinaryFileTypeId = attributeBinaryFileType.Id'                          FileName = file.Name'                          Description = string.Format( "Imported as {0}"' file.Name )'                          CreatedDateTime = file.LastWriteTime.DateTime'                          ModifiedDateTime = file.LastWriteTime.DateTime'                          CreatedByPersonAliasId = ImportPersonAliasId'                          ForeignKey = documentForeignId'                          ForeignId = documentForeignId.AsIntegerOrNull()                      };                        rockFile.SetStorageEntityTypeId( attributeBinaryFileType.StorageEntityTypeId );                      rockFile.StorageEntitySettings = emptyJsonObject;                        if ( attributeBinaryFileType.AttributeValues != null )                      {                          rockFile.StorageEntitySettings = attributeBinaryFileType.AttributeValues                              .ToDictionary( a => a.Key' v => v.Value.Value ).ToJson();                      }                        // use base stream instead of file stream to keep the byte[]                      // NOTE: if byte[] converts to a string it will corrupt the stream                      using ( var fileContent = new StreamReader( file.Open() ) )                      {                          rockFile.ContentStream = new MemoryStream( fileContent.BaseStream.ReadBytesToEnd() );                      }                        newFileList.Add( new DocumentKeys()                      {                          PersonId = personKeys.PersonId'                          AttributeId = fileAttribute.Id'                          File = rockFile                      } );                        completedItems++;                      if ( completedItems % percentage < 1 )                      {                          var percentComplete = completedItems / percentage;                          ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) );                      }                      else if ( completedItems % ReportingNumber < 1 )                      {                          SaveFiles( newFileList );                            // Reset list                          newFileList.Clear();                          ReportPartialProgress();                      }                  }              }
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: foreach ( var file in folder.Entries )              {                  var fileExtension = Path.GetExtension( file.Name );                  if ( FileTypeBlackList.Contains( fileExtension ) )                  {                      LogException( "Binary File Import"' string.Format( "{0} filetype not allowed ({1})"' fileExtension' file.Name ) );                      continue;                  }                    var parsedFileName = file.Name.Split( '_' );                  // Ministry docs should follow this pattern:                  // 0. Firstname                  // 1. Lastname                  // 2. ForeignId                  // 3. Filename                  // 4. Doc Id                    var personForeignId = parsedFileName[2].AsType<int?>();                  var personKeys = ImportedPeople.FirstOrDefault( p => p.PersonForeignId == personForeignId );                  if ( personKeys != null )                  {                      var attributeName = string.Empty;                      var documentForeignId = string.Empty;                      if ( parsedFileName.Count() > 4 )                      {                          attributeName = parsedFileName[3];                          documentForeignId = parsedFileName[4];                      }                      else                      {                          var nameWithoutExtension = parsedFileName[3].ReplaceLastOccurrence( fileExtension' string.Empty );                          attributeName = Regex.Replace( nameWithoutExtension' "\\d{4'}[.\\w]+$"' string.Empty );                          documentForeignId = Regex.Match( nameWithoutExtension' "\\d+$" ).Value;                      }                        // append "Document" to attribute name to create unique attributes                      // this matches core attribute "Background Check Document"                      attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName;                      var attributeKey = attributeName.RemoveSpecialCharacters();                        Attribute fileAttribute = null;                      var attributeBinaryFileType = ministryFileType;                      if ( !existingAttributes.ContainsKey( attributeKey ) )                      {                          fileAttribute = new Attribute                          {                              FieldTypeId = fileFieldTypeId'                              EntityTypeId = personEntityTypeId'                              EntityTypeQualifierColumn = string.Empty'                              EntityTypeQualifierValue = string.Empty'                              Key = attributeKey'                              Name = attributeName'                              Description = string.Format( "{0} created by binary file import"' attributeName )'                              IsGridColumn = false'                              IsMultiValue = false'                              IsRequired = false'                              AllowSearch = false'                              IsSystem = false'                              Order = 0                          };                            fileAttribute.AttributeQualifiers.Add( new AttributeQualifier()                          {                              Key = "binaryFileType"'                              Value = ministryFileType.Guid.ToString()                          } );                            lookupContext.Attributes.Add( fileAttribute );                          lookupContext.SaveChanges();                            existingAttributes.Add( fileAttribute.Key' fileAttribute );                      }                      else                      {                          // attribute already exists in Rock' override default file type with the Rock-specified file type                          fileAttribute = existingAttributes[attributeKey];                          var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) );                          if ( attributeBinaryFileTypeGuid != null )                          {                              attributeBinaryFileType = binaryFileTypeService.Get( attributeBinaryFileTypeGuid.Value.AsGuid() );                          }                      }                        var rockFile = new Rock.Model.BinaryFile                      {                          IsSystem = false'                          IsTemporary = false'                          MimeType = GetMIMEType( file.Name )'                          BinaryFileTypeId = attributeBinaryFileType.Id'                          FileName = file.Name'                          Description = string.Format( "Imported as {0}"' file.Name )'                          CreatedDateTime = file.LastWriteTime.DateTime'                          ModifiedDateTime = file.LastWriteTime.DateTime'                          CreatedByPersonAliasId = ImportPersonAliasId'                          ForeignKey = documentForeignId'                          ForeignId = documentForeignId.AsIntegerOrNull()                      };                        rockFile.SetStorageEntityTypeId( attributeBinaryFileType.StorageEntityTypeId );                      rockFile.StorageEntitySettings = emptyJsonObject;                        if ( attributeBinaryFileType.AttributeValues != null )                      {                          rockFile.StorageEntitySettings = attributeBinaryFileType.AttributeValues                              .ToDictionary( a => a.Key' v => v.Value.Value ).ToJson();                      }                        // use base stream instead of file stream to keep the byte[]                      // NOTE: if byte[] converts to a string it will corrupt the stream                      using ( var fileContent = new StreamReader( file.Open() ) )                      {                          rockFile.ContentStream = new MemoryStream( fileContent.BaseStream.ReadBytesToEnd() );                      }                        newFileList.Add( new DocumentKeys()                      {                          PersonId = personKeys.PersonId'                          AttributeId = fileAttribute.Id'                          File = rockFile                      } );                        completedItems++;                      if ( completedItems % percentage < 1 )                      {                          var percentComplete = completedItems / percentage;                          ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) );                      }                      else if ( completedItems % ReportingNumber < 1 )                      {                          SaveFiles( newFileList );                            // Reset list                          newFileList.Clear();                          ReportPartialProgress();                      }                  }              }
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: foreach ( var file in folder.Entries )              {                  var fileExtension = Path.GetExtension( file.Name );                  if ( FileTypeBlackList.Contains( fileExtension ) )                  {                      LogException( "Binary File Import"' string.Format( "{0} filetype not allowed ({1})"' fileExtension' file.Name ) );                      continue;                  }                    var parsedFileName = file.Name.Split( '_' );                  // Ministry docs should follow this pattern:                  // 0. Firstname                  // 1. Lastname                  // 2. ForeignId                  // 3. Filename                  // 4. Doc Id                    var personForeignId = parsedFileName[2].AsType<int?>();                  var personKeys = ImportedPeople.FirstOrDefault( p => p.PersonForeignId == personForeignId );                  if ( personKeys != null )                  {                      var attributeName = string.Empty;                      var documentForeignId = string.Empty;                      if ( parsedFileName.Count() > 4 )                      {                          attributeName = parsedFileName[3];                          documentForeignId = parsedFileName[4];                      }                      else                      {                          var nameWithoutExtension = parsedFileName[3].ReplaceLastOccurrence( fileExtension' string.Empty );                          attributeName = Regex.Replace( nameWithoutExtension' "\\d{4'}[.\\w]+$"' string.Empty );                          documentForeignId = Regex.Match( nameWithoutExtension' "\\d+$" ).Value;                      }                        // append "Document" to attribute name to create unique attributes                      // this matches core attribute "Background Check Document"                      attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName;                      var attributeKey = attributeName.RemoveSpecialCharacters();                        Attribute fileAttribute = null;                      var attributeBinaryFileType = ministryFileType;                      if ( !existingAttributes.ContainsKey( attributeKey ) )                      {                          fileAttribute = new Attribute                          {                              FieldTypeId = fileFieldTypeId'                              EntityTypeId = personEntityTypeId'                              EntityTypeQualifierColumn = string.Empty'                              EntityTypeQualifierValue = string.Empty'                              Key = attributeKey'                              Name = attributeName'                              Description = string.Format( "{0} created by binary file import"' attributeName )'                              IsGridColumn = false'                              IsMultiValue = false'                              IsRequired = false'                              AllowSearch = false'                              IsSystem = false'                              Order = 0                          };                            fileAttribute.AttributeQualifiers.Add( new AttributeQualifier()                          {                              Key = "binaryFileType"'                              Value = ministryFileType.Guid.ToString()                          } );                            lookupContext.Attributes.Add( fileAttribute );                          lookupContext.SaveChanges();                            existingAttributes.Add( fileAttribute.Key' fileAttribute );                      }                      else                      {                          // attribute already exists in Rock' override default file type with the Rock-specified file type                          fileAttribute = existingAttributes[attributeKey];                          var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) );                          if ( attributeBinaryFileTypeGuid != null )                          {                              attributeBinaryFileType = binaryFileTypeService.Get( attributeBinaryFileTypeGuid.Value.AsGuid() );                          }                      }                        var rockFile = new Rock.Model.BinaryFile                      {                          IsSystem = false'                          IsTemporary = false'                          MimeType = GetMIMEType( file.Name )'                          BinaryFileTypeId = attributeBinaryFileType.Id'                          FileName = file.Name'                          Description = string.Format( "Imported as {0}"' file.Name )'                          CreatedDateTime = file.LastWriteTime.DateTime'                          ModifiedDateTime = file.LastWriteTime.DateTime'                          CreatedByPersonAliasId = ImportPersonAliasId'                          ForeignKey = documentForeignId'                          ForeignId = documentForeignId.AsIntegerOrNull()                      };                        rockFile.SetStorageEntityTypeId( attributeBinaryFileType.StorageEntityTypeId );                      rockFile.StorageEntitySettings = emptyJsonObject;                        if ( attributeBinaryFileType.AttributeValues != null )                      {                          rockFile.StorageEntitySettings = attributeBinaryFileType.AttributeValues                              .ToDictionary( a => a.Key' v => v.Value.Value ).ToJson();                      }                        // use base stream instead of file stream to keep the byte[]                      // NOTE: if byte[] converts to a string it will corrupt the stream                      using ( var fileContent = new StreamReader( file.Open() ) )                      {                          rockFile.ContentStream = new MemoryStream( fileContent.BaseStream.ReadBytesToEnd() );                      }                        newFileList.Add( new DocumentKeys()                      {                          PersonId = personKeys.PersonId'                          AttributeId = fileAttribute.Id'                          File = rockFile                      } );                        completedItems++;                      if ( completedItems % percentage < 1 )                      {                          var percentComplete = completedItems / percentage;                          ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) );                      }                      else if ( completedItems % ReportingNumber < 1 )                      {                          SaveFiles( newFileList );                            // Reset list                          newFileList.Clear();                          ReportPartialProgress();                      }                  }              }
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: foreach ( var file in folder.Entries )              {                  var fileExtension = Path.GetExtension( file.Name );                  if ( FileTypeBlackList.Contains( fileExtension ) )                  {                      LogException( "Binary File Import"' string.Format( "{0} filetype not allowed ({1})"' fileExtension' file.Name ) );                      continue;                  }                    var parsedFileName = file.Name.Split( '_' );                  // Ministry docs should follow this pattern:                  // 0. Firstname                  // 1. Lastname                  // 2. ForeignId                  // 3. Filename                  // 4. Doc Id                    var personForeignId = parsedFileName[2].AsType<int?>();                  var personKeys = ImportedPeople.FirstOrDefault( p => p.PersonForeignId == personForeignId );                  if ( personKeys != null )                  {                      var attributeName = string.Empty;                      var documentForeignId = string.Empty;                      if ( parsedFileName.Count() > 4 )                      {                          attributeName = parsedFileName[3];                          documentForeignId = parsedFileName[4];                      }                      else                      {                          var nameWithoutExtension = parsedFileName[3].ReplaceLastOccurrence( fileExtension' string.Empty );                          attributeName = Regex.Replace( nameWithoutExtension' "\\d{4'}[.\\w]+$"' string.Empty );                          documentForeignId = Regex.Match( nameWithoutExtension' "\\d+$" ).Value;                      }                        // append "Document" to attribute name to create unique attributes                      // this matches core attribute "Background Check Document"                      attributeName = !attributeName.EndsWith( "Document"' StringComparison.CurrentCultureIgnoreCase ) ? string.Format( "{0} Document"' attributeName ) : attributeName;                      var attributeKey = attributeName.RemoveSpecialCharacters();                        Attribute fileAttribute = null;                      var attributeBinaryFileType = ministryFileType;                      if ( !existingAttributes.ContainsKey( attributeKey ) )                      {                          fileAttribute = new Attribute                          {                              FieldTypeId = fileFieldTypeId'                              EntityTypeId = personEntityTypeId'                              EntityTypeQualifierColumn = string.Empty'                              EntityTypeQualifierValue = string.Empty'                              Key = attributeKey'                              Name = attributeName'                              Description = string.Format( "{0} created by binary file import"' attributeName )'                              IsGridColumn = false'                              IsMultiValue = false'                              IsRequired = false'                              AllowSearch = false'                              IsSystem = false'                              Order = 0                          };                            fileAttribute.AttributeQualifiers.Add( new AttributeQualifier()                          {                              Key = "binaryFileType"'                              Value = ministryFileType.Guid.ToString()                          } );                            lookupContext.Attributes.Add( fileAttribute );                          lookupContext.SaveChanges();                            existingAttributes.Add( fileAttribute.Key' fileAttribute );                      }                      else                      {                          // attribute already exists in Rock' override default file type with the Rock-specified file type                          fileAttribute = existingAttributes[attributeKey];                          var attributeBinaryFileTypeGuid = fileAttribute.AttributeQualifiers.FirstOrDefault( q => q.Key.Equals( "binaryFileType" ) );                          if ( attributeBinaryFileTypeGuid != null )                          {                              attributeBinaryFileType = binaryFileTypeService.Get( attributeBinaryFileTypeGuid.Value.AsGuid() );                          }                      }                        var rockFile = new Rock.Model.BinaryFile                      {                          IsSystem = false'                          IsTemporary = false'                          MimeType = GetMIMEType( file.Name )'                          BinaryFileTypeId = attributeBinaryFileType.Id'                          FileName = file.Name'                          Description = string.Format( "Imported as {0}"' file.Name )'                          CreatedDateTime = file.LastWriteTime.DateTime'                          ModifiedDateTime = file.LastWriteTime.DateTime'                          CreatedByPersonAliasId = ImportPersonAliasId'                          ForeignKey = documentForeignId'                          ForeignId = documentForeignId.AsIntegerOrNull()                      };                        rockFile.SetStorageEntityTypeId( attributeBinaryFileType.StorageEntityTypeId );                      rockFile.StorageEntitySettings = emptyJsonObject;                        if ( attributeBinaryFileType.AttributeValues != null )                      {                          rockFile.StorageEntitySettings = attributeBinaryFileType.AttributeValues                              .ToDictionary( a => a.Key' v => v.Value.Value ).ToJson();                      }                        // use base stream instead of file stream to keep the byte[]                      // NOTE: if byte[] converts to a string it will corrupt the stream                      using ( var fileContent = new StreamReader( file.Open() ) )                      {                          rockFile.ContentStream = new MemoryStream( fileContent.BaseStream.ReadBytesToEnd() );                      }                        newFileList.Add( new DocumentKeys()                      {                          PersonId = personKeys.PersonId'                          AttributeId = fileAttribute.Id'                          File = rockFile                      } );                        completedItems++;                      if ( completedItems % percentage < 1 )                      {                          var percentComplete = completedItems / percentage;                          ReportProgress( percentComplete' string.Format( "{0:N0} ministry document files imported ({1}% complete)."' completedItems' percentComplete ) );                      }                      else if ( completedItems % ReportingNumber < 1 )                      {                          SaveFiles( newFileList );                            // Reset list                          newFileList.Clear();                          ReportPartialProgress();                      }                  }              }
Magic Number,Excavator.BinaryFile,MinistryDocument,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\MinistryDocument.cs,Map,The following statement contains a magic number: ReportProgress( 100' string.Format( "Finished files import: {0:N0} ministry documents imported."' completedItems ) );
Magic Number,Excavator.BinaryFile,TransactionImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\TransactionImage.cs,Map,The following statement contains a magic number: var percentage = ( totalEntries - 1 ) / 100 + 1;
Magic Number,Excavator.BinaryFile,TransactionImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\TransactionImage.cs,Map,The following statement contains a magic number: ReportProgress( 100' string.Format( "Finished files import: {0:N0} transaction images imported."' completedItems ) );
Magic Number,Excavator.BinaryFile.PersonImage,PersonImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\PersonImage.cs,Map,The following statement contains a magic number: var percentage = ( totalEntries - 1 ) / 100 + 1;
Magic Number,Excavator.BinaryFile.PersonImage,PersonImage,C:\repos\NewSpring_Excavator\Excavator.BinaryFile\Maps\PersonImage.cs,Map,The following statement contains a magic number: ReportProgress( 100' string.Format( "Finished files import: {0:N0} person images imported."' completedItems ) );
