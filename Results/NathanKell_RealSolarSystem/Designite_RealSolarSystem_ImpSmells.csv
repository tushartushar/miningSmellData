Implementation smell,Namespace,Class,File,Method,Description
Long Method,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The method has 157 lines of code.
Long Method,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,setSite,The method has 124 lines of code.
Long Method,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The method has 149 lines of code.
Long Method,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The method has 112 lines of code.
Long Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadCB,The method has 242 lines of code.
Long Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The method has 1013 lines of code.
Long Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The method has 283 lines of code.
Complex Method,RealSolarSystem,CameraFixer,C:\repos\NathanKell_RealSolarSystem\Source\CameraFixer.cs,Start,Cyclomatic complexity of the method is 17
Complex Method,RealSolarSystem,CameraFixer,C:\repos\NathanKell_RealSolarSystem\Source\CameraFixer.cs,EditorBoundsFixer,Cyclomatic complexity of the method is 8
Complex Method,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,Cyclomatic complexity of the method is 15
Complex Method,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,Cyclomatic complexity of the method is 17
Complex Method,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDraw,Cyclomatic complexity of the method is 9
Complex Method,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,setSite,Cyclomatic complexity of the method is 36
Complex Method,RealSolarSystem,KSCSiteManager,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,KSCSiteManager,Cyclomatic complexity of the method is 8
Complex Method,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,Cyclomatic complexity of the method is 23
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,Cyclomatic complexity of the method is 8
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadCB,Cyclomatic complexity of the method is 35
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,Cyclomatic complexity of the method is 267
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,Cyclomatic complexity of the method is 27
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadExport,Cyclomatic complexity of the method is 14
Complex Method,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadRSS,Cyclomatic complexity of the method is 9
Complex Method,RealSolarSystem,SolarPanelFixer,C:\repos\NathanKell_RealSolarSystem\Source\SolarPanelFixer.cs,Start,Cyclomatic complexity of the method is 13
Complex Method,RealSolarSystem,TimeWarpFixer,C:\repos\NathanKell_RealSolarSystem\Source\TimeWarpFixer.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,RealSolarSystem,RSSWatchDog,C:\repos\NathanKell_RealSolarSystem\Source\Watchdogs.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,RealSolarSystem,RSSWatchDog,C:\repos\NathanKell_RealSolarSystem\Source\Watchdogs.cs,FixedUpdate,Cyclomatic complexity of the method is 11
Complex Method,RealSolarSystem,RSSWatchDog,C:\repos\NathanKell_RealSolarSystem\Source\Watchdogs.cs,UpdateAtmospheres,Cyclomatic complexity of the method is 11
Long Parameter List,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadTexture,The method has 5 parameters. Parameters: path' map' compress' upload' unreadable
Long Statement,RealSolarSystem,CameraFixer,C:\repos\NathanKell_RealSolarSystem\Source\CameraFixer.cs,Start,The length of the statement  "                print("*RSS* Fixing PCam. Min " + PlanetariumCamera.fetch.minDistance + "' Max " + PlanetariumCamera.fetch.maxDistance + ". Start " + PlanetariumCamera.fetch.startDistance + "' zoom " + PlanetariumCamera.fetch.zoomScaleFactor); " is 227.
Long Statement,RealSolarSystem,CameraFixer,C:\repos\NathanKell_RealSolarSystem\Source\CameraFixer.cs,Start,The length of the statement  "                print("Fixed. Min " + PlanetariumCamera.fetch.minDistance + "' Max " + PlanetariumCamera.fetch.maxDistance + ". Start " + PlanetariumCamera.fetch.startDistance + "' zoom " + PlanetariumCamera.fetch.zoomScaleFactor); " is 215.
Long Statement,RealSolarSystem,CameraFixer,C:\repos\NathanKell_RealSolarSystem\Source\CameraFixer.cs,EditorBoundsFixer,The length of the statement  "                        + "' bounds " + EditorBounds.Instance.constructionBounds.ToString() + "/" + EditorBounds.Instance.cameraOffsetBounds.ToString()); " is 129.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "            Debug.Log(String.Format("[CompatibilityChecker] Running checker version {0} from '{1}'"' _version' Assembly.GetExecutingAssembly().GetName().Name)); " is 148.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "                        Debug.LogWarning(String.Format("[CompatibilityChecker] Exception while invoking IsCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName().Name' e)); " is 161.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "                        Debug.LogWarning(String.Format("[CompatibilityChecker] Exception while invoking IsUnityCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName().Name' e)); " is 166.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "                message += "WARNING: You are using 64-bit KSP on Windows. This version of KSP is known to cause crashes. It's highly recommended that you use either 32-bit KSP on Windows or switch to Linux."; " is 192.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "                message += ((message == String.Empty) ? "Some" : "\n\nAdditionally' some") + " installed mods may be incompatible with this version of Kerbal Space Program. Features may be broken or disabled. Please check for updates to the listed mods."; " is 239.
Long Statement,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,Start,The length of the statement  "                    message += String.Format("\n\nThese mods are incompatible with KSP {0}.{1}.{2}:\n\n"' Versioning.version_major' Versioning.version_minor' Versioning.Revision); " is 159.
Long Statement,RealSolarSystem,ConfigNodeExtensions,C:\repos\NathanKell_RealSolarSystem\Source\ConfigNodeExtensions.cs,TryGetValue,The length of the statement  "                    MonoBehaviour.print("Exception: Error parsing as color4: original text: " + node.GetValue("name") + " --- exception " + e.Message); " is 131.
Long Statement,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The length of the statement  "                        print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e); " is 125.
Long Statement,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDraw,The length of the statement  "                        GUI.Label(new Rect((float)(point.x) + 28f' (float)(Screen.height - point.y) + 5f' 50' 20)' kvp.Value.displayName' siteText); " is 124.
Long Statement,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,setSite,The length of the statement  "				ScreenMessages.PostScreenMessage("Launch site changed to " + newSite.displayName' 2.5f' ScreenMessageStyle.LOWER_CENTER); " is 121.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "            if(HighLogic.LoadedScene == GameScenes.TRACKSTATION || HighLogic.LoadedScene == GameScenes.SPACECENTER || HighLogic.LoadedScene == GameScenes.FLIGHT) { " is 151.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as color4: original text: " + RSSSettings.GetValue("sunlightColor") + " --- exception " + e.Message); " is 128.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as float: original text: " + RSSSettings.GetValue("sunlightIntensity") + " --- exception " + e.Message); " is 131.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as float: original text: " + RSSSettings.GetValue("sunlightShadowStrength") + " --- exception " + e.Message); " is 136.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as color4: original text: " + RSSSettings.GetValue("scaledSunlightColor") + " --- exception " + e.Message); " is 134.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as float: original text: " + RSSSettings.GetValue("scaledSunlightIntensity") + " --- exception " + e.Message); " is 137.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "		                        print("*RSS* Error parsing as color4: original text: " + RSSSettings.GetValue("IVASunColor") + " --- exception " + e.Message); " is 126.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "		                        print("*RSS* Error parsing as float: original text: " + RSSSettings.GetValue("IVASunIntensity") + " --- exception " + e.Message); " is 129.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as color4: original text: " + RSSSettings.GetValue("sunlightLensFlareColor") + " --- exception " + e.Message); " is 137.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "                //Funny story behind locating this one. When I was typing "Light l" in the foreach function earlier' one of the suggestions " is 123.
Long Statement,RealSolarSystem,LightShifter,C:\repos\NathanKell_RealSolarSystem\Source\LightShifter.cs,Start,The length of the statement  "	                        print("*RSS* Error parsing as color4: original text: " + RSSSettings.GetValue("ambientLightColor") + " --- exception " + e.Message); " is 132.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The length of the statement  "                    brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces " is 132.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The length of the statement  "                            vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor' " is 136.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The length of the statement  "                        brokenString = currentText.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces " is 136.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The length of the statement  "                                triangles = triangles + 3 * (brokenString.Length - 2); /*brokenString.Length is 3 or greater since a face must have at least " is 124.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The length of the statement  "                                    brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal) " is 133.
Long Statement,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The length of the statement  "                                while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face. " is 136.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The length of the statement  "                        afg.waveLength = new Color((float)Math.Pow(1 / col.x' 0.25)' (float)Math.Pow(1 / col.y' 0.25)' (float)Math.Pow(1 / col.z' 0.25)' 1f); " is 133.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The length of the statement  "                        print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("invWaveLength") + " --- exception " + e.Message); " is 124.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The length of the statement  "                        print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("waveLength") + " --- exception " + e.Message); " is 121.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadCB,The length of the statement  "                    print("*RSS* finished with " + body.GetName() + ".pressureCurve (" + body.pressureCurve.keys.Length.ToString() + " keys)"); " is 123.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The length of the statement  "                            body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3); " is 138.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The length of the statement  "                            body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass)); " is 162.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The length of the statement  "                                body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly; " is 148.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The length of the statement  "                                                            print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("noiseColor") + " --- exception " + e.Message); " is 120.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The length of the statement  "                                                print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("repositionRadial") + " --- exception " + e.Message); " is 125.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The length of the statement  "                                                print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("reorientInitialUp") + " --- exception " + e.Message); " is 126.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The length of the statement  "                                            PQSMod_VertexColorMapBlend colorMap = (PQSMod_VertexColorMapBlend)tempObj.AddComponent(typeof(PQSMod_VertexColorMapBlend)); " is 123.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The length of the statement  "                                        PQSMod_VertexSimplexNoiseColor vertColor = (PQSMod_VertexSimplexNoiseColor)tempObj.AddComponent(typeof(PQSMod_VertexSimplexNoiseColor)); " is 136.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                                System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG()); " is 170.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                                print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message); " is 121.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                                            float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right. " is 127.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                                            print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor); " is 125.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                                scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet. " is 169.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The length of the statement  "                //print("*RSS* Found AG " + ag.name + " " + (ag.tag == null ? "" : ag.tag) + ". Planet " + (ag.planet == null ? "NULL" : ag.planet.name)); " is 138.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadExport,The length of the statement  "                            print("*RSS* Error parsing as col3: original text: " + exportNode.GetValue("oceanColor") + " --- exception " + e.Message); " is 122.
Long Statement,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadRSS,The length of the statement  "                foreach (CelestialBody body in FlightGlobals.fetch.bodies) //Resources.FindObjectsOfTypeAll(typeof(CelestialBody))) //in FlightGlobals.fetch.bodies) " is 148.
Long Statement,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadAnimationCurve,The length of the statement  "                        MonoBehaviour.print("*RSS* Invalid animationCurve data: animationCurve data must have exactly two or four parameters!"); " is 120.
Long Statement,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadTexture,The length of the statement  "                            GameDatabase.TextureInfo tInfo = DDSLoader.DatabaseLoaderTexture_DDS.LoadDDS(path' !unreadable' path.Contains("NRM")' -1' upload); " is 130.
Long Statement,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,DumpSST,The length of the statement  "            print("Pos = (" + t.position.x + "' " + t.position.y + "' " + t.position.z + "); lPos = (" + t.localPosition.x + "' " + t.localPosition.y + "' " + t.localPosition.z + ")"); " is 172.
Long Statement,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,PrintComponents,The length of the statement  "            print("Transform " + t.name + " pos" + Vec3ToString(t.position) + "' lp" + Vec3ToString(t.localPosition) + "' scale" + Vec3ToString(t.lossyScale) +"'  ls" + Vec3ToString(t.localScale) + " has components:"); " is 206.
Long Statement,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,dumpKeys,The length of the statement  "                    print("key'" + i + " = " + c.keys[i].time + " " + c.keys[i].value + " " + c.keys[i].inTangent + " " + c.keys[i].outTangent); " is 124.
Complex Conditional,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDraw,The conditional expression  "siteLocations.Count < 1 || lsTexture == null || !showSites || !iconDisplayDistance()"  is complex.
Complex Conditional,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The conditional expression  "!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ")                          && !currentText.StartsWith("vn ")"  is complex.
Complex Conditional,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The conditional expression  "!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap ")"  is complex.
Empty Catch Block,RealSolarSystem,SolarPanelFixer,C:\repos\NathanKell_RealSolarSystem\Source\SolarPanelFixer.cs,Start,The method has an empty catch block.
Magic Number,RealSolarSystem,CBRotation,C:\repos\NathanKell_RealSolarSystem\Source\CBRotation.cs,AngleAtTime,The following statement contains a magic number: return (initialRotation + 360.0 / rotationPeriod * time) % 360.0;
Magic Number,RealSolarSystem,CBRotation,C:\repos\NathanKell_RealSolarSystem\Source\CBRotation.cs,AngleAtTime,The following statement contains a magic number: return (initialRotation + 360.0 / rotationPeriod * time) % 360.0;
Magic Number,RealSolarSystem,CBRotation,C:\repos\NathanKell_RealSolarSystem\Source\CBRotation.cs,AngularVelocity,The following statement contains a magic number: return Tilt() * Vector3d.down * (Math.PI * 2 / rotationPeriod);
Magic Number,RealSolarSystem,CBRotation,C:\repos\NathanKell_RealSolarSystem\Source\CBRotation.cs,zUpAngularVelocity,The following statement contains a magic number: return Tilt() * Vector3d.back * (Math.PI * 2 / rotationPeriod);
Magic Number,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,IsCompatible,The following statement contains a magic number: return Versioning.version_major == 0 && Versioning.version_minor == 90 && Versioning.Revision == 0;
Magic Number,RealSolarSystem,CompatibilityChecker,C:\repos\NathanKell_RealSolarSystem\Source\Checkers.cs,IsWin64,The following statement contains a magic number: return (IntPtr.Size == 8) && (Environment.OSVersion.Platform == PlatformID.Win32NT);
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,Update,The following statement contains a magic number: if (counter < 5)              {                  counter += TimeWarp.fixedDeltaTime;                  return;              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,OnDraw,The following statement contains a magic number: if (isCompatible && GUIOpen)              {                  //print("[AFG Editor] OnDraw");                  if (HighLogic.LoadedSceneIsFlight && FlightGlobals.ActiveVessel != null)                      windowPosition = GUI.Window(69105' windowPosition' ShowGUI' "Wavelength Parameters"' windowStyle);              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (afg != null)              {                  //print("[AFG Editor]: ShowGUI");                  Color waveLength;                  waveLength.a = afg.waveLength.a;                  //float innerRadius;                  //float atmoHeightScale;                  //float eSun;                  //float Kr;                  //float Km;                    /*                  GUILayout.BeginVertical();                  //GUI.Label(new Rect(65' 40' 200' 30)' "Wavelength Parameters");                                GUILayout.Label("Red: " + afg.waveLength.r.ToString());                  waveLength.r = GUILayout.HorizontalSlider(afg.waveLength.r' -2.0F' 2.0F);                  GUILayout.Label("Green: " + afg.waveLength.g.ToString());                  waveLength.g = GUILayout.HorizontalSlider(afg.waveLength.g' -2.0F' 2.0F);                  GUILayout.Label("Blue: " + afg.waveLength.b.ToString());                  waveLength.b = GUILayout.HorizontalSlider(afg.waveLength.b' -2.0F' 2.0F);                  eSun = GUILayout.HorizontalSlider(afg.ESun' 0.0f' 1.0f);                  Kr = GUILayout.HorizontalSlider(afg.Kr' 0.0f' 1.0f);                  Km = GUILayout.HorizontalSlider(afg.Km' 0.0f' 1.0f);                  GUILayout.EndVertical();                  */                    float rf;                  float gf;                  float bf;                  float af;                  float Esunf;                  float Krf;                  float Kmf;                  float innerf;                  float outerf;                    GUILayout.BeginHorizontal();                  GUILayout.Label("Red");                  rt = GUILayout.TextField(rt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Green");                  gt = GUILayout.TextField(gt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Blue");                  bt = GUILayout.TextField(bt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Alpha");                  at = GUILayout.TextField(at' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("ESun");                  ESunt = GUILayout.TextField(ESunt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Kr");                  Krt = GUILayout.TextField(Krt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("Km");                  Kmt = GUILayout.TextField(Kmt' 10);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("InnerR");                  innert = GUILayout.TextField(innert' 15);                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("OuterR");                  outert = GUILayout.TextField(outert' 15);                  GUILayout.EndHorizontal();                    if (GUILayout.Button("Apply"))                  {                      try                      {                          if(float.TryParse(rt' out rf)) afg.waveLength.r = rf;                          if (float.TryParse(gt' out gf)) afg.waveLength.g = gf;                          if (float.TryParse(bt' out bf)) afg.waveLength.b = bf;                          if (float.TryParse(bt' out af)) afg.waveLength.a = af;                          if (float.TryParse(ESunt' out Esunf)) afg.ESun = Esunf;                          if (float.TryParse(Krt' out Krf)) afg.Kr = Krf;                          if (float.TryParse(Kmt' out Kmf)) afg.Km = Kmf;                          afg.KrESun = Krf * Esunf;                          afg.KmESun = Kmf * Esunf;                          afg.Kr4PI = Krf * 4f * (float)Math.PI;                          afg.Km4PI = Kmf * 4f * (float)Math.PI;                          if (float.TryParse(innert' out innerf)) afg.innerRadius = innerf * ScaledSpace.InverseScaleFactor;                          if (float.TryParse(outert' out outerf)) afg.outerRadius = outerf * ScaledSpace.InverseScaleFactor;                            // compute relations                          afg.scale = 1f / (afg.outerRadius - afg.innerRadius);                          afg.scaleDepth = -0.25f;                          afg.scaleOverScaleDepth = afg.scale / afg.scaleDepth;                          afg.outerRadius2 = afg.outerRadius * afg.outerRadius;                          afg.innerRadius2 = afg.innerRadius * afg.innerRadius;                            // set params                          MethodInfo setMaterial = afg.GetType().GetMethod("SetMaterial"' BindingFlags.NonPublic | BindingFlags.Instance);                          setMaterial.Invoke(afg' new object[] { true });                      }                      catch (Exception e)                      {                          print("*RSS* *ERROR* setting AtmosphereFromGround " + afg.name + " for body " + FlightGlobals.getMainBody().name + ": " + e);                      }                  }              }              else              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("No atmosphere");                  GUILayout.EndHorizontal();                  GUILayout.BeginHorizontal();                  GUILayout.Label("for current body");                  GUILayout.EndHorizontal();              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (cams != null)              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("CAMERA EDITOR");                  GUILayout.EndHorizontal();                  foreach (CameraWrapper cam in cams)                  {                      GUILayout.BeginHorizontal();                      GUILayout.Label("Camera: " + cam.camName);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Depth");                      cam.depth = GUILayout.TextField(cam.depth' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Far Clip");                      cam.farClipPlane = GUILayout.TextField(cam.farClipPlane' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Near Clip");                      cam.nearClipPlane = GUILayout.TextField(cam.nearClipPlane' 10);                      GUILayout.EndHorizontal();                        /*for (int i = 0; i < cam.layerCullDistances.Count; i++)                      {                          GUILayout.BeginHorizontal();                          GUILayout.Label("Cull Dist " + i);                          cam.layerCullDistances[i] = GUILayout.TextField(cam.layerCullDistances[i]' 10);                          GUILayout.EndHorizontal();                      }*/                        if (GUILayout.Button("Apply to " + cam.camName))                      {                          cam.Apply();                      }                  }              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (cams != null)              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("CAMERA EDITOR");                  GUILayout.EndHorizontal();                  foreach (CameraWrapper cam in cams)                  {                      GUILayout.BeginHorizontal();                      GUILayout.Label("Camera: " + cam.camName);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Depth");                      cam.depth = GUILayout.TextField(cam.depth' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Far Clip");                      cam.farClipPlane = GUILayout.TextField(cam.farClipPlane' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Near Clip");                      cam.nearClipPlane = GUILayout.TextField(cam.nearClipPlane' 10);                      GUILayout.EndHorizontal();                        /*for (int i = 0; i < cam.layerCullDistances.Count; i++)                      {                          GUILayout.BeginHorizontal();                          GUILayout.Label("Cull Dist " + i);                          cam.layerCullDistances[i] = GUILayout.TextField(cam.layerCullDistances[i]' 10);                          GUILayout.EndHorizontal();                      }*/                        if (GUILayout.Button("Apply to " + cam.camName))                      {                          cam.Apply();                      }                  }              }
Magic Number,RealSolarSystem,AFGEditor,C:\repos\NathanKell_RealSolarSystem\Source\GUI.cs,ShowGUI,The following statement contains a magic number: if (cams != null)              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("CAMERA EDITOR");                  GUILayout.EndHorizontal();                  foreach (CameraWrapper cam in cams)                  {                      GUILayout.BeginHorizontal();                      GUILayout.Label("Camera: " + cam.camName);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Depth");                      cam.depth = GUILayout.TextField(cam.depth' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Far Clip");                      cam.farClipPlane = GUILayout.TextField(cam.farClipPlane' 10);                      GUILayout.EndHorizontal();                        GUILayout.BeginHorizontal();                      GUILayout.Label("Near Clip");                      cam.nearClipPlane = GUILayout.TextField(cam.nearClipPlane' 10);                      GUILayout.EndHorizontal();                        /*for (int i = 0; i < cam.layerCullDistances.Count; i++)                      {                          GUILayout.BeginHorizontal();                          GUILayout.Label("Cull Dist " + i);                          cam.layerCullDistances[i] = GUILayout.TextField(cam.layerCullDistances[i]' 10);                          GUILayout.EndHorizontal();                      }*/                        if (GUILayout.Button("Apply to " + cam.camName))                      {                          cam.Apply();                      }                  }              }
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,Start,The following statement contains a magic number: RenderingManager.AddToPostDrawQueue(2' this.onDraw);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,Start,The following statement contains a magic number: RenderingManager.AddToPostDrawQueue(3' this.onDrawGUI);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,OnDestroy,The following statement contains a magic number: RenderingManager.RemoveFromPostDrawQueue(2' this.onDraw);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,OnDestroy,The following statement contains a magic number: RenderingManager.RemoveFromPostDrawQueue(3' this.onDrawGUI);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(oldButton) {  				if(GUI.Button(new Rect(Screen.width - 100' 45' 100' 30)' "Launch Sites")) {  					showWindow = !showWindow;  				}  			} else {  				if(GUI.Button(new Rect(Screen.width - 33' 45' 28' 28)' (showWindow ? lsButtonHighlight : lsButtonNormal)' bStyle)) {  					showWindow = !showWindow;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(GUI.Button(new Rect(Screen.width - 33' 78' 28' 28)' (showSites ? eyeButtonHighlight : eyeButtonNormal)' bStyle)) {  				showSites = !showSites;  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(GUI.Button(new Rect(Screen.width - 33' 78' 28' 28)' (showSites ? eyeButtonHighlight : eyeButtonNormal)' bStyle)) {  				showSites = !showSites;  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(GUI.Button(new Rect(Screen.width - 33' 78' 28' 28)' (showSites ? eyeButtonHighlight : eyeButtonNormal)' bStyle)) {  				showSites = !showSites;  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(GUI.Button(new Rect(Screen.width - 33' 78' 28' 28)' (showSites ? eyeButtonHighlight : eyeButtonNormal)' bStyle)) {  				showSites = !showSites;  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDrawGUI,The following statement contains a magic number: if(showWindow) {  				if(oldButton) {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 75' 300' 400));  				} else {  					GUILayout.BeginArea(new Rect(Screen.width - 333' 45' 300' 400));  				}  				scrollPosition = GUILayout.BeginScrollView(scrollPosition' GUILayout.Width(300)' GUILayout.Height(400));  				Color defColor = GUI.color;  				bool isActiveSite = false;  				foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					GUILayout.BeginHorizontal();  					if(GUILayout.Button(magButtonNormal' bStyle' GUILayout.MaxWidth(28))) {  						focusOnSite(kvp.Value.geographicLocation);  					}  					if(isActiveSite) {  						GUI.contentColor = XKCDColors.ElectricLime;  					}  					if(GUILayout.Button(new GUIContent(kvp.Value.displayName' kvp.Value.description))) {  						if(isActiveSite) {  							ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  						} else {  							setSite(kvp.Value);  						}  					}  					GUI.contentColor = defColor;  					GUILayout.EndHorizontal();  				}  				GUILayout.EndScrollView();  				GUILayout.EndArea();  				  				GUI.backgroundColor = XKCDColors.AlmostBlack;  				if(curTooltip != "") {  					if(oldButton) {  						GUI.Label(new Rect(Screen.width - 633' 75' 300' 400)' GUI.tooltip' infoLabel);  					} else {  						GUI.Label(new Rect(Screen.width - 633' 45' 300' 400)' GUI.tooltip' infoLabel);  					}  				}  				if(Event.current.type == EventType.Repaint) {  					curTooltip = GUI.tooltip;  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDraw,The following statement contains a magic number: foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  				Camera camera = MapView.MapCamera.camera;  				Vector3d point = Kerbin.GetWorldSurfacePosition(kvp.Value.geographicLocation.x' kvp.Value.geographicLocation.y' 0);  				if(!IsOccluded(point' Kerbin)) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					point = ScaledSpace.LocalToScaledSpace(point);  					point = camera.WorldToScreenPoint(point);  					Rect iconBound = new Rect((float) point.x' (float) (Screen.height - point.y)' 28f' 28f);  					if(isActiveSite) {  						Graphics.DrawTexture(iconBound' lsActiveTexture);  					} else {  						Graphics.DrawTexture(iconBound' lsTexture);  					}    					if(iconBound.Contains(Event.current.mousePosition)) {                          GUI.Label(new Rect((float)(point.x) + 28f' (float)(Screen.height - point.y) + 5f' 50' 20)' kvp.Value.displayName' siteText);  						if(Event.current.type == EventType.mouseDown && Event.current.button == 0) {  							if(isActiveSite) {  								ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  							} else {  								setSite(kvp.Value);  							}  						}  					}  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,onDraw,The following statement contains a magic number: foreach(KeyValuePair<string' LaunchSite> kvp in siteLocations) {  				Camera camera = MapView.MapCamera.camera;  				Vector3d point = Kerbin.GetWorldSurfacePosition(kvp.Value.geographicLocation.x' kvp.Value.geographicLocation.y' 0);  				if(!IsOccluded(point' Kerbin)) {  					isActiveSite = kvp.Value.name.Equals(activeSite);  					point = ScaledSpace.LocalToScaledSpace(point);  					point = camera.WorldToScreenPoint(point);  					Rect iconBound = new Rect((float) point.x' (float) (Screen.height - point.y)' 28f' 28f);  					if(isActiveSite) {  						Graphics.DrawTexture(iconBound' lsActiveTexture);  					} else {  						Graphics.DrawTexture(iconBound' lsTexture);  					}    					if(iconBound.Contains(Event.current.mousePosition)) {                          GUI.Label(new Rect((float)(point.x) + 28f' (float)(Screen.height - point.y) + 5f' 50' 20)' kvp.Value.displayName' siteText);  						if(Event.current.type == EventType.mouseDown && Event.current.button == 0) {  							if(isActiveSite) {  								ScreenMessages.PostScreenMessage("Cannot set launch site to active site."' 2.5f' ScreenMessageStyle.LOWER_CENTER);  							} else {  								setSite(kvp.Value);  							}  						}  					}  				}  			}
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,focusOnSite,The following statement contains a magic number: float distance = (float) (Kerbin.Radius * 0.00035);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,IsOccluded,The following statement contains a magic number: if(Vector3d.Angle(camPos - loc' body.position - loc) > 90) { return false; }
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,loadTextures,The following statement contains a magic number: infoLabel.padding = new RectOffset(5' 5' 5' 5);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,loadTextures,The following statement contains a magic number: infoLabel.padding = new RectOffset(5' 5' 5' 5);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,loadTextures,The following statement contains a magic number: infoLabel.padding = new RectOffset(5' 5' 5' 5);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,loadTextures,The following statement contains a magic number: infoLabel.padding = new RectOffset(5' 5' 5' 5);
Magic Number,RealSolarSystem,KSCSwitcher,C:\repos\NathanKell_RealSolarSystem\Source\KSCSwitcher.cs,iconDisplayDistance,The following statement contains a magic number: return MapView.MapCamera.Distance < 25000 && MapView.MapCamera.target.name == Kerbin.name;
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following statement contains a magic number: using (StreamReader stream = File.OpenText(filename))              {                  stream.ReadLine();                  string curLine = stream.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                    while (curLine != null)                  {                      curLine = curLine.Trim();                           //Trim the current line                      brokenString = curLine.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                      //if(log) MonoBehaviour.print(curLine);                      switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }                      curLine = stream.ReadLine();                      if (curLine != null)                      {                          curLine = curLine.Replace("  "' " ");                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateTangents,The following statement contains a magic number: int triangleCount = mesh.triangles.Length / 3;
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateTangents,The following statement contains a magic number: for (int i = 0; i < triangleCount; i++)              {                    int i1 = mesh.triangles[tri];                  int i2 = mesh.triangles[tri + 1];                  int i3 = mesh.triangles[tri + 2];                    Vector3 v1 = mesh.vertices[i1];                  Vector3 v2 = mesh.vertices[i2];                  Vector3 v3 = mesh.vertices[i3];                    Vector2 w1 = mesh.uv[i1];                  Vector2 w2 = mesh.uv[i2];                  Vector2 w3 = mesh.uv[i3];                      float x1 = v2.x - v1.x;                  float x2 = v3.x - v1.x;                  float y1 = v2.y - v1.y;                  float y2 = v3.y - v1.y;                  float z1 = v2.z - v1.z;                  float z2 = v3.z - v1.z;                    float s1 = w2.x - w1.x;                  float s2 = w3.x - w1.x;                  float t1 = w2.y - w1.y;                  float t2 = w3.y - w1.y;                    float r = 1.0f / (s1 * t2 - s2 * t1);                    sdir.x = (t2 * x1 - t1 * x2);                  sdir.y = (t2 * y1 - t1 * y2);                  sdir.z = (t2 * z1 - t1 * z2);                  sdir *= r;                    tdir.x = (s1 * x2 - s2 * x1);                  tdir.y = (s1 * y2 - s2 * y1);                  tdir.z = (s1 * z2 - s2 * z1);                  tdir *= r;                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;                    tri += 3;              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateTangents,The following statement contains a magic number: for (int i = 0; i < triangleCount; i++)              {                    int i1 = mesh.triangles[tri];                  int i2 = mesh.triangles[tri + 1];                  int i3 = mesh.triangles[tri + 2];                    Vector3 v1 = mesh.vertices[i1];                  Vector3 v2 = mesh.vertices[i2];                  Vector3 v3 = mesh.vertices[i3];                    Vector2 w1 = mesh.uv[i1];                  Vector2 w2 = mesh.uv[i2];                  Vector2 w3 = mesh.uv[i3];                      float x1 = v2.x - v1.x;                  float x2 = v3.x - v1.x;                  float y1 = v2.y - v1.y;                  float y2 = v3.y - v1.y;                  float z1 = v2.z - v1.z;                  float z2 = v3.z - v1.z;                    float s1 = w2.x - w1.x;                  float s2 = w3.x - w1.x;                  float t1 = w2.y - w1.y;                  float t2 = w3.y - w1.y;                    float r = 1.0f / (s1 * t2 - s2 * t1);                    sdir.x = (t2 * x1 - t1 * x2);                  sdir.y = (t2 * y1 - t1 * y2);                  sdir.z = (t2 * z1 - t1 * z2);                  sdir *= r;                    tdir.x = (s1 * x2 - s2 * x1);                  tdir.y = (s1 * y2 - s2 * y1);                  tdir.z = (s1 * z2 - s2 * z1);                  tdir *= r;                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;                    tri += 3;              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,MeshToString,The following statement contains a magic number: for (int material = 0; material < m.subMeshCount; material++)              {                  sb.Append("\n");                  sb.Append("usemtl ").Append(mats[material].name).Append("\n");                  sb.Append("usemap ").Append(mats[material].name).Append("\n");                    int[] triangles = m.GetTriangles(material);                  for (int i = 0; i < triangles.Length; i += 3)                  {                      sb.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n"'                          triangles[i] + 1' triangles[i + 1] + 1' triangles[i + 2] + 1));                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,MeshToString,The following statement contains a magic number: for (int material = 0; material < m.subMeshCount; material++)              {                  sb.Append("\n");                  sb.Append("usemtl ").Append(mats[material].name).Append("\n");                  sb.Append("usemap ").Append(mats[material].name).Append("\n");                    int[] triangles = m.GetTriangles(material);                  for (int i = 0; i < triangles.Length; i += 3)                  {                      sb.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n"'                          triangles[i] + 1' triangles[i + 1] + 1' triangles[i + 2] + 1));                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ")                          && !currentText.StartsWith("vn "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                           //Trim the current line                          brokenString = currentText.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                          switch (brokenString[0])                          {                              case "v":                                  vertices++;                                  break;                              case "vt":                                  vt++;                                  break;                              case "vn":                                  vn++;                                  break;                              case "f":                                  face = face + brokenString.Length - 1;                                  triangles = triangles + 3 * (brokenString.Length - 2); /*brokenString.Length is 3 or greater since a face must have at least                                                                                       3 vertices.  For each additional vertice' there is an additional                                                                                       triangle in the mesh (hence this formula).*/                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ")                          && !currentText.StartsWith("vn "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                           //Trim the current line                          brokenString = currentText.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                          switch (brokenString[0])                          {                              case "v":                                  vertices++;                                  break;                              case "vt":                                  vt++;                                  break;                              case "vn":                                  vn++;                                  break;                              case "f":                                  face = face + brokenString.Length - 1;                                  triangles = triangles + 3 * (brokenString.Length - 2); /*brokenString.Length is 3 or greater since a face must have at least                                                                                       3 vertices.  For each additional vertice' there is an additional                                                                                       triangle in the mesh (hence this formula).*/                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                  char[] splitIdentifier = { ' ' };                  string[] brokenString;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ")                          && !currentText.StartsWith("vn "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                           //Trim the current line                          brokenString = currentText.Split(splitIdentifier' 50);      //Split the line into an array' separating the original line by blank spaces                          switch (brokenString[0])                          {                              case "v":                                  vertices++;                                  break;                              case "vt":                                  vt++;                                  break;                              case "vn":                                  vn++;                                  break;                              case "f":                                  face = face + brokenString.Length - 1;                                  triangles = triangles + 3 * (brokenString.Length - 2); /*brokenString.Length is 3 or greater since a face must have at least                                                                                       3 vertices.  For each additional vertice' there is an additional                                                                                       triangle in the mesh (hence this formula).*/                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader(entireText))              {                  string currentText = reader.ReadLine();                    char[] splitIdentifier = { ' ' };                  char[] splitIdentifier2 = { '/' };                  string[] brokenString;                  string[] brokenBrokenString;                  int f = 0;                  int f2 = 0;                  int v = 0;                  int vn = 0;                  int vt = 0;                  int vt1 = 0;                  int vt2 = 0;                  while (currentText != null)                  {                      if (!currentText.StartsWith("f ") && !currentText.StartsWith("v ") && !currentText.StartsWith("vt ") &&                          !currentText.StartsWith("vn ") && !currentText.StartsWith("g ") && !currentText.StartsWith("usemtl ") &&                          !currentText.StartsWith("mtllib ") && !currentText.StartsWith("vt1 ") && !currentText.StartsWith("vt2 ") &&                          !currentText.StartsWith("vc ") && !currentText.StartsWith("usemap "))                      {                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");                          }                      }                      else                      {                          currentText = currentText.Trim();                          brokenString = currentText.Split(splitIdentifier' 50);                          switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }                          currentText = reader.ReadLine();                          if (currentText != null)                          {                              currentText = currentText.Replace("  "' " ");       //Some .obj files insert double spaces' this removes them.                          }                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,OnGUI,The following statement contains a magic number: if (showGUI)              {                  if (GuiIdx < 0)                  {                      GuiIdx = "RealSolarSystem".GetHashCode();                      screenRect = new Rect(100' 200' 300' 220);                  }                  screenRect = GUILayout.Window(GuiIdx' screenRect' RSSGUI' "RealSolarSystem Status"' skins.window);              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,OnGUI,The following statement contains a magic number: if (showGUI)              {                  if (GuiIdx < 0)                  {                      GuiIdx = "RealSolarSystem".GetHashCode();                      screenRect = new Rect(100' 200' 300' 220);                  }                  screenRect = GUILayout.Window(GuiIdx' screenRect' RSSGUI' "RealSolarSystem Status"' skins.window);              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,OnGUI,The following statement contains a magic number: if (showGUI)              {                  if (GuiIdx < 0)                  {                      GuiIdx = "RealSolarSystem".GetHashCode();                      screenRect = new Rect(100' 200' 300' 220);                  }                  screenRect = GUILayout.Window(GuiIdx' screenRect' RSSGUI' "RealSolarSystem Status"' skins.window);              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,OnGUI,The following statement contains a magic number: if (showGUI)              {                  if (GuiIdx < 0)                  {                      GuiIdx = "RealSolarSystem".GetHashCode();                      screenRect = new Rect(100' 200' 300' 220);                  }                  screenRect = GUILayout.Window(GuiIdx' screenRect' RSSGUI' "RealSolarSystem Status"' skins.window);              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The following statement contains a magic number: if (modNode != null)              {                  float ftmp;                  // the default                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  if (modNode.TryGetValue("outerRadius"' ref afg.outerRadius))                  {                      afg.outerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.HasValue("outerRadiusAtmo"))                  {                      afg.outerRadius = ((float)body.Radius + body.maxAtmosphereAltitude) * ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("outerRadiusMult"' ref afg.outerRadius))                  {                      afg.outerRadius *= (float)body.Radius * ScaledSpace.InverseScaleFactor;                  }                    // the default                  afg.innerRadius = afg.outerRadius * 0.975f;                  if (modNode.TryGetValue("innerRadius"' ref afg.innerRadius))                  {                      afg.innerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("innerRadiusMult"' ref afg.innerRadius))                  {                      afg.innerRadius *= afg.outerRadius;                  }                    modNode.TryGetValue("doScale"' ref afg.doScale);                  if (modNode.HasValue("transformScale"))                  {                      if (float.TryParse(modNode.GetValue("transformScale")' out ftmp) && afg.transform != null)                          afg.transform.localScale = new Vector3(ftmp' ftmp' ftmp);                  }                  else if (modNode.HasValue("transformAtmo"))                  {                      afg.transform.localScale = Vector3.one * ((float)(body.Radius + body.maxAtmosphereAltitude) / (float)body.Radius);                  }                      if (modNode.HasValue("invWaveLength"))                  {                      //will be recomputed by SQUAD anyway so no point.                      // so instead' compute waveLength from it                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("invWaveLength"));                          afg.invWaveLength = new Color(col.x' col.y' col.z' col.w);                          afg.waveLength = new Color((float)Math.Pow(1 / col.x' 0.25)' (float)Math.Pow(1 / col.y' 0.25)' (float)Math.Pow(1 / col.z' 0.25)' 1f);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("invWaveLength") + " --- exception " + e.Message);                      }                  }                  if (modNode.HasValue("waveLength"))                  {                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("waveLength"));                          afg.waveLength = new Color(col.x' col.y' col.z' col.w);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("waveLength") + " --- exception " + e.Message);                      }                  }                  modNode.TryGetValue("Kr"' ref afg.Kr);                  modNode.TryGetValue("Km"' ref afg.Km);                  modNode.TryGetValue("ESun"' ref afg.ESun);                  modNode.TryGetValue("g"' ref afg.g);                  modNode.TryGetValue("samples"' ref afg.samples);              }              else              {                  // the defaults                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  afg.innerRadius = afg.outerRadius * 0.975f;              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The following statement contains a magic number: if (modNode != null)              {                  float ftmp;                  // the default                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  if (modNode.TryGetValue("outerRadius"' ref afg.outerRadius))                  {                      afg.outerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.HasValue("outerRadiusAtmo"))                  {                      afg.outerRadius = ((float)body.Radius + body.maxAtmosphereAltitude) * ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("outerRadiusMult"' ref afg.outerRadius))                  {                      afg.outerRadius *= (float)body.Radius * ScaledSpace.InverseScaleFactor;                  }                    // the default                  afg.innerRadius = afg.outerRadius * 0.975f;                  if (modNode.TryGetValue("innerRadius"' ref afg.innerRadius))                  {                      afg.innerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("innerRadiusMult"' ref afg.innerRadius))                  {                      afg.innerRadius *= afg.outerRadius;                  }                    modNode.TryGetValue("doScale"' ref afg.doScale);                  if (modNode.HasValue("transformScale"))                  {                      if (float.TryParse(modNode.GetValue("transformScale")' out ftmp) && afg.transform != null)                          afg.transform.localScale = new Vector3(ftmp' ftmp' ftmp);                  }                  else if (modNode.HasValue("transformAtmo"))                  {                      afg.transform.localScale = Vector3.one * ((float)(body.Radius + body.maxAtmosphereAltitude) / (float)body.Radius);                  }                      if (modNode.HasValue("invWaveLength"))                  {                      //will be recomputed by SQUAD anyway so no point.                      // so instead' compute waveLength from it                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("invWaveLength"));                          afg.invWaveLength = new Color(col.x' col.y' col.z' col.w);                          afg.waveLength = new Color((float)Math.Pow(1 / col.x' 0.25)' (float)Math.Pow(1 / col.y' 0.25)' (float)Math.Pow(1 / col.z' 0.25)' 1f);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("invWaveLength") + " --- exception " + e.Message);                      }                  }                  if (modNode.HasValue("waveLength"))                  {                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("waveLength"));                          afg.waveLength = new Color(col.x' col.y' col.z' col.w);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("waveLength") + " --- exception " + e.Message);                      }                  }                  modNode.TryGetValue("Kr"' ref afg.Kr);                  modNode.TryGetValue("Km"' ref afg.Km);                  modNode.TryGetValue("ESun"' ref afg.ESun);                  modNode.TryGetValue("g"' ref afg.g);                  modNode.TryGetValue("samples"' ref afg.samples);              }              else              {                  // the defaults                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  afg.innerRadius = afg.outerRadius * 0.975f;              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,UpdateAFG,The following statement contains a magic number: if (modNode != null)              {                  float ftmp;                  // the default                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  if (modNode.TryGetValue("outerRadius"' ref afg.outerRadius))                  {                      afg.outerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.HasValue("outerRadiusAtmo"))                  {                      afg.outerRadius = ((float)body.Radius + body.maxAtmosphereAltitude) * ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("outerRadiusMult"' ref afg.outerRadius))                  {                      afg.outerRadius *= (float)body.Radius * ScaledSpace.InverseScaleFactor;                  }                    // the default                  afg.innerRadius = afg.outerRadius * 0.975f;                  if (modNode.TryGetValue("innerRadius"' ref afg.innerRadius))                  {                      afg.innerRadius *= ScaledSpace.InverseScaleFactor;                  }                  else if (modNode.TryGetValue("innerRadiusMult"' ref afg.innerRadius))                  {                      afg.innerRadius *= afg.outerRadius;                  }                    modNode.TryGetValue("doScale"' ref afg.doScale);                  if (modNode.HasValue("transformScale"))                  {                      if (float.TryParse(modNode.GetValue("transformScale")' out ftmp) && afg.transform != null)                          afg.transform.localScale = new Vector3(ftmp' ftmp' ftmp);                  }                  else if (modNode.HasValue("transformAtmo"))                  {                      afg.transform.localScale = Vector3.one * ((float)(body.Radius + body.maxAtmosphereAltitude) / (float)body.Radius);                  }                      if (modNode.HasValue("invWaveLength"))                  {                      //will be recomputed by SQUAD anyway so no point.                      // so instead' compute waveLength from it                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("invWaveLength"));                          afg.invWaveLength = new Color(col.x' col.y' col.z' col.w);                          afg.waveLength = new Color((float)Math.Pow(1 / col.x' 0.25)' (float)Math.Pow(1 / col.y' 0.25)' (float)Math.Pow(1 / col.z' 0.25)' 1f);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("invWaveLength") + " --- exception " + e.Message);                      }                  }                  if (modNode.HasValue("waveLength"))                  {                      try                      {                          Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("waveLength"));                          afg.waveLength = new Color(col.x' col.y' col.z' col.w);                      }                      catch (Exception e)                      {                          print("*RSS* Error parsing as color4: original text: " + modNode.GetValue("waveLength") + " --- exception " + e.Message);                      }                  }                  modNode.TryGetValue("Kr"' ref afg.Kr);                  modNode.TryGetValue("Km"' ref afg.Km);                  modNode.TryGetValue("ESun"' ref afg.ESun);                  modNode.TryGetValue("g"' ref afg.g);                  modNode.TryGetValue("samples"' ref afg.samples);              }              else              {                  // the defaults                  afg.outerRadius = (float)body.Radius * 1.025f * ScaledSpace.InverseScaleFactor;                  afg.innerRadius = afg.outerRadius * 0.975f;              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LLAtoECEF,The following statement contains a magic number: const double degreesToRadians = Math.PI / 180.0;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,GeeASLToOthers,The following statement contains a magic number: body.gMagnitudeAtCenter = body.GeeASL * 9.81 * rsq;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,GeeASLToOthers,The following statement contains a magic number: body.Mass = body.gravParameter * (1 / 6.674E-11);
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,MassToOthers,The following statement contains a magic number: body.GeeASL = body.Mass * (6.674E-11 / 9.81) / rsq;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,MassToOthers,The following statement contains a magic number: body.GeeASL = body.Mass * (6.674E-11 / 9.81) / rsq;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,MassToOthers,The following statement contains a magic number: body.gMagnitudeAtCenter = body.GeeASL * 9.81 * rsq;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,GravParamToOthers,The following statement contains a magic number: body.Mass = body.gravParameter * (1 / 6.674E-11);
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,GravParamToOthers,The following statement contains a magic number: body.GeeASL = body.gravParameter / 9.81 / rsq;
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadFinishOrbits,The following statement contains a magic number: if (loadInfo.orbitCalc)              {                  // do final update for all SoIs and hillSpheres and periods                  guiMajor = "Final orbit pass";                  //OnGui();                  print("*RSS* Doing final orbit pass");                  foreach (CelestialBody body in FlightGlobals.fetch.bodies)                  {                      guiMinor = body.name;                      guiExtra = "Orbital params";                      yield return null;                      // this used to be in a try' seems unnecessary                      if (body.orbitDriver != null)                      {                          if (body.referenceBody != null)                          {                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1 / 3);                              body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                              if (body.sphereOfInfluence < body.Radius * 1.5 || body.sphereOfInfluence < body.Radius + 20000.0)                                  body.sphereOfInfluence = Math.Max(body.Radius * 1.5' body.Radius + 20000.0); // sanity check                                body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.674E-11 * body.orbit.semiMajorAxis / (body.Mass + body.referenceBody.Mass));                              if (body.orbit.eccentricity <= 1.0)                              {                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                                  body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                              }                              else                              {                                  // ignores this body's own mass for this one...                                  body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                                  body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                                  body.orbit.ObTAtEpoch = body.orbit.ObT;                              }                              print("Computing params for " + body.name + ". SoI = " + body.sphereOfInfluence);                          }                          else                          {                              body.sphereOfInfluence = double.PositiveInfinity;                              body.hillSphere = double.PositiveInfinity;                          }                          // doesn't seem needed - body.orbitDriver.QueuedUpdate = true;                      }                      yield return null;                      guiExtra = "CBUpdate";                      yield return null;                      try                      {                          body.CBUpdate();                      }                      catch (Exception e)                      {                          print("CBUpdate for " + body.name + " failed: " + e.Message);                      }                      yield return null;                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The following statement contains a magic number: foreach (string pName in PQSs)              {                  print("Finding PQS " + pName);                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                  {                      if (p.name.Equals(pName))                      {                          if (body.pqsController != p)                              if (body.pqsController != p.parentSphere)                                  continue;                          guiMinor = "PQS " + p.name;                          //OnGui();                          p.radius = body.Radius;                          print("Editing PQS " + pName + "' default set radius = " + p.radius);                          if (custom) // YES' THIS IS SILLY                          // I SHOULD JUST WRITE A REAL C# EXTENSIBLE LOADER                          // Oh well. Hacks are quicker.                          {                              ConfigNode pqsNode = node.GetNode("PQS").GetNode(pName);                                // PQS members                              if (pqsNode.HasValue("radius"))                              {                                  if (double.TryParse(pqsNode.GetValue("radius")' out dtmp))                                  {                                      p.radius = dtmp;                                      print("Editing PQS " + pName + "' config set radius = " + p.radius);                                  }                              }                              if (pqsNode.HasValue("maxLevel"))                              {                                  if (int.TryParse(pqsNode.GetValue("maxLevel")' out itmp))                                  {                                      p.maxLevel = itmp;                                      try                                      {                                          PQSCache.PresetList.GetPreset(p.name).maxSubdivision = itmp;                                      }                                      catch (Exception e)                                      {                                          print("*RSS* ERROR: Applying change to preset for " + p.name + "' exception: " + e.Message);                                      }                                  }                              }                              if (pqsNode.HasValue("maxQuadLenghtsPerFrame"))                              {                                  if (float.TryParse(pqsNode.GetValue("maxQuadLenghtsPerFrame")' out ftmp))                                  {                                      p.maxQuadLenghtsPerFrame = ftmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeMax"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeMax")' out dtmp))                                  {                                      p.visRadAltitudeMax = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeValue")' out dtmp))                                  {                                      p.visRadAltitudeValue = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadSeaLevelValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadSeaLevelValue")' out dtmp))                                  {                                      p.visRadSeaLevelValue = dtmp;                                  }                              }                                yield return null;                              // PQSMods                              var mods = p.transform.GetComponentsInChildren(typeof(PQSMod)' true);                              foreach (var m in mods)                              {                                  print("Processing " + m.GetType().Name);                                  guiExtra = m.GetType().Name;                                  yield return null;                                  //OnGui();                                  foreach (ConfigNode modNode in pqsNode.nodes)                                  {                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeightAbsolute") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeightAbsolute mod = m as PQSMod_VertexSimplexHeightAbsolute;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeightCurve2") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeightCurve2 mod = m as PQSMod_VertexHeightNoiseVertHeightCurve2;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedSubFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedSubFrequency")' out ftmp))                                                  mod.ridgedSubFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexRidgedAltitudeCurve") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexRidgedAltitudeCurve mod = m as PQSMod_VertexRidgedAltitudeCurve;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexPlanet") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexPlanet mod = m as PQSMod_VertexPlanet;                                          if (modNode.HasValue("seed"))                                          {                                              if (int.TryParse(modNode.GetValue("seed")' out itmp))                                                  mod.seed = itmp;                                          }                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("colorDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("colorDeformity")' out dtmp))                                                  mod.colorDeformity = dtmp;                                          }                                          if (modNode.HasValue("oceanLevel"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanLevel")' out dtmp))                                                  mod.oceanLevel = dtmp;                                          }                                          if (modNode.HasValue("oceanStep"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanStep")' out dtmp))                                                  mod.oceanStep = dtmp;                                          }                                          if (modNode.HasValue("oceanDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanDepth")' out dtmp))                                                  mod.oceanDepth = dtmp;                                          }                                          if (modNode.HasValue("oceanSnap"))                                          {                                              if (bool.TryParse(modNode.GetValue("oceanSnap")' out btmp))                                                  mod.oceanSnap = btmp;                                          }                                          if (modNode.HasValue("terrainSmoothing"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainSmoothing")' out dtmp))                                                  mod.terrainSmoothing = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeStart"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeStart")' out dtmp))                                                  mod.terrainShapeStart = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeEnd"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeEnd")' out dtmp))                                                  mod.terrainShapeEnd = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMin"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMin")' out dtmp))                                                  mod.terrainRidgesMin = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMax"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMax")' out dtmp))                                                  mod.terrainRidgesMax = dtmp;                                          }                                          if (modNode.HasValue("buildHeightColors"))                                          {                                              if (bool.TryParse(modNode.GetValue("buildHeightColors")' out btmp))                                                  mod.buildHeightColors = btmp;                                          }                                          if (modNode.HasValue("terrainRidgeBalance"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgeBalance")' out dtmp))                                                  mod.terrainRidgeBalance = dtmp;                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          // Also supports Landclasses. Maybe come back and do these later...                                          yield return null;                                          mod.OnSetup();                                      }                                      ///                                      if (modNode.name.Equals("PQSMod_VertexHeightMap") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightMap mod = m as PQSMod_VertexHeightMap;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("heightMapOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapOffset")' out dtmp))                                                  mod.heightMapOffset = dtmp;                                              print("*RSS* Set offset " + mod.heightMapOffset);                                          }                                          if (modNode.HasValue("heightMap"))                                          {                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                              if((object)map != null)                                              {                                                  yield return null;                                                  mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                                  yield return null;                                              }                                              else                                                  print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AltitudeAlpha") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AltitudeAlpha mod = m as PQSMod_AltitudeAlpha;                                          if (modNode.HasValue("atmosphereDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("atmosphereDepth")' out dtmp))                                                  mod.atmosphereDepth = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AerialPerspectiveMaterial") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AerialPerspectiveMaterial mod = m as PQSMod_AerialPerspectiveMaterial;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (float.TryParse(modNode.GetValue("heightMapDeformity")' out ftmp))                                                  mod.atmosphereDepth = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeight mod = m as PQSMod_VertexSimplexHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (double.TryParse(modNode.GetValue("octaves")' out dtmp))                                                  mod.octaves = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeight mod = m as PQSMod_VertexHeightNoiseVertHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (int.TryParse(modNode.GetValue("octaves")' out itmp))                                                  mod.octaves = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VoronoiCraters") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VoronoiCraters mod = m as PQSMod_VoronoiCraters;                                          if (modNode.HasValue("KEYvoronoiSeed"))                                              if (int.Parse(modNode.GetValue("KEYvoronoiSeed")) != mod.voronoiSeed)                                                  continue;                                            if (modNode.HasValue("deformation"))                                          {                                              if (double.TryParse(modNode.GetValue("deformation")' out dtmp))                                                  mod.deformation = dtmp;                                          }                                          if (modNode.HasValue("voronoiFrequency"))                                          {                                              if (double.TryParse(modNode.GetValue("voronoiFrequency")' out dtmp))                                                  mod.voronoiFrequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoise") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoise mod = m as PQSMod_VertexHeightNoise;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSLandControl") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSLandControl mod = m as PQSLandControl;                                          if (modNode.HasValue("useHeightMap"))                                          {                                              if (bool.TryParse(modNode.GetValue("useHeightMap")' out btmp))                                                  mod.useHeightMap = btmp;                                                if (mod.useHeightMap && modNode.HasValue("heightMap"))                                              {                                                  Texture2D map = null;                                                  bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                                  if ((object)map != null)                                                  {                                                      yield return null;                                                      mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                      if (localLoad)                                                      {                                                          DestroyImmediate(map);                                                          map = null;                                                      }                                                      yield return null;                                                  }                                                  else                                                  {                                                      print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                                      mod.useHeightMap = false;                                                  }                                              }                                              else                                                  mod.useHeightMap = false; // If there was no heightMap given                                          }                                              if (modNode.HasValue("vHeightMax"))                                          {                                              if (float.TryParse(modNode.GetValue("vHeightMax")' out ftmp))                                                  mod.vHeightMax = ftmp;                                          }                                          if (modNode.HasValue("altitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeBlend")' out ftmp))                                                  mod.altitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("altitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeFrequency")' out ftmp))                                                  mod.altitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("altitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudePersistance")' out ftmp))                                                  mod.altitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("latitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeBlend")' out ftmp))                                                  mod.latitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("latitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeFrequency")' out ftmp))                                                  mod.latitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("latitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudePersistance")' out ftmp))                                                  mod.latitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("longitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeBlend")' out ftmp))                                                  mod.longitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("longitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeFrequency")' out ftmp))                                                  mod.longitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("longitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudePersistance")' out ftmp))                                                  mod.longitudePersistance = ftmp;                                          }                                          foreach (ConfigNode lcNode in modNode.GetNodes("LandClass"))                                          {                                              bool found = false;                                              string lcName = lcNode.GetValue("landClassName");                                              foreach (PQSLandControl.LandClass lc in mod.landClasses)                                              {                                                  if (lc.landClassName.Equals(lcName))                                                  {                                                      found = true;                                                      if (lcNode.HasValue("color"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("color"));                                                              lc.color = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("color") + " --- exception " + e.Message);                                                          }                                                      }                                                      if (lcNode.HasValue("noiseColor"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("noiseColor"));                                                              lc.noiseColor = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("noiseColor") + " --- exception " + e.Message);                                                          }                                                      }                                                        // ranges                                                      if (lcNode.HasNode("altitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("altitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.altitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.altitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.altitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.altitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("latitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("latitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.latitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.latitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.latitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.latitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("longitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("longitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.longitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.longitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.longitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.longitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasValue("latitudeDouble"))                                                      {                                                          if (bool.TryParse(lcNode.GetValue("latitudeDouble")' out btmp))                                                              lc.latitudeDouble = btmp;                                                      }                                                      if (lcNode.HasValue("minimumRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("minimumRealHeight")' out dtmp))                                                              lc.minimumRealHeight = dtmp;                                                      if (lcNode.HasValue("alterRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("alterRealHeight")' out dtmp))                                                              lc.alterRealHeight = dtmp;                                                      if (lcNode.HasValue("alterApparentHeight"))                                                          if (float.TryParse(lcNode.GetValue("alterApparentHeight")' out ftmp))                                                              lc.alterApparentHeight = ftmp;                                                          break; // don't need to find any more                                                  }                                              }                                              if (!found)                                                  print("*RSS* LandClass " + lcName + " not found in PQSLandControl for PQS " + p.name + " of CB " + body.name);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                        // City                                      if (modNode.name.Equals("PQSCity") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSCity mod = m as PQSCity;                                          if (modNode.HasValue("KEYname"))                                              if (!(mod.name.Equals(modNode.GetValue("KEYname"))))                                                  continue;                                            if (modNode.HasValue("repositionRadial"))                                          {                                              try                                              {                                                  mod.repositionRadial = KSPUtil.ParseVector3(modNode.GetValue("repositionRadial"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("repositionRadial") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.repositionRadial = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          if (modNode.HasValue("reorientInitialUp"))                                          {                                              try                                              {                                                  mod.reorientInitialUp = KSPUtil.ParseVector3(modNode.GetValue("reorientInitialUp"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("reorientInitialUp") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("repositionToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphere")' out btmp))                                                  mod.repositionToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurface"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurface")' out btmp))                                                  mod.repositionToSphereSurface = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurfaceAddHeight"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurfaceAddHeight")' out btmp))                                                  mod.repositionToSphereSurfaceAddHeight = btmp;                                          }                                          if (modNode.HasValue("reorientToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("reorientToSphere")' out btmp))                                                  mod.reorientToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionRadiusOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("repositionRadiusOffset")' out dtmp))                                                  mod.repositionRadiusOffset = dtmp;                                          }                                          if (modNode.HasValue("lodvisibleRangeMult"))                                          {                                              if (double.TryParse(modNode.GetValue("lodvisibleRangeMult")' out dtmp))                                                  foreach (PQSCity.LODRange l in mod.lod)                                                      l.visibleRange *= (float)dtmp;                                          }                                            if (modNode.HasValue("reorientFinalAngle"))                                          {                                              if (float.TryParse(modNode.GetValue("reorientFinalAngle")' out ftmp))                                                  mod.reorientFinalAngle = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      // KSC Flat area                                      if (modNode.name.Equals("PQSMod_MapDecalTangent") && m.GetType().ToString().Equals(modNode.name))                                      {                                          // thanks to asmi for this!                                          PQSMod_MapDecalTangent mod = m as PQSMod_MapDecalTangent;                                          if (modNode.HasValue("position"))                                          {                                              try                                              {                                                  mod.position = KSPUtil.ParseVector3(modNode.GetValue("position"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("position") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("radius"))                                          {                                              if (double.TryParse(modNode.GetValue("radius")' out dtmp))                                                  mod.radius = dtmp;                                          }                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("absoluteOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("absoluteOffset")' out dtmp))                                                  mod.absoluteOffset = dtmp;                                          }                                            if (modNode.HasValue("absolute"))                                          {                                              if (bool.TryParse(modNode.GetValue("absolute")' out btmp))                                                  mod.absolute = btmp;                                          }                                          if (modNode.HasValue("rescaleToRadius"))                                          {                                              mod.position *= (float)(body.Radius / origRadius);                                              mod.radius *= (body.Radius / origRadius);                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.position = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorMapBlend mod = m as PQSMod_VertexColorMapBlend;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          if (modNode.HasValue("enabled"))                                              if (bool.TryParse(modNode.GetValue("enabled")' out btmp))                                                  mod.enabled = mod.modEnabled = btmp;                                            if (modNode.HasValue("vertexColorMap"))                                          {                                              // for now don't destroy old map' use GC.                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                              if ((object)map != null)                                              {                                                  map.LoadImage(System.IO.File.ReadAllBytes(KSPUtil.ApplicationRootPath + modNode.GetValue("vertexColorMap")));                                                  yield return null;                                                  //DestroyImmediate(mod.vertexColorMap);                                                  //mod.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                                  mod.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                              }                                              yield return null;                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorSolid mod = m as PQSMod_VertexColorSolid;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  mod.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                  }                              }                              if (pqsNode.HasNode("Add"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Add").nodes)                                  {                                      print("Adding " + modNode.name);                                      guiExtra = "Add " + modNode.name;                                      yield return null;                                      //OnGui();                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                          if((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                PQSMod_VertexColorMapBlend colorMap = (PQSMod_VertexColorMapBlend)tempObj.AddComponent(typeof(PQSMod_VertexColorMapBlend));                                                tempObj.transform.parent = p.gameObject.transform;                                              colorMap.sphere = p;                                                yield return null;                                              colorMap.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                              colorMap.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                              yield return null;                                              colorMap.blend = 1.0f;                                              if (modNode.HasValue("blend"))                                                  if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                      colorMap.blend = ftmp;                                                colorMap.order = 9999993;                                              if (modNode.HasValue("order"))                                                  if (int.TryParse(modNode.GetValue("order")' out itmp))                                                      colorMap.order = itmp;                                                colorMap.modEnabled = true;                                                if (localLoad)                                              {                                                  DestroyImmediate(map);                                                  map = null;                                              }                                              yield return null;                                              colorMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      if (modNode.name.Equals("PQSMod_VertexSimplexNoiseColor"))                                      {                                          GameObject tempObj = new GameObject();                                          PQSMod_VertexSimplexNoiseColor vertColor = (PQSMod_VertexSimplexNoiseColor)tempObj.AddComponent(typeof(PQSMod_VertexSimplexNoiseColor));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                            vertColor.blend = 1.0f;                                          modNode.TryGetValue("blend"' ref vertColor.blend);                                            vertColor.order = 9999994;                                          modNode.TryGetValue("order"' ref vertColor.order);                                          modNode.TryGetValue("octaves"' ref vertColor.octaves);                                          modNode.TryGetValue("persistence"' ref vertColor.persistence);                                          modNode.TryGetValue("frequency"' ref vertColor.frequency);                                          modNode.TryGetValue("colorStart"' ref vertColor.colorStart);                                          modNode.TryGetValue("colorEnd"' ref vertColor.colorEnd);                                          modNode.TryGetValue("frequency"' ref vertColor.seed);                                            vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid"))                                      {                                          GameObject tempObj = new GameObject();                                              PQSMod_VertexColorSolid vertColor = (PQSMod_VertexColorSolid)tempObj.AddComponent(typeof(PQSMod_VertexColorSolid));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                                vertColor.blend = 1.0f;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  vertColor.blend = ftmp;                                            vertColor.order = 9999992;                                          if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  vertColor.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  vertColor.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightMap"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                          if ((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                  PQSMod_VertexHeightMap heightMap = (PQSMod_VertexHeightMap)tempObj.AddComponent(typeof(PQSMod_VertexHeightMap));                                              tempObj.transform.parent = p.gameObject.transform;                                              heightMap.sphere = p;                                                yield return null;                                              heightMap.heightMap = ScriptableObject.CreateInstance<MapSO>();                                              heightMap.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                              DestroyImmediate(map);                                              map = null;                                              yield return null;                                              heightMap.heightMapOffset = 0.0f;                                              modNode.TryGetValue("heightMapOffset"' ref heightMap.heightMapOffset);                                                heightMap.heightMapDeformity = 100.0f;                                              modNode.TryGetValue("heightMapDeformity"' ref heightMap.heightMapDeformity);                                                heightMap.scaleDeformityByRadius = false;                                              modNode.TryGetValue("scaleDeformityByRadius"' ref heightMap.scaleDeformityByRadius);                                                heightMap.order = 10;                                              modNode.TryGetValue("order"' ref heightMap.order);                                              heightMap.scaleDeformityByRadius = false;                                                heightMap.modEnabled = true;                                              yield return null;                                              heightMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      yield return null;                                  }                              }                              if (pqsNode.HasNode("Disable"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Disable").nodes)                                  {                                      string mName = modNode.name;                                      print("Disabling " + mName);                                      guiExtra = "Disable " + mName;                                      yield return null;                                      //OnGui();                                      if (mName.Equals("PQSLandControl"))                                      {                                          List<PQSLandControl> modList = p.transform.GetComponentsInChildren<PQSLandControl>(true).ToList();                                          /*while(modList.Count > 0)                                          {                                              PQSLandControl m = modList[0];                                              if (m.heightMap != null)                                                  DestroyImmediate(m.heightMap);                                              m.modEnabled = false;                                              m.enabled = false;                                              modList.RemoveAt(0);                                              DestroyImmediate(m);                                          }*/                                          foreach (PQSLandControl m in modList)                                          {                                              m.modEnabled = false;                                              m.enabled = false;                                              m.OnSetup();                                          }                                      }                                      else                                      {                                          int idx = 0;                                          bool doAll = false;                                          if (mName.Contains("'"))                                          {                                              string[] splt = mName.Split(''');                                              mName = splt[0];                                              if (splt[1][0].Equals('*'))                                                  doAll = true;                                              else                                                  int.TryParse(splt[1]' out idx);                                          }                                          print("Generic disable: " + mName + " with idx: " + idx + "; doAll: " + doAll);                                          int cur = 0;                                          foreach (var m in mods)                                          {                                              if (modNode.name.Equals(m.GetType().Name))                                              {                                                  if (cur == idx || doAll)                                                  {                                                      m.GetType().GetField("modEnabled").SetValue(m' false);                                                      print("Found and disabled " + m.GetType().Name);                                                  }                                                  else                                                      cur++;                                              }                                          }                                      }                                  }                              }                              yield return null;                          }                          print("Rebuilding sphere " + p.name);                          guiExtra = "Rebuilding " + p.name;                          yield return null;                          try                          {                              //OnGui();                              //p.ResetSphere();                              p.RebuildSphere();                          }                          catch (Exception e)                          {                              print("Rebuild sphere for " + node.name + " failed: " + e.Message);                          }                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The following statement contains a magic number: foreach (string pName in PQSs)              {                  print("Finding PQS " + pName);                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                  {                      if (p.name.Equals(pName))                      {                          if (body.pqsController != p)                              if (body.pqsController != p.parentSphere)                                  continue;                          guiMinor = "PQS " + p.name;                          //OnGui();                          p.radius = body.Radius;                          print("Editing PQS " + pName + "' default set radius = " + p.radius);                          if (custom) // YES' THIS IS SILLY                          // I SHOULD JUST WRITE A REAL C# EXTENSIBLE LOADER                          // Oh well. Hacks are quicker.                          {                              ConfigNode pqsNode = node.GetNode("PQS").GetNode(pName);                                // PQS members                              if (pqsNode.HasValue("radius"))                              {                                  if (double.TryParse(pqsNode.GetValue("radius")' out dtmp))                                  {                                      p.radius = dtmp;                                      print("Editing PQS " + pName + "' config set radius = " + p.radius);                                  }                              }                              if (pqsNode.HasValue("maxLevel"))                              {                                  if (int.TryParse(pqsNode.GetValue("maxLevel")' out itmp))                                  {                                      p.maxLevel = itmp;                                      try                                      {                                          PQSCache.PresetList.GetPreset(p.name).maxSubdivision = itmp;                                      }                                      catch (Exception e)                                      {                                          print("*RSS* ERROR: Applying change to preset for " + p.name + "' exception: " + e.Message);                                      }                                  }                              }                              if (pqsNode.HasValue("maxQuadLenghtsPerFrame"))                              {                                  if (float.TryParse(pqsNode.GetValue("maxQuadLenghtsPerFrame")' out ftmp))                                  {                                      p.maxQuadLenghtsPerFrame = ftmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeMax"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeMax")' out dtmp))                                  {                                      p.visRadAltitudeMax = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeValue")' out dtmp))                                  {                                      p.visRadAltitudeValue = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadSeaLevelValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadSeaLevelValue")' out dtmp))                                  {                                      p.visRadSeaLevelValue = dtmp;                                  }                              }                                yield return null;                              // PQSMods                              var mods = p.transform.GetComponentsInChildren(typeof(PQSMod)' true);                              foreach (var m in mods)                              {                                  print("Processing " + m.GetType().Name);                                  guiExtra = m.GetType().Name;                                  yield return null;                                  //OnGui();                                  foreach (ConfigNode modNode in pqsNode.nodes)                                  {                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeightAbsolute") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeightAbsolute mod = m as PQSMod_VertexSimplexHeightAbsolute;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeightCurve2") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeightCurve2 mod = m as PQSMod_VertexHeightNoiseVertHeightCurve2;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedSubFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedSubFrequency")' out ftmp))                                                  mod.ridgedSubFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexRidgedAltitudeCurve") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexRidgedAltitudeCurve mod = m as PQSMod_VertexRidgedAltitudeCurve;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexPlanet") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexPlanet mod = m as PQSMod_VertexPlanet;                                          if (modNode.HasValue("seed"))                                          {                                              if (int.TryParse(modNode.GetValue("seed")' out itmp))                                                  mod.seed = itmp;                                          }                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("colorDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("colorDeformity")' out dtmp))                                                  mod.colorDeformity = dtmp;                                          }                                          if (modNode.HasValue("oceanLevel"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanLevel")' out dtmp))                                                  mod.oceanLevel = dtmp;                                          }                                          if (modNode.HasValue("oceanStep"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanStep")' out dtmp))                                                  mod.oceanStep = dtmp;                                          }                                          if (modNode.HasValue("oceanDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanDepth")' out dtmp))                                                  mod.oceanDepth = dtmp;                                          }                                          if (modNode.HasValue("oceanSnap"))                                          {                                              if (bool.TryParse(modNode.GetValue("oceanSnap")' out btmp))                                                  mod.oceanSnap = btmp;                                          }                                          if (modNode.HasValue("terrainSmoothing"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainSmoothing")' out dtmp))                                                  mod.terrainSmoothing = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeStart"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeStart")' out dtmp))                                                  mod.terrainShapeStart = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeEnd"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeEnd")' out dtmp))                                                  mod.terrainShapeEnd = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMin"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMin")' out dtmp))                                                  mod.terrainRidgesMin = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMax"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMax")' out dtmp))                                                  mod.terrainRidgesMax = dtmp;                                          }                                          if (modNode.HasValue("buildHeightColors"))                                          {                                              if (bool.TryParse(modNode.GetValue("buildHeightColors")' out btmp))                                                  mod.buildHeightColors = btmp;                                          }                                          if (modNode.HasValue("terrainRidgeBalance"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgeBalance")' out dtmp))                                                  mod.terrainRidgeBalance = dtmp;                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          // Also supports Landclasses. Maybe come back and do these later...                                          yield return null;                                          mod.OnSetup();                                      }                                      ///                                      if (modNode.name.Equals("PQSMod_VertexHeightMap") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightMap mod = m as PQSMod_VertexHeightMap;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("heightMapOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapOffset")' out dtmp))                                                  mod.heightMapOffset = dtmp;                                              print("*RSS* Set offset " + mod.heightMapOffset);                                          }                                          if (modNode.HasValue("heightMap"))                                          {                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                              if((object)map != null)                                              {                                                  yield return null;                                                  mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                                  yield return null;                                              }                                              else                                                  print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AltitudeAlpha") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AltitudeAlpha mod = m as PQSMod_AltitudeAlpha;                                          if (modNode.HasValue("atmosphereDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("atmosphereDepth")' out dtmp))                                                  mod.atmosphereDepth = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AerialPerspectiveMaterial") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AerialPerspectiveMaterial mod = m as PQSMod_AerialPerspectiveMaterial;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (float.TryParse(modNode.GetValue("heightMapDeformity")' out ftmp))                                                  mod.atmosphereDepth = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeight mod = m as PQSMod_VertexSimplexHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (double.TryParse(modNode.GetValue("octaves")' out dtmp))                                                  mod.octaves = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeight mod = m as PQSMod_VertexHeightNoiseVertHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (int.TryParse(modNode.GetValue("octaves")' out itmp))                                                  mod.octaves = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VoronoiCraters") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VoronoiCraters mod = m as PQSMod_VoronoiCraters;                                          if (modNode.HasValue("KEYvoronoiSeed"))                                              if (int.Parse(modNode.GetValue("KEYvoronoiSeed")) != mod.voronoiSeed)                                                  continue;                                            if (modNode.HasValue("deformation"))                                          {                                              if (double.TryParse(modNode.GetValue("deformation")' out dtmp))                                                  mod.deformation = dtmp;                                          }                                          if (modNode.HasValue("voronoiFrequency"))                                          {                                              if (double.TryParse(modNode.GetValue("voronoiFrequency")' out dtmp))                                                  mod.voronoiFrequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoise") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoise mod = m as PQSMod_VertexHeightNoise;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSLandControl") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSLandControl mod = m as PQSLandControl;                                          if (modNode.HasValue("useHeightMap"))                                          {                                              if (bool.TryParse(modNode.GetValue("useHeightMap")' out btmp))                                                  mod.useHeightMap = btmp;                                                if (mod.useHeightMap && modNode.HasValue("heightMap"))                                              {                                                  Texture2D map = null;                                                  bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                                  if ((object)map != null)                                                  {                                                      yield return null;                                                      mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                      if (localLoad)                                                      {                                                          DestroyImmediate(map);                                                          map = null;                                                      }                                                      yield return null;                                                  }                                                  else                                                  {                                                      print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                                      mod.useHeightMap = false;                                                  }                                              }                                              else                                                  mod.useHeightMap = false; // If there was no heightMap given                                          }                                              if (modNode.HasValue("vHeightMax"))                                          {                                              if (float.TryParse(modNode.GetValue("vHeightMax")' out ftmp))                                                  mod.vHeightMax = ftmp;                                          }                                          if (modNode.HasValue("altitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeBlend")' out ftmp))                                                  mod.altitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("altitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeFrequency")' out ftmp))                                                  mod.altitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("altitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudePersistance")' out ftmp))                                                  mod.altitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("latitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeBlend")' out ftmp))                                                  mod.latitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("latitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeFrequency")' out ftmp))                                                  mod.latitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("latitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudePersistance")' out ftmp))                                                  mod.latitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("longitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeBlend")' out ftmp))                                                  mod.longitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("longitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeFrequency")' out ftmp))                                                  mod.longitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("longitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudePersistance")' out ftmp))                                                  mod.longitudePersistance = ftmp;                                          }                                          foreach (ConfigNode lcNode in modNode.GetNodes("LandClass"))                                          {                                              bool found = false;                                              string lcName = lcNode.GetValue("landClassName");                                              foreach (PQSLandControl.LandClass lc in mod.landClasses)                                              {                                                  if (lc.landClassName.Equals(lcName))                                                  {                                                      found = true;                                                      if (lcNode.HasValue("color"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("color"));                                                              lc.color = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("color") + " --- exception " + e.Message);                                                          }                                                      }                                                      if (lcNode.HasValue("noiseColor"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("noiseColor"));                                                              lc.noiseColor = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("noiseColor") + " --- exception " + e.Message);                                                          }                                                      }                                                        // ranges                                                      if (lcNode.HasNode("altitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("altitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.altitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.altitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.altitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.altitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("latitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("latitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.latitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.latitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.latitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.latitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("longitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("longitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.longitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.longitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.longitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.longitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasValue("latitudeDouble"))                                                      {                                                          if (bool.TryParse(lcNode.GetValue("latitudeDouble")' out btmp))                                                              lc.latitudeDouble = btmp;                                                      }                                                      if (lcNode.HasValue("minimumRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("minimumRealHeight")' out dtmp))                                                              lc.minimumRealHeight = dtmp;                                                      if (lcNode.HasValue("alterRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("alterRealHeight")' out dtmp))                                                              lc.alterRealHeight = dtmp;                                                      if (lcNode.HasValue("alterApparentHeight"))                                                          if (float.TryParse(lcNode.GetValue("alterApparentHeight")' out ftmp))                                                              lc.alterApparentHeight = ftmp;                                                          break; // don't need to find any more                                                  }                                              }                                              if (!found)                                                  print("*RSS* LandClass " + lcName + " not found in PQSLandControl for PQS " + p.name + " of CB " + body.name);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                        // City                                      if (modNode.name.Equals("PQSCity") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSCity mod = m as PQSCity;                                          if (modNode.HasValue("KEYname"))                                              if (!(mod.name.Equals(modNode.GetValue("KEYname"))))                                                  continue;                                            if (modNode.HasValue("repositionRadial"))                                          {                                              try                                              {                                                  mod.repositionRadial = KSPUtil.ParseVector3(modNode.GetValue("repositionRadial"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("repositionRadial") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.repositionRadial = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          if (modNode.HasValue("reorientInitialUp"))                                          {                                              try                                              {                                                  mod.reorientInitialUp = KSPUtil.ParseVector3(modNode.GetValue("reorientInitialUp"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("reorientInitialUp") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("repositionToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphere")' out btmp))                                                  mod.repositionToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurface"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurface")' out btmp))                                                  mod.repositionToSphereSurface = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurfaceAddHeight"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurfaceAddHeight")' out btmp))                                                  mod.repositionToSphereSurfaceAddHeight = btmp;                                          }                                          if (modNode.HasValue("reorientToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("reorientToSphere")' out btmp))                                                  mod.reorientToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionRadiusOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("repositionRadiusOffset")' out dtmp))                                                  mod.repositionRadiusOffset = dtmp;                                          }                                          if (modNode.HasValue("lodvisibleRangeMult"))                                          {                                              if (double.TryParse(modNode.GetValue("lodvisibleRangeMult")' out dtmp))                                                  foreach (PQSCity.LODRange l in mod.lod)                                                      l.visibleRange *= (float)dtmp;                                          }                                            if (modNode.HasValue("reorientFinalAngle"))                                          {                                              if (float.TryParse(modNode.GetValue("reorientFinalAngle")' out ftmp))                                                  mod.reorientFinalAngle = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      // KSC Flat area                                      if (modNode.name.Equals("PQSMod_MapDecalTangent") && m.GetType().ToString().Equals(modNode.name))                                      {                                          // thanks to asmi for this!                                          PQSMod_MapDecalTangent mod = m as PQSMod_MapDecalTangent;                                          if (modNode.HasValue("position"))                                          {                                              try                                              {                                                  mod.position = KSPUtil.ParseVector3(modNode.GetValue("position"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("position") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("radius"))                                          {                                              if (double.TryParse(modNode.GetValue("radius")' out dtmp))                                                  mod.radius = dtmp;                                          }                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("absoluteOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("absoluteOffset")' out dtmp))                                                  mod.absoluteOffset = dtmp;                                          }                                            if (modNode.HasValue("absolute"))                                          {                                              if (bool.TryParse(modNode.GetValue("absolute")' out btmp))                                                  mod.absolute = btmp;                                          }                                          if (modNode.HasValue("rescaleToRadius"))                                          {                                              mod.position *= (float)(body.Radius / origRadius);                                              mod.radius *= (body.Radius / origRadius);                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.position = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorMapBlend mod = m as PQSMod_VertexColorMapBlend;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          if (modNode.HasValue("enabled"))                                              if (bool.TryParse(modNode.GetValue("enabled")' out btmp))                                                  mod.enabled = mod.modEnabled = btmp;                                            if (modNode.HasValue("vertexColorMap"))                                          {                                              // for now don't destroy old map' use GC.                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                              if ((object)map != null)                                              {                                                  map.LoadImage(System.IO.File.ReadAllBytes(KSPUtil.ApplicationRootPath + modNode.GetValue("vertexColorMap")));                                                  yield return null;                                                  //DestroyImmediate(mod.vertexColorMap);                                                  //mod.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                                  mod.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                              }                                              yield return null;                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorSolid mod = m as PQSMod_VertexColorSolid;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  mod.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                  }                              }                              if (pqsNode.HasNode("Add"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Add").nodes)                                  {                                      print("Adding " + modNode.name);                                      guiExtra = "Add " + modNode.name;                                      yield return null;                                      //OnGui();                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                          if((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                PQSMod_VertexColorMapBlend colorMap = (PQSMod_VertexColorMapBlend)tempObj.AddComponent(typeof(PQSMod_VertexColorMapBlend));                                                tempObj.transform.parent = p.gameObject.transform;                                              colorMap.sphere = p;                                                yield return null;                                              colorMap.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                              colorMap.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                              yield return null;                                              colorMap.blend = 1.0f;                                              if (modNode.HasValue("blend"))                                                  if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                      colorMap.blend = ftmp;                                                colorMap.order = 9999993;                                              if (modNode.HasValue("order"))                                                  if (int.TryParse(modNode.GetValue("order")' out itmp))                                                      colorMap.order = itmp;                                                colorMap.modEnabled = true;                                                if (localLoad)                                              {                                                  DestroyImmediate(map);                                                  map = null;                                              }                                              yield return null;                                              colorMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      if (modNode.name.Equals("PQSMod_VertexSimplexNoiseColor"))                                      {                                          GameObject tempObj = new GameObject();                                          PQSMod_VertexSimplexNoiseColor vertColor = (PQSMod_VertexSimplexNoiseColor)tempObj.AddComponent(typeof(PQSMod_VertexSimplexNoiseColor));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                            vertColor.blend = 1.0f;                                          modNode.TryGetValue("blend"' ref vertColor.blend);                                            vertColor.order = 9999994;                                          modNode.TryGetValue("order"' ref vertColor.order);                                          modNode.TryGetValue("octaves"' ref vertColor.octaves);                                          modNode.TryGetValue("persistence"' ref vertColor.persistence);                                          modNode.TryGetValue("frequency"' ref vertColor.frequency);                                          modNode.TryGetValue("colorStart"' ref vertColor.colorStart);                                          modNode.TryGetValue("colorEnd"' ref vertColor.colorEnd);                                          modNode.TryGetValue("frequency"' ref vertColor.seed);                                            vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid"))                                      {                                          GameObject tempObj = new GameObject();                                              PQSMod_VertexColorSolid vertColor = (PQSMod_VertexColorSolid)tempObj.AddComponent(typeof(PQSMod_VertexColorSolid));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                                vertColor.blend = 1.0f;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  vertColor.blend = ftmp;                                            vertColor.order = 9999992;                                          if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  vertColor.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  vertColor.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightMap"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                          if ((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                  PQSMod_VertexHeightMap heightMap = (PQSMod_VertexHeightMap)tempObj.AddComponent(typeof(PQSMod_VertexHeightMap));                                              tempObj.transform.parent = p.gameObject.transform;                                              heightMap.sphere = p;                                                yield return null;                                              heightMap.heightMap = ScriptableObject.CreateInstance<MapSO>();                                              heightMap.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                              DestroyImmediate(map);                                              map = null;                                              yield return null;                                              heightMap.heightMapOffset = 0.0f;                                              modNode.TryGetValue("heightMapOffset"' ref heightMap.heightMapOffset);                                                heightMap.heightMapDeformity = 100.0f;                                              modNode.TryGetValue("heightMapDeformity"' ref heightMap.heightMapDeformity);                                                heightMap.scaleDeformityByRadius = false;                                              modNode.TryGetValue("scaleDeformityByRadius"' ref heightMap.scaleDeformityByRadius);                                                heightMap.order = 10;                                              modNode.TryGetValue("order"' ref heightMap.order);                                              heightMap.scaleDeformityByRadius = false;                                                heightMap.modEnabled = true;                                              yield return null;                                              heightMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      yield return null;                                  }                              }                              if (pqsNode.HasNode("Disable"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Disable").nodes)                                  {                                      string mName = modNode.name;                                      print("Disabling " + mName);                                      guiExtra = "Disable " + mName;                                      yield return null;                                      //OnGui();                                      if (mName.Equals("PQSLandControl"))                                      {                                          List<PQSLandControl> modList = p.transform.GetComponentsInChildren<PQSLandControl>(true).ToList();                                          /*while(modList.Count > 0)                                          {                                              PQSLandControl m = modList[0];                                              if (m.heightMap != null)                                                  DestroyImmediate(m.heightMap);                                              m.modEnabled = false;                                              m.enabled = false;                                              modList.RemoveAt(0);                                              DestroyImmediate(m);                                          }*/                                          foreach (PQSLandControl m in modList)                                          {                                              m.modEnabled = false;                                              m.enabled = false;                                              m.OnSetup();                                          }                                      }                                      else                                      {                                          int idx = 0;                                          bool doAll = false;                                          if (mName.Contains("'"))                                          {                                              string[] splt = mName.Split(''');                                              mName = splt[0];                                              if (splt[1][0].Equals('*'))                                                  doAll = true;                                              else                                                  int.TryParse(splt[1]' out idx);                                          }                                          print("Generic disable: " + mName + " with idx: " + idx + "; doAll: " + doAll);                                          int cur = 0;                                          foreach (var m in mods)                                          {                                              if (modNode.name.Equals(m.GetType().Name))                                              {                                                  if (cur == idx || doAll)                                                  {                                                      m.GetType().GetField("modEnabled").SetValue(m' false);                                                      print("Found and disabled " + m.GetType().Name);                                                  }                                                  else                                                      cur++;                                              }                                          }                                      }                                  }                              }                              yield return null;                          }                          print("Rebuilding sphere " + p.name);                          guiExtra = "Rebuilding " + p.name;                          yield return null;                          try                          {                              //OnGui();                              //p.ResetSphere();                              p.RebuildSphere();                          }                          catch (Exception e)                          {                              print("Rebuild sphere for " + node.name + " failed: " + e.Message);                          }                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The following statement contains a magic number: foreach (string pName in PQSs)              {                  print("Finding PQS " + pName);                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                  {                      if (p.name.Equals(pName))                      {                          if (body.pqsController != p)                              if (body.pqsController != p.parentSphere)                                  continue;                          guiMinor = "PQS " + p.name;                          //OnGui();                          p.radius = body.Radius;                          print("Editing PQS " + pName + "' default set radius = " + p.radius);                          if (custom) // YES' THIS IS SILLY                          // I SHOULD JUST WRITE A REAL C# EXTENSIBLE LOADER                          // Oh well. Hacks are quicker.                          {                              ConfigNode pqsNode = node.GetNode("PQS").GetNode(pName);                                // PQS members                              if (pqsNode.HasValue("radius"))                              {                                  if (double.TryParse(pqsNode.GetValue("radius")' out dtmp))                                  {                                      p.radius = dtmp;                                      print("Editing PQS " + pName + "' config set radius = " + p.radius);                                  }                              }                              if (pqsNode.HasValue("maxLevel"))                              {                                  if (int.TryParse(pqsNode.GetValue("maxLevel")' out itmp))                                  {                                      p.maxLevel = itmp;                                      try                                      {                                          PQSCache.PresetList.GetPreset(p.name).maxSubdivision = itmp;                                      }                                      catch (Exception e)                                      {                                          print("*RSS* ERROR: Applying change to preset for " + p.name + "' exception: " + e.Message);                                      }                                  }                              }                              if (pqsNode.HasValue("maxQuadLenghtsPerFrame"))                              {                                  if (float.TryParse(pqsNode.GetValue("maxQuadLenghtsPerFrame")' out ftmp))                                  {                                      p.maxQuadLenghtsPerFrame = ftmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeMax"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeMax")' out dtmp))                                  {                                      p.visRadAltitudeMax = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeValue")' out dtmp))                                  {                                      p.visRadAltitudeValue = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadSeaLevelValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadSeaLevelValue")' out dtmp))                                  {                                      p.visRadSeaLevelValue = dtmp;                                  }                              }                                yield return null;                              // PQSMods                              var mods = p.transform.GetComponentsInChildren(typeof(PQSMod)' true);                              foreach (var m in mods)                              {                                  print("Processing " + m.GetType().Name);                                  guiExtra = m.GetType().Name;                                  yield return null;                                  //OnGui();                                  foreach (ConfigNode modNode in pqsNode.nodes)                                  {                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeightAbsolute") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeightAbsolute mod = m as PQSMod_VertexSimplexHeightAbsolute;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeightCurve2") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeightCurve2 mod = m as PQSMod_VertexHeightNoiseVertHeightCurve2;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedSubFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedSubFrequency")' out ftmp))                                                  mod.ridgedSubFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexRidgedAltitudeCurve") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexRidgedAltitudeCurve mod = m as PQSMod_VertexRidgedAltitudeCurve;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexPlanet") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexPlanet mod = m as PQSMod_VertexPlanet;                                          if (modNode.HasValue("seed"))                                          {                                              if (int.TryParse(modNode.GetValue("seed")' out itmp))                                                  mod.seed = itmp;                                          }                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("colorDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("colorDeformity")' out dtmp))                                                  mod.colorDeformity = dtmp;                                          }                                          if (modNode.HasValue("oceanLevel"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanLevel")' out dtmp))                                                  mod.oceanLevel = dtmp;                                          }                                          if (modNode.HasValue("oceanStep"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanStep")' out dtmp))                                                  mod.oceanStep = dtmp;                                          }                                          if (modNode.HasValue("oceanDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanDepth")' out dtmp))                                                  mod.oceanDepth = dtmp;                                          }                                          if (modNode.HasValue("oceanSnap"))                                          {                                              if (bool.TryParse(modNode.GetValue("oceanSnap")' out btmp))                                                  mod.oceanSnap = btmp;                                          }                                          if (modNode.HasValue("terrainSmoothing"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainSmoothing")' out dtmp))                                                  mod.terrainSmoothing = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeStart"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeStart")' out dtmp))                                                  mod.terrainShapeStart = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeEnd"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeEnd")' out dtmp))                                                  mod.terrainShapeEnd = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMin"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMin")' out dtmp))                                                  mod.terrainRidgesMin = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMax"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMax")' out dtmp))                                                  mod.terrainRidgesMax = dtmp;                                          }                                          if (modNode.HasValue("buildHeightColors"))                                          {                                              if (bool.TryParse(modNode.GetValue("buildHeightColors")' out btmp))                                                  mod.buildHeightColors = btmp;                                          }                                          if (modNode.HasValue("terrainRidgeBalance"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgeBalance")' out dtmp))                                                  mod.terrainRidgeBalance = dtmp;                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          // Also supports Landclasses. Maybe come back and do these later...                                          yield return null;                                          mod.OnSetup();                                      }                                      ///                                      if (modNode.name.Equals("PQSMod_VertexHeightMap") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightMap mod = m as PQSMod_VertexHeightMap;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("heightMapOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapOffset")' out dtmp))                                                  mod.heightMapOffset = dtmp;                                              print("*RSS* Set offset " + mod.heightMapOffset);                                          }                                          if (modNode.HasValue("heightMap"))                                          {                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                              if((object)map != null)                                              {                                                  yield return null;                                                  mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                                  yield return null;                                              }                                              else                                                  print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AltitudeAlpha") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AltitudeAlpha mod = m as PQSMod_AltitudeAlpha;                                          if (modNode.HasValue("atmosphereDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("atmosphereDepth")' out dtmp))                                                  mod.atmosphereDepth = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AerialPerspectiveMaterial") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AerialPerspectiveMaterial mod = m as PQSMod_AerialPerspectiveMaterial;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (float.TryParse(modNode.GetValue("heightMapDeformity")' out ftmp))                                                  mod.atmosphereDepth = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeight mod = m as PQSMod_VertexSimplexHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (double.TryParse(modNode.GetValue("octaves")' out dtmp))                                                  mod.octaves = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeight mod = m as PQSMod_VertexHeightNoiseVertHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (int.TryParse(modNode.GetValue("octaves")' out itmp))                                                  mod.octaves = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VoronoiCraters") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VoronoiCraters mod = m as PQSMod_VoronoiCraters;                                          if (modNode.HasValue("KEYvoronoiSeed"))                                              if (int.Parse(modNode.GetValue("KEYvoronoiSeed")) != mod.voronoiSeed)                                                  continue;                                            if (modNode.HasValue("deformation"))                                          {                                              if (double.TryParse(modNode.GetValue("deformation")' out dtmp))                                                  mod.deformation = dtmp;                                          }                                          if (modNode.HasValue("voronoiFrequency"))                                          {                                              if (double.TryParse(modNode.GetValue("voronoiFrequency")' out dtmp))                                                  mod.voronoiFrequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoise") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoise mod = m as PQSMod_VertexHeightNoise;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSLandControl") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSLandControl mod = m as PQSLandControl;                                          if (modNode.HasValue("useHeightMap"))                                          {                                              if (bool.TryParse(modNode.GetValue("useHeightMap")' out btmp))                                                  mod.useHeightMap = btmp;                                                if (mod.useHeightMap && modNode.HasValue("heightMap"))                                              {                                                  Texture2D map = null;                                                  bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                                  if ((object)map != null)                                                  {                                                      yield return null;                                                      mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                      if (localLoad)                                                      {                                                          DestroyImmediate(map);                                                          map = null;                                                      }                                                      yield return null;                                                  }                                                  else                                                  {                                                      print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                                      mod.useHeightMap = false;                                                  }                                              }                                              else                                                  mod.useHeightMap = false; // If there was no heightMap given                                          }                                              if (modNode.HasValue("vHeightMax"))                                          {                                              if (float.TryParse(modNode.GetValue("vHeightMax")' out ftmp))                                                  mod.vHeightMax = ftmp;                                          }                                          if (modNode.HasValue("altitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeBlend")' out ftmp))                                                  mod.altitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("altitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeFrequency")' out ftmp))                                                  mod.altitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("altitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudePersistance")' out ftmp))                                                  mod.altitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("latitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeBlend")' out ftmp))                                                  mod.latitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("latitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeFrequency")' out ftmp))                                                  mod.latitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("latitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudePersistance")' out ftmp))                                                  mod.latitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("longitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeBlend")' out ftmp))                                                  mod.longitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("longitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeFrequency")' out ftmp))                                                  mod.longitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("longitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudePersistance")' out ftmp))                                                  mod.longitudePersistance = ftmp;                                          }                                          foreach (ConfigNode lcNode in modNode.GetNodes("LandClass"))                                          {                                              bool found = false;                                              string lcName = lcNode.GetValue("landClassName");                                              foreach (PQSLandControl.LandClass lc in mod.landClasses)                                              {                                                  if (lc.landClassName.Equals(lcName))                                                  {                                                      found = true;                                                      if (lcNode.HasValue("color"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("color"));                                                              lc.color = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("color") + " --- exception " + e.Message);                                                          }                                                      }                                                      if (lcNode.HasValue("noiseColor"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("noiseColor"));                                                              lc.noiseColor = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("noiseColor") + " --- exception " + e.Message);                                                          }                                                      }                                                        // ranges                                                      if (lcNode.HasNode("altitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("altitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.altitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.altitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.altitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.altitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("latitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("latitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.latitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.latitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.latitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.latitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("longitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("longitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.longitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.longitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.longitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.longitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasValue("latitudeDouble"))                                                      {                                                          if (bool.TryParse(lcNode.GetValue("latitudeDouble")' out btmp))                                                              lc.latitudeDouble = btmp;                                                      }                                                      if (lcNode.HasValue("minimumRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("minimumRealHeight")' out dtmp))                                                              lc.minimumRealHeight = dtmp;                                                      if (lcNode.HasValue("alterRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("alterRealHeight")' out dtmp))                                                              lc.alterRealHeight = dtmp;                                                      if (lcNode.HasValue("alterApparentHeight"))                                                          if (float.TryParse(lcNode.GetValue("alterApparentHeight")' out ftmp))                                                              lc.alterApparentHeight = ftmp;                                                          break; // don't need to find any more                                                  }                                              }                                              if (!found)                                                  print("*RSS* LandClass " + lcName + " not found in PQSLandControl for PQS " + p.name + " of CB " + body.name);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                        // City                                      if (modNode.name.Equals("PQSCity") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSCity mod = m as PQSCity;                                          if (modNode.HasValue("KEYname"))                                              if (!(mod.name.Equals(modNode.GetValue("KEYname"))))                                                  continue;                                            if (modNode.HasValue("repositionRadial"))                                          {                                              try                                              {                                                  mod.repositionRadial = KSPUtil.ParseVector3(modNode.GetValue("repositionRadial"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("repositionRadial") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.repositionRadial = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          if (modNode.HasValue("reorientInitialUp"))                                          {                                              try                                              {                                                  mod.reorientInitialUp = KSPUtil.ParseVector3(modNode.GetValue("reorientInitialUp"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("reorientInitialUp") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("repositionToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphere")' out btmp))                                                  mod.repositionToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurface"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurface")' out btmp))                                                  mod.repositionToSphereSurface = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurfaceAddHeight"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurfaceAddHeight")' out btmp))                                                  mod.repositionToSphereSurfaceAddHeight = btmp;                                          }                                          if (modNode.HasValue("reorientToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("reorientToSphere")' out btmp))                                                  mod.reorientToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionRadiusOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("repositionRadiusOffset")' out dtmp))                                                  mod.repositionRadiusOffset = dtmp;                                          }                                          if (modNode.HasValue("lodvisibleRangeMult"))                                          {                                              if (double.TryParse(modNode.GetValue("lodvisibleRangeMult")' out dtmp))                                                  foreach (PQSCity.LODRange l in mod.lod)                                                      l.visibleRange *= (float)dtmp;                                          }                                            if (modNode.HasValue("reorientFinalAngle"))                                          {                                              if (float.TryParse(modNode.GetValue("reorientFinalAngle")' out ftmp))                                                  mod.reorientFinalAngle = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      // KSC Flat area                                      if (modNode.name.Equals("PQSMod_MapDecalTangent") && m.GetType().ToString().Equals(modNode.name))                                      {                                          // thanks to asmi for this!                                          PQSMod_MapDecalTangent mod = m as PQSMod_MapDecalTangent;                                          if (modNode.HasValue("position"))                                          {                                              try                                              {                                                  mod.position = KSPUtil.ParseVector3(modNode.GetValue("position"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("position") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("radius"))                                          {                                              if (double.TryParse(modNode.GetValue("radius")' out dtmp))                                                  mod.radius = dtmp;                                          }                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("absoluteOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("absoluteOffset")' out dtmp))                                                  mod.absoluteOffset = dtmp;                                          }                                            if (modNode.HasValue("absolute"))                                          {                                              if (bool.TryParse(modNode.GetValue("absolute")' out btmp))                                                  mod.absolute = btmp;                                          }                                          if (modNode.HasValue("rescaleToRadius"))                                          {                                              mod.position *= (float)(body.Radius / origRadius);                                              mod.radius *= (body.Radius / origRadius);                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.position = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorMapBlend mod = m as PQSMod_VertexColorMapBlend;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          if (modNode.HasValue("enabled"))                                              if (bool.TryParse(modNode.GetValue("enabled")' out btmp))                                                  mod.enabled = mod.modEnabled = btmp;                                            if (modNode.HasValue("vertexColorMap"))                                          {                                              // for now don't destroy old map' use GC.                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                              if ((object)map != null)                                              {                                                  map.LoadImage(System.IO.File.ReadAllBytes(KSPUtil.ApplicationRootPath + modNode.GetValue("vertexColorMap")));                                                  yield return null;                                                  //DestroyImmediate(mod.vertexColorMap);                                                  //mod.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                                  mod.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                              }                                              yield return null;                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorSolid mod = m as PQSMod_VertexColorSolid;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  mod.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                  }                              }                              if (pqsNode.HasNode("Add"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Add").nodes)                                  {                                      print("Adding " + modNode.name);                                      guiExtra = "Add " + modNode.name;                                      yield return null;                                      //OnGui();                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                          if((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                PQSMod_VertexColorMapBlend colorMap = (PQSMod_VertexColorMapBlend)tempObj.AddComponent(typeof(PQSMod_VertexColorMapBlend));                                                tempObj.transform.parent = p.gameObject.transform;                                              colorMap.sphere = p;                                                yield return null;                                              colorMap.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                              colorMap.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                              yield return null;                                              colorMap.blend = 1.0f;                                              if (modNode.HasValue("blend"))                                                  if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                      colorMap.blend = ftmp;                                                colorMap.order = 9999993;                                              if (modNode.HasValue("order"))                                                  if (int.TryParse(modNode.GetValue("order")' out itmp))                                                      colorMap.order = itmp;                                                colorMap.modEnabled = true;                                                if (localLoad)                                              {                                                  DestroyImmediate(map);                                                  map = null;                                              }                                              yield return null;                                              colorMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      if (modNode.name.Equals("PQSMod_VertexSimplexNoiseColor"))                                      {                                          GameObject tempObj = new GameObject();                                          PQSMod_VertexSimplexNoiseColor vertColor = (PQSMod_VertexSimplexNoiseColor)tempObj.AddComponent(typeof(PQSMod_VertexSimplexNoiseColor));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                            vertColor.blend = 1.0f;                                          modNode.TryGetValue("blend"' ref vertColor.blend);                                            vertColor.order = 9999994;                                          modNode.TryGetValue("order"' ref vertColor.order);                                          modNode.TryGetValue("octaves"' ref vertColor.octaves);                                          modNode.TryGetValue("persistence"' ref vertColor.persistence);                                          modNode.TryGetValue("frequency"' ref vertColor.frequency);                                          modNode.TryGetValue("colorStart"' ref vertColor.colorStart);                                          modNode.TryGetValue("colorEnd"' ref vertColor.colorEnd);                                          modNode.TryGetValue("frequency"' ref vertColor.seed);                                            vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid"))                                      {                                          GameObject tempObj = new GameObject();                                              PQSMod_VertexColorSolid vertColor = (PQSMod_VertexColorSolid)tempObj.AddComponent(typeof(PQSMod_VertexColorSolid));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                                vertColor.blend = 1.0f;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  vertColor.blend = ftmp;                                            vertColor.order = 9999992;                                          if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  vertColor.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  vertColor.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightMap"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                          if ((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                  PQSMod_VertexHeightMap heightMap = (PQSMod_VertexHeightMap)tempObj.AddComponent(typeof(PQSMod_VertexHeightMap));                                              tempObj.transform.parent = p.gameObject.transform;                                              heightMap.sphere = p;                                                yield return null;                                              heightMap.heightMap = ScriptableObject.CreateInstance<MapSO>();                                              heightMap.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                              DestroyImmediate(map);                                              map = null;                                              yield return null;                                              heightMap.heightMapOffset = 0.0f;                                              modNode.TryGetValue("heightMapOffset"' ref heightMap.heightMapOffset);                                                heightMap.heightMapDeformity = 100.0f;                                              modNode.TryGetValue("heightMapDeformity"' ref heightMap.heightMapDeformity);                                                heightMap.scaleDeformityByRadius = false;                                              modNode.TryGetValue("scaleDeformityByRadius"' ref heightMap.scaleDeformityByRadius);                                                heightMap.order = 10;                                              modNode.TryGetValue("order"' ref heightMap.order);                                              heightMap.scaleDeformityByRadius = false;                                                heightMap.modEnabled = true;                                              yield return null;                                              heightMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      yield return null;                                  }                              }                              if (pqsNode.HasNode("Disable"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Disable").nodes)                                  {                                      string mName = modNode.name;                                      print("Disabling " + mName);                                      guiExtra = "Disable " + mName;                                      yield return null;                                      //OnGui();                                      if (mName.Equals("PQSLandControl"))                                      {                                          List<PQSLandControl> modList = p.transform.GetComponentsInChildren<PQSLandControl>(true).ToList();                                          /*while(modList.Count > 0)                                          {                                              PQSLandControl m = modList[0];                                              if (m.heightMap != null)                                                  DestroyImmediate(m.heightMap);                                              m.modEnabled = false;                                              m.enabled = false;                                              modList.RemoveAt(0);                                              DestroyImmediate(m);                                          }*/                                          foreach (PQSLandControl m in modList)                                          {                                              m.modEnabled = false;                                              m.enabled = false;                                              m.OnSetup();                                          }                                      }                                      else                                      {                                          int idx = 0;                                          bool doAll = false;                                          if (mName.Contains("'"))                                          {                                              string[] splt = mName.Split(''');                                              mName = splt[0];                                              if (splt[1][0].Equals('*'))                                                  doAll = true;                                              else                                                  int.TryParse(splt[1]' out idx);                                          }                                          print("Generic disable: " + mName + " with idx: " + idx + "; doAll: " + doAll);                                          int cur = 0;                                          foreach (var m in mods)                                          {                                              if (modNode.name.Equals(m.GetType().Name))                                              {                                                  if (cur == idx || doAll)                                                  {                                                      m.GetType().GetField("modEnabled").SetValue(m' false);                                                      print("Found and disabled " + m.GetType().Name);                                                  }                                                  else                                                      cur++;                                              }                                          }                                      }                                  }                              }                              yield return null;                          }                          print("Rebuilding sphere " + p.name);                          guiExtra = "Rebuilding " + p.name;                          yield return null;                          try                          {                              //OnGui();                              //p.ResetSphere();                              p.RebuildSphere();                          }                          catch (Exception e)                          {                              print("Rebuild sphere for " + node.name + " failed: " + e.Message);                          }                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadPQS,The following statement contains a magic number: foreach (string pName in PQSs)              {                  print("Finding PQS " + pName);                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                  {                      if (p.name.Equals(pName))                      {                          if (body.pqsController != p)                              if (body.pqsController != p.parentSphere)                                  continue;                          guiMinor = "PQS " + p.name;                          //OnGui();                          p.radius = body.Radius;                          print("Editing PQS " + pName + "' default set radius = " + p.radius);                          if (custom) // YES' THIS IS SILLY                          // I SHOULD JUST WRITE A REAL C# EXTENSIBLE LOADER                          // Oh well. Hacks are quicker.                          {                              ConfigNode pqsNode = node.GetNode("PQS").GetNode(pName);                                // PQS members                              if (pqsNode.HasValue("radius"))                              {                                  if (double.TryParse(pqsNode.GetValue("radius")' out dtmp))                                  {                                      p.radius = dtmp;                                      print("Editing PQS " + pName + "' config set radius = " + p.radius);                                  }                              }                              if (pqsNode.HasValue("maxLevel"))                              {                                  if (int.TryParse(pqsNode.GetValue("maxLevel")' out itmp))                                  {                                      p.maxLevel = itmp;                                      try                                      {                                          PQSCache.PresetList.GetPreset(p.name).maxSubdivision = itmp;                                      }                                      catch (Exception e)                                      {                                          print("*RSS* ERROR: Applying change to preset for " + p.name + "' exception: " + e.Message);                                      }                                  }                              }                              if (pqsNode.HasValue("maxQuadLenghtsPerFrame"))                              {                                  if (float.TryParse(pqsNode.GetValue("maxQuadLenghtsPerFrame")' out ftmp))                                  {                                      p.maxQuadLenghtsPerFrame = ftmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeMax"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeMax")' out dtmp))                                  {                                      p.visRadAltitudeMax = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadAltitudeValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadAltitudeValue")' out dtmp))                                  {                                      p.visRadAltitudeValue = dtmp;                                  }                              }                              if (pqsNode.HasValue("visRadSeaLevelValue"))                              {                                  if (double.TryParse(pqsNode.GetValue("visRadSeaLevelValue")' out dtmp))                                  {                                      p.visRadSeaLevelValue = dtmp;                                  }                              }                                yield return null;                              // PQSMods                              var mods = p.transform.GetComponentsInChildren(typeof(PQSMod)' true);                              foreach (var m in mods)                              {                                  print("Processing " + m.GetType().Name);                                  guiExtra = m.GetType().Name;                                  yield return null;                                  //OnGui();                                  foreach (ConfigNode modNode in pqsNode.nodes)                                  {                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeightAbsolute") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeightAbsolute mod = m as PQSMod_VertexSimplexHeightAbsolute;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeightCurve2") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeightCurve2 mod = m as PQSMod_VertexHeightNoiseVertHeightCurve2;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedSubFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedSubFrequency")' out ftmp))                                                  mod.ridgedSubFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexRidgedAltitudeCurve") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexRidgedAltitudeCurve mod = m as PQSMod_VertexRidgedAltitudeCurve;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("ridgedAddFrequency")' out ftmp))                                                  mod.ridgedAddFrequency = ftmp;                                          }                                          if (modNode.HasValue("ridgedAddOctaves"))                                          {                                              if (int.TryParse(modNode.GetValue("ridgedAddOctaves")' out itmp))                                                  mod.ridgedAddOctaves = itmp;                                          }                                          if (modNode.HasValue("simplexHeightStart"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightStart")' out ftmp))                                                  mod.simplexHeightStart = ftmp;                                          }                                          if (modNode.HasValue("simplexHeightEnd"))                                          {                                              if (float.TryParse(modNode.GetValue("simplexHeightEnd")' out ftmp))                                                  mod.simplexHeightEnd = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexPlanet") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexPlanet mod = m as PQSMod_VertexPlanet;                                          if (modNode.HasValue("seed"))                                          {                                              if (int.TryParse(modNode.GetValue("seed")' out itmp))                                                  mod.seed = itmp;                                          }                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("colorDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("colorDeformity")' out dtmp))                                                  mod.colorDeformity = dtmp;                                          }                                          if (modNode.HasValue("oceanLevel"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanLevel")' out dtmp))                                                  mod.oceanLevel = dtmp;                                          }                                          if (modNode.HasValue("oceanStep"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanStep")' out dtmp))                                                  mod.oceanStep = dtmp;                                          }                                          if (modNode.HasValue("oceanDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("oceanDepth")' out dtmp))                                                  mod.oceanDepth = dtmp;                                          }                                          if (modNode.HasValue("oceanSnap"))                                          {                                              if (bool.TryParse(modNode.GetValue("oceanSnap")' out btmp))                                                  mod.oceanSnap = btmp;                                          }                                          if (modNode.HasValue("terrainSmoothing"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainSmoothing")' out dtmp))                                                  mod.terrainSmoothing = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeStart"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeStart")' out dtmp))                                                  mod.terrainShapeStart = dtmp;                                          }                                          if (modNode.HasValue("terrainShapeEnd"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainShapeEnd")' out dtmp))                                                  mod.terrainShapeEnd = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMin"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMin")' out dtmp))                                                  mod.terrainRidgesMin = dtmp;                                          }                                          if (modNode.HasValue("terrainRidgesMax"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgesMax")' out dtmp))                                                  mod.terrainRidgesMax = dtmp;                                          }                                          if (modNode.HasValue("buildHeightColors"))                                          {                                              if (bool.TryParse(modNode.GetValue("buildHeightColors")' out btmp))                                                  mod.buildHeightColors = btmp;                                          }                                          if (modNode.HasValue("terrainRidgeBalance"))                                          {                                              if (double.TryParse(modNode.GetValue("terrainRidgeBalance")' out dtmp))                                                  mod.terrainRidgeBalance = dtmp;                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          // Also supports Landclasses. Maybe come back and do these later...                                          yield return null;                                          mod.OnSetup();                                      }                                      ///                                      if (modNode.name.Equals("PQSMod_VertexHeightMap") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightMap mod = m as PQSMod_VertexHeightMap;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("heightMapOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapOffset")' out dtmp))                                                  mod.heightMapOffset = dtmp;                                              print("*RSS* Set offset " + mod.heightMapOffset);                                          }                                          if (modNode.HasValue("heightMap"))                                          {                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                              if((object)map != null)                                              {                                                  yield return null;                                                  mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                                  yield return null;                                              }                                              else                                                  print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                          }                                          if (modNode.HasValue("order"))                                          {                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AltitudeAlpha") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AltitudeAlpha mod = m as PQSMod_AltitudeAlpha;                                          if (modNode.HasValue("atmosphereDepth"))                                          {                                              if (double.TryParse(modNode.GetValue("atmosphereDepth")' out dtmp))                                                  mod.atmosphereDepth = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_AerialPerspectiveMaterial") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_AerialPerspectiveMaterial mod = m as PQSMod_AerialPerspectiveMaterial;                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (float.TryParse(modNode.GetValue("heightMapDeformity")' out ftmp))                                                  mod.atmosphereDepth = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexSimplexHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexSimplexHeight mod = m as PQSMod_VertexSimplexHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (double.TryParse(modNode.GetValue("deformity")' out dtmp))                                                  mod.deformity = dtmp;                                          }                                          if (modNode.HasValue("persistence"))                                          {                                              if (double.TryParse(modNode.GetValue("persistence")' out dtmp))                                                  mod.persistence = dtmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (double.TryParse(modNode.GetValue("frequency")' out dtmp))                                                  mod.frequency = dtmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (double.TryParse(modNode.GetValue("octaves")' out dtmp))                                                  mod.octaves = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoiseVertHeight") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoiseVertHeight mod = m as PQSMod_VertexHeightNoiseVertHeight;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          if (modNode.HasValue("octaves"))                                          {                                              if (int.TryParse(modNode.GetValue("octaves")' out itmp))                                                  mod.octaves = itmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VoronoiCraters") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VoronoiCraters mod = m as PQSMod_VoronoiCraters;                                          if (modNode.HasValue("KEYvoronoiSeed"))                                              if (int.Parse(modNode.GetValue("KEYvoronoiSeed")) != mod.voronoiSeed)                                                  continue;                                            if (modNode.HasValue("deformation"))                                          {                                              if (double.TryParse(modNode.GetValue("deformation")' out dtmp))                                                  mod.deformation = dtmp;                                          }                                          if (modNode.HasValue("voronoiFrequency"))                                          {                                              if (double.TryParse(modNode.GetValue("voronoiFrequency")' out dtmp))                                                  mod.voronoiFrequency = dtmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightNoise") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexHeightNoise mod = m as PQSMod_VertexHeightNoise;                                          if (modNode.HasValue("deformity"))                                          {                                              if (float.TryParse(modNode.GetValue("deformity")' out ftmp))                                                  mod.deformity = ftmp;                                          }                                          if (modNode.HasValue("frequency"))                                          {                                              if (float.TryParse(modNode.GetValue("frequency")' out ftmp))                                                  mod.frequency = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSLandControl") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSLandControl mod = m as PQSLandControl;                                          if (modNode.HasValue("useHeightMap"))                                          {                                              if (bool.TryParse(modNode.GetValue("useHeightMap")' out btmp))                                                  mod.useHeightMap = btmp;                                                if (mod.useHeightMap && modNode.HasValue("heightMap"))                                              {                                                  Texture2D map = null;                                                  bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                                  if ((object)map != null)                                                  {                                                      yield return null;                                                      mod.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                                      if (localLoad)                                                      {                                                          DestroyImmediate(map);                                                          map = null;                                                      }                                                      yield return null;                                                  }                                                  else                                                  {                                                      print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("heightMap"));                                                      mod.useHeightMap = false;                                                  }                                              }                                              else                                                  mod.useHeightMap = false; // If there was no heightMap given                                          }                                              if (modNode.HasValue("vHeightMax"))                                          {                                              if (float.TryParse(modNode.GetValue("vHeightMax")' out ftmp))                                                  mod.vHeightMax = ftmp;                                          }                                          if (modNode.HasValue("altitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeBlend")' out ftmp))                                                  mod.altitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("altitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudeFrequency")' out ftmp))                                                  mod.altitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("altitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("altitudePersistance")' out ftmp))                                                  mod.altitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("latitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeBlend")' out ftmp))                                                  mod.latitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("latitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudeFrequency")' out ftmp))                                                  mod.latitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("latitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("latitudePersistance")' out ftmp))                                                  mod.latitudePersistance = ftmp;                                          }                                          if (modNode.HasValue("longitudeBlend"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeBlend")' out ftmp))                                                  mod.longitudeBlend = ftmp;                                          }                                          if (modNode.HasValue("longitudeFrequency"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudeFrequency")' out ftmp))                                                  mod.longitudeFrequency = ftmp;                                          }                                          if (modNode.HasValue("longitudePersistance"))                                          {                                              if (float.TryParse(modNode.GetValue("longitudePersistance")' out ftmp))                                                  mod.longitudePersistance = ftmp;                                          }                                          foreach (ConfigNode lcNode in modNode.GetNodes("LandClass"))                                          {                                              bool found = false;                                              string lcName = lcNode.GetValue("landClassName");                                              foreach (PQSLandControl.LandClass lc in mod.landClasses)                                              {                                                  if (lc.landClassName.Equals(lcName))                                                  {                                                      found = true;                                                      if (lcNode.HasValue("color"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("color"));                                                              lc.color = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("color") + " --- exception " + e.Message);                                                          }                                                      }                                                      if (lcNode.HasValue("noiseColor"))                                                      {                                                          try                                                          {                                                              Vector4 col = KSPUtil.ParseVector4(lcNode.GetValue("noiseColor"));                                                              lc.noiseColor = new Color(col.x' col.y' col.z' col.w);                                                          }                                                          catch (Exception e)                                                          {                                                              print("*RSS* Error parsing as color4: original text: " + lcNode.GetValue("noiseColor") + " --- exception " + e.Message);                                                          }                                                      }                                                        // ranges                                                      if (lcNode.HasNode("altitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("altitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.altitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.altitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.altitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.altitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("latitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("latitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.latitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.latitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.latitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.latitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasNode("longitudeRange"))                                                      {                                                          ConfigNode range = lcNode.GetNode("longitudeRange");                                                          if (range.HasValue("startStart"))                                                              if (double.TryParse(range.GetValue("startStart")' out dtmp))                                                                  lc.longitudeRange.startStart = dtmp;                                                          if (range.HasValue("startEnd"))                                                              if (double.TryParse(range.GetValue("startEnd")' out dtmp))                                                                  lc.longitudeRange.startEnd = dtmp;                                                          if (range.HasValue("endStart"))                                                              if (double.TryParse(range.GetValue("endStart")' out dtmp))                                                                  lc.longitudeRange.endStart = dtmp;                                                          if (range.HasValue("endEnd"))                                                              if (double.TryParse(range.GetValue("endEnd")' out dtmp))                                                                  lc.longitudeRange.endEnd = dtmp;                                                      }                                                      if (lcNode.HasValue("latitudeDouble"))                                                      {                                                          if (bool.TryParse(lcNode.GetValue("latitudeDouble")' out btmp))                                                              lc.latitudeDouble = btmp;                                                      }                                                      if (lcNode.HasValue("minimumRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("minimumRealHeight")' out dtmp))                                                              lc.minimumRealHeight = dtmp;                                                      if (lcNode.HasValue("alterRealHeight"))                                                          if (double.TryParse(lcNode.GetValue("alterRealHeight")' out dtmp))                                                              lc.alterRealHeight = dtmp;                                                      if (lcNode.HasValue("alterApparentHeight"))                                                          if (float.TryParse(lcNode.GetValue("alterApparentHeight")' out ftmp))                                                              lc.alterApparentHeight = ftmp;                                                          break; // don't need to find any more                                                  }                                              }                                              if (!found)                                                  print("*RSS* LandClass " + lcName + " not found in PQSLandControl for PQS " + p.name + " of CB " + body.name);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                        // City                                      if (modNode.name.Equals("PQSCity") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSCity mod = m as PQSCity;                                          if (modNode.HasValue("KEYname"))                                              if (!(mod.name.Equals(modNode.GetValue("KEYname"))))                                                  continue;                                            if (modNode.HasValue("repositionRadial"))                                          {                                              try                                              {                                                  mod.repositionRadial = KSPUtil.ParseVector3(modNode.GetValue("repositionRadial"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("repositionRadial") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.repositionRadial = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          if (modNode.HasValue("reorientInitialUp"))                                          {                                              try                                              {                                                  mod.reorientInitialUp = KSPUtil.ParseVector3(modNode.GetValue("reorientInitialUp"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("reorientInitialUp") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("repositionToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphere")' out btmp))                                                  mod.repositionToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurface"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurface")' out btmp))                                                  mod.repositionToSphereSurface = btmp;                                          }                                          if (modNode.HasValue("repositionToSphereSurfaceAddHeight"))                                          {                                              if (bool.TryParse(modNode.GetValue("repositionToSphereSurfaceAddHeight")' out btmp))                                                  mod.repositionToSphereSurfaceAddHeight = btmp;                                          }                                          if (modNode.HasValue("reorientToSphere"))                                          {                                              if (bool.TryParse(modNode.GetValue("reorientToSphere")' out btmp))                                                  mod.reorientToSphere = btmp;                                          }                                          if (modNode.HasValue("repositionRadiusOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("repositionRadiusOffset")' out dtmp))                                                  mod.repositionRadiusOffset = dtmp;                                          }                                          if (modNode.HasValue("lodvisibleRangeMult"))                                          {                                              if (double.TryParse(modNode.GetValue("lodvisibleRangeMult")' out dtmp))                                                  foreach (PQSCity.LODRange l in mod.lod)                                                      l.visibleRange *= (float)dtmp;                                          }                                            if (modNode.HasValue("reorientFinalAngle"))                                          {                                              if (float.TryParse(modNode.GetValue("reorientFinalAngle")' out ftmp))                                                  mod.reorientFinalAngle = ftmp;                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      // KSC Flat area                                      if (modNode.name.Equals("PQSMod_MapDecalTangent") && m.GetType().ToString().Equals(modNode.name))                                      {                                          // thanks to asmi for this!                                          PQSMod_MapDecalTangent mod = m as PQSMod_MapDecalTangent;                                          if (modNode.HasValue("position"))                                          {                                              try                                              {                                                  mod.position = KSPUtil.ParseVector3(modNode.GetValue("position"));                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec3: original text: " + modNode.GetValue("position") + " --- exception " + e.Message);                                              }                                          }                                          if (modNode.HasValue("radius"))                                          {                                              if (double.TryParse(modNode.GetValue("radius")' out dtmp))                                                  mod.radius = dtmp;                                          }                                          if (modNode.HasValue("heightMapDeformity"))                                          {                                              if (double.TryParse(modNode.GetValue("heightMapDeformity")' out dtmp))                                                  mod.heightMapDeformity = dtmp;                                          }                                          if (modNode.HasValue("absoluteOffset"))                                          {                                              if (double.TryParse(modNode.GetValue("absoluteOffset")' out dtmp))                                                  mod.absoluteOffset = dtmp;                                          }                                            if (modNode.HasValue("absolute"))                                          {                                              if (bool.TryParse(modNode.GetValue("absolute")' out btmp))                                                  mod.absolute = btmp;                                          }                                          if (modNode.HasValue("rescaleToRadius"))                                          {                                              mod.position *= (float)(body.Radius / origRadius);                                              mod.radius *= (body.Radius / origRadius);                                          }                                          if (modNode.HasValue("latitude") && modNode.HasValue("longitude"))                                          {                                              double lat' lon;                                              double.TryParse(modNode.GetValue("latitude")' out lat);                                              double.TryParse(modNode.GetValue("longitude")' out lon);                                                mod.position = LLAtoECEF(lat' lon' 0' body.Radius);                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorMapBlend mod = m as PQSMod_VertexColorMapBlend;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                          if (modNode.HasValue("enabled"))                                              if (bool.TryParse(modNode.GetValue("enabled")' out btmp))                                                  mod.enabled = mod.modEnabled = btmp;                                            if (modNode.HasValue("vertexColorMap"))                                          {                                              // for now don't destroy old map' use GC.                                              Texture2D map = null;                                              bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                              if ((object)map != null)                                              {                                                  map.LoadImage(System.IO.File.ReadAllBytes(KSPUtil.ApplicationRootPath + modNode.GetValue("vertexColorMap")));                                                  yield return null;                                                  //DestroyImmediate(mod.vertexColorMap);                                                  //mod.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                                  mod.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                                  if (localLoad)                                                  {                                                      DestroyImmediate(map);                                                      map = null;                                                  }                                              }                                              yield return null;                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                          yield return null;                                          mod.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid") && m.GetType().ToString().Equals(modNode.name))                                      {                                          PQSMod_VertexColorSolid mod = m as PQSMod_VertexColorSolid;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  mod.blend = ftmp;                                            if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  mod.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  mod.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          yield return null;                                          mod.OnSetup();                                      }                                  }                              }                              if (pqsNode.HasNode("Add"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Add").nodes)                                  {                                      print("Adding " + modNode.name);                                      guiExtra = "Add " + modNode.name;                                      yield return null;                                      //OnGui();                                      if (modNode.name.Equals("PQSMod_VertexColorMapBlend"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("vertexColorMap")' ref map' false' false' false);                                          if((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                PQSMod_VertexColorMapBlend colorMap = (PQSMod_VertexColorMapBlend)tempObj.AddComponent(typeof(PQSMod_VertexColorMapBlend));                                                tempObj.transform.parent = p.gameObject.transform;                                              colorMap.sphere = p;                                                yield return null;                                              colorMap.vertexColorMap = ScriptableObject.CreateInstance<MapSO>();                                              colorMap.vertexColorMap.CreateMap(MapSO.MapDepth.RGB' map);                                              yield return null;                                              colorMap.blend = 1.0f;                                              if (modNode.HasValue("blend"))                                                  if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                      colorMap.blend = ftmp;                                                colorMap.order = 9999993;                                              if (modNode.HasValue("order"))                                                  if (int.TryParse(modNode.GetValue("order")' out itmp))                                                      colorMap.order = itmp;                                                colorMap.modEnabled = true;                                                if (localLoad)                                              {                                                  DestroyImmediate(map);                                                  map = null;                                              }                                              yield return null;                                              colorMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      if (modNode.name.Equals("PQSMod_VertexSimplexNoiseColor"))                                      {                                          GameObject tempObj = new GameObject();                                          PQSMod_VertexSimplexNoiseColor vertColor = (PQSMod_VertexSimplexNoiseColor)tempObj.AddComponent(typeof(PQSMod_VertexSimplexNoiseColor));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                            vertColor.blend = 1.0f;                                          modNode.TryGetValue("blend"' ref vertColor.blend);                                            vertColor.order = 9999994;                                          modNode.TryGetValue("order"' ref vertColor.order);                                          modNode.TryGetValue("octaves"' ref vertColor.octaves);                                          modNode.TryGetValue("persistence"' ref vertColor.persistence);                                          modNode.TryGetValue("frequency"' ref vertColor.frequency);                                          modNode.TryGetValue("colorStart"' ref vertColor.colorStart);                                          modNode.TryGetValue("colorEnd"' ref vertColor.colorEnd);                                          modNode.TryGetValue("frequency"' ref vertColor.seed);                                            vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexColorSolid"))                                      {                                          GameObject tempObj = new GameObject();                                              PQSMod_VertexColorSolid vertColor = (PQSMod_VertexColorSolid)tempObj.AddComponent(typeof(PQSMod_VertexColorSolid));                                            tempObj.transform.parent = p.gameObject.transform;                                          vertColor.sphere = p;                                                vertColor.blend = 1.0f;                                          if (modNode.HasValue("blend"))                                              if (float.TryParse(modNode.GetValue("blend")' out ftmp))                                                  vertColor.blend = ftmp;                                            vertColor.order = 9999992;                                          if (modNode.HasValue("order"))                                              if (int.TryParse(modNode.GetValue("order")' out itmp))                                                  vertColor.order = itmp;                                            if (modNode.HasValue("color"))                                          {                                              try                                              {                                                  Vector4 col = KSPUtil.ParseVector4(modNode.GetValue("color"));                                                  Color c = new Color(col.x' col.y' col.z' col.w);                                                  vertColor.color = c;                                              }                                              catch (Exception e)                                              {                                                  print("*RSS* Error parsing as vec4: original text: " + modNode.GetValue("color") + " --- exception " + e.Message);                                              }                                          }                                          vertColor.modEnabled = true;                                          yield return null;                                          vertColor.OnSetup();                                      }                                      if (modNode.name.Equals("PQSMod_VertexHeightMap"))                                      {                                          Texture2D map = null;                                          bool localLoad = Utils.LoadTexture(modNode.GetValue("heightMap")' ref map' false' false' false);                                          if ((object)map != null)                                          {                                              GameObject tempObj = new GameObject();                                                  PQSMod_VertexHeightMap heightMap = (PQSMod_VertexHeightMap)tempObj.AddComponent(typeof(PQSMod_VertexHeightMap));                                              tempObj.transform.parent = p.gameObject.transform;                                              heightMap.sphere = p;                                                yield return null;                                              heightMap.heightMap = ScriptableObject.CreateInstance<MapSO>();                                              heightMap.heightMap.CreateMap(MapSO.MapDepth.Greyscale' map);                                              DestroyImmediate(map);                                              map = null;                                              yield return null;                                              heightMap.heightMapOffset = 0.0f;                                              modNode.TryGetValue("heightMapOffset"' ref heightMap.heightMapOffset);                                                heightMap.heightMapDeformity = 100.0f;                                              modNode.TryGetValue("heightMapDeformity"' ref heightMap.heightMapDeformity);                                                heightMap.scaleDeformityByRadius = false;                                              modNode.TryGetValue("scaleDeformityByRadius"' ref heightMap.scaleDeformityByRadius);                                                heightMap.order = 10;                                              modNode.TryGetValue("order"' ref heightMap.order);                                              heightMap.scaleDeformityByRadius = false;                                                heightMap.modEnabled = true;                                              yield return null;                                              heightMap.OnSetup();                                          }                                          else                                              print("*RSS* *ERROR* texture does not exist! " + modNode.GetValue("vertexColorMap"));                                        }                                      yield return null;                                  }                              }                              if (pqsNode.HasNode("Disable"))                              {                                  foreach (ConfigNode modNode in pqsNode.GetNode("Disable").nodes)                                  {                                      string mName = modNode.name;                                      print("Disabling " + mName);                                      guiExtra = "Disable " + mName;                                      yield return null;                                      //OnGui();                                      if (mName.Equals("PQSLandControl"))                                      {                                          List<PQSLandControl> modList = p.transform.GetComponentsInChildren<PQSLandControl>(true).ToList();                                          /*while(modList.Count > 0)                                          {                                              PQSLandControl m = modList[0];                                              if (m.heightMap != null)                                                  DestroyImmediate(m.heightMap);                                              m.modEnabled = false;                                              m.enabled = false;                                              modList.RemoveAt(0);                                              DestroyImmediate(m);                                          }*/                                          foreach (PQSLandControl m in modList)                                          {                                              m.modEnabled = false;                                              m.enabled = false;                                              m.OnSetup();                                          }                                      }                                      else                                      {                                          int idx = 0;                                          bool doAll = false;                                          if (mName.Contains("'"))                                          {                                              string[] splt = mName.Split(''');                                              mName = splt[0];                                              if (splt[1][0].Equals('*'))                                                  doAll = true;                                              else                                                  int.TryParse(splt[1]' out idx);                                          }                                          print("Generic disable: " + mName + " with idx: " + idx + "; doAll: " + doAll);                                          int cur = 0;                                          foreach (var m in mods)                                          {                                              if (modNode.name.Equals(m.GetType().Name))                                              {                                                  if (cur == idx || doAll)                                                  {                                                      m.GetType().GetField("modEnabled").SetValue(m' false);                                                      print("Found and disabled " + m.GetType().Name);                                                  }                                                  else                                                      cur++;                                              }                                          }                                      }                                  }                              }                              yield return null;                          }                          print("Rebuilding sphere " + p.name);                          guiExtra = "Rebuilding " + p.name;                          yield return null;                          try                          {                              //OnGui();                              //p.ResetSphere();                              p.RebuildSphere();                          }                          catch (Exception e)                          {                              print("Rebuild sphere for " + node.name + " failed: " + e.Message);                          }                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The following statement contains a magic number: if (ScaledSpace.Instance != null)              {                  float SSTScale = 1.0f;                  node.TryGetValue("SSTScale"' ref SSTScale);                  foreach (Transform t in ScaledSpace.Instance.scaledSpaceTransforms)                  {                      if (t.name.Equals(node.name))                      {                          print("*RSS* Found scaledspace transform for " + t.name + "' scale " + t.localScale.x);                          scaledSpaceTransform = t;                          // replace                          int replaceColor = 0;                          string path = "";                          if (node.HasValue("SSColor"))                          {                              replaceColor = 1;                              path = node.GetValue("SSColor");                          }                          if (node.HasValue("SSColor32"))                          {                              replaceColor = 2;                              path = node.GetValue("SSColor32");                          }                          if (replaceColor > 0)                          {                              guiExtra = "Color map";                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' true' true' true);                              if ((object)map != null)                              {                                  Texture oldColor = t.gameObject.renderer.material.GetTexture("_MainTex");                                  if ((object)oldColor != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_MainTex") == oldColor)                                              m.SetTexture("_MainTex"' map);                                      }                                      DestroyImmediate(oldColor);                                      oldColor = null;                                      yield return null;                                  }                              }                          }                          yield return null;                          guiExtra = "";                          if (node.HasValue("SSBump"))                          {                              guiExtra = "Normal Map";                              path = node.GetValue("SSBump");                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' loadInfo.compressNormals' true' true);                              yield return null;                              if ((object)map != null)                              {                                  Texture oldBump = t.gameObject.renderer.material.GetTexture("_BumpMap");                                  if (oldBump != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_BumpMap") == oldBump)                                              m.SetTexture("_BumpMap"' map);                                      }                                      t.gameObject.renderer.material.SetTexture("_BumpMap"' map); // in case one wasn't set.                                      DestroyImmediate(oldBump);                                      oldBump = null;                                      yield return null;                                  }                              }                              yield return null;                              guiExtra = "";                              //OnGui();                          }                          /*if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                          {                              try                              {                                  System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG());                              }                              catch (Exception e)                              {                                  print("*RSS* Failed to get/write ramp for " + body.name + "' exception: " + e.Message);                              }                          }*/                          guiExtra = "Ramp and Specularity";                          yield return null;                          if (node.HasValue("SSRampRef"))                          {                              //if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                              // for now try setting anyway.                              Texture map = null;                              map = GetRamp(node.GetValue("SSRampRef"));                              if (map != null)                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          if (node.HasValue("SSRamp"))                          {                              Texture2D map = null;                              bool localLoad = Utils.LoadTexture(node.GetValue("SSRamp")' ref map' true' true' true);                              if ((object)map != null)                              {                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              }                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          yield return null;                          if (node.HasValue("SSSpec"))                          {                              try                              {                                  Vector4 col = KSPUtil.ParseVector4(node.GetValue("SSSpec"));                                  Color c = new Color(col.x' col.y' col.z' col.w);                                  t.gameObject.renderer.material.SetColor("_SpecColor"' c);                              }                              catch (Exception e)                              {                                  print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message);                              }                          }                          yield return null;                            // Fix mesh                          guiExtra = "Wrapping mesh";                          yield return null;                          bool rescale = true;                          bool doWrapHere = loadInfo.doWrap;                          node.TryGetValue("wrap"' ref doWrapHere);                          bool sphereVal = loadInfo.spheresOnly;                          bool sphereHere = node.TryGetValue("useSphericalSSM"' ref sphereVal);                          float origLocalScale = t.localScale.x; // assume uniform scale                          if (body.pqsController != null && doWrapHere)                          {                              MeshFilter m = (MeshFilter)t.GetComponent(typeof(MeshFilter));                              if (m == null || m.mesh == null)                              {                                  print("*RSS* Failure getting SSM for " + body.pqsController.name + ": mesh is null");                              }                              else                              {                                  char sep = System.IO.Path.DirectorySeparatorChar;                                  string filePath = KSPUtil.ApplicationRootPath + "GameData" + sep + "RealSolarSystem" + sep + "Plugins"                                              + sep + "PluginData" + sep + t.name;                                    filePath += ".obj";                                      bool wrap = true;                                  if (File.Exists(filePath))                                  {                                      try                                      {                                          print("*RSS* loading cached ScaledSpace mesh " + m.name);                                          ProfileTimer.Push("LoadSSM_" + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                            ObjLib.UpdateMeshFromFile(tMesh' filePath);                                          m.mesh = tMesh;                                          m.mesh.RecalculateBounds();                                          print("*RSS* Loaded " + filePath + " and wrapped.");                                          ProfileTimer.Pop("LoadSSM_" + body.name);                                          wrap = false;                                      }                                      catch (Exception ex)                                      {                                          Print("*RSS* Failed to load cached SSM: {0}"' ex);                                      }                                      yield return null;                                  }                                  if (wrap)                                  {                                      try                                      {                                          ProfileTimer.Push("Wrap time for " + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                          if (sphereVal)                                          {                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor);                                              Utils.ScaleVerts(tMesh' scaleFactor);                                          }                                          else                                          {                                              print("*RSS* wrapping ScaledSpace mesh " + m.name + " to PQS " +                                                    body.pqsController.name);                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale));                                              // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              Utils.MatchVerts(tMesh' body.pqsController' body.ocean ? body.Radius : 0.0'                                                  scaleFactor);                                              //ProfileTimer.Push("Recalc Normals");                                              tMesh.RecalculateNormals();                                                //ProfileTimer.Pop("Recalc Normals");                                              ObjLib.UpdateTangents(tMesh);                                              //print("*RSS* wrapped.");                                          }                                          m.mesh = tMesh;                                          try                                          {                                              ObjLib.MeshToFile(m' filePath);                                          }                                          catch (Exception e)                                          {                                              print("*RSS* Exception saving wrapped mesh " + filePath + ": " + e.Message);                                          }                                          //print("*RSS*: Done wrapping and exporting. Setting scale");                                            tMesh.RecalculateBounds();                                          // do normal rescaling below.                                          ProfileTimer.Pop("Wrap time for " + body.name);                                      }                                      catch (Exception e)                                      {                                          print("*RSS* Exception wrapping: " + e.Message);                                      }                                  }                                  yield return null;                                  //OnGui();                              }                          }                          atmo = t.FindChild("Atmosphere");                          //OnGui();                          if (rescale)                          {                              float scaleFactor = (float)((double)origLocalScale * body.Radius / origRadius * SSTScale);                              t.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                          }                          else                          {                              // rescale only atmo                              if (atmo != null)                              {                                  guiExtra = "Atmosphere";                                  yield return null;                                  print("*RSS* found atmo transform for " + node.name);                                  float scaleFactor = loadInfo.SSAtmoScale; // default to global default                                  if (!node.TryGetValue("SSAtmoScale"' ref scaleFactor)) // if no override multiplier                                  {                                      if (loadInfo.defaultAtmoScale) // use stock KSP multiplier                                          scaleFactor *= 1.025f;                                      else // or use atmosphere height-dependent multiplier                                          scaleFactor *= (float)((body.Radius + body.maxAtmosphereAltitude) / body.Radius);                                  }                                  scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet.                                  atmo.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                                  print("*RSS* final scale of atmo for " + body.name + " in scaledspace: " + atmo.localScale.x);                              }                          }                          print("*RSS* final scale of " + body.name + " in scaledspace: " + t.localScale.x);                          yield return null;                          guiExtra = "";                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The following statement contains a magic number: if (ScaledSpace.Instance != null)              {                  float SSTScale = 1.0f;                  node.TryGetValue("SSTScale"' ref SSTScale);                  foreach (Transform t in ScaledSpace.Instance.scaledSpaceTransforms)                  {                      if (t.name.Equals(node.name))                      {                          print("*RSS* Found scaledspace transform for " + t.name + "' scale " + t.localScale.x);                          scaledSpaceTransform = t;                          // replace                          int replaceColor = 0;                          string path = "";                          if (node.HasValue("SSColor"))                          {                              replaceColor = 1;                              path = node.GetValue("SSColor");                          }                          if (node.HasValue("SSColor32"))                          {                              replaceColor = 2;                              path = node.GetValue("SSColor32");                          }                          if (replaceColor > 0)                          {                              guiExtra = "Color map";                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' true' true' true);                              if ((object)map != null)                              {                                  Texture oldColor = t.gameObject.renderer.material.GetTexture("_MainTex");                                  if ((object)oldColor != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_MainTex") == oldColor)                                              m.SetTexture("_MainTex"' map);                                      }                                      DestroyImmediate(oldColor);                                      oldColor = null;                                      yield return null;                                  }                              }                          }                          yield return null;                          guiExtra = "";                          if (node.HasValue("SSBump"))                          {                              guiExtra = "Normal Map";                              path = node.GetValue("SSBump");                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' loadInfo.compressNormals' true' true);                              yield return null;                              if ((object)map != null)                              {                                  Texture oldBump = t.gameObject.renderer.material.GetTexture("_BumpMap");                                  if (oldBump != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_BumpMap") == oldBump)                                              m.SetTexture("_BumpMap"' map);                                      }                                      t.gameObject.renderer.material.SetTexture("_BumpMap"' map); // in case one wasn't set.                                      DestroyImmediate(oldBump);                                      oldBump = null;                                      yield return null;                                  }                              }                              yield return null;                              guiExtra = "";                              //OnGui();                          }                          /*if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                          {                              try                              {                                  System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG());                              }                              catch (Exception e)                              {                                  print("*RSS* Failed to get/write ramp for " + body.name + "' exception: " + e.Message);                              }                          }*/                          guiExtra = "Ramp and Specularity";                          yield return null;                          if (node.HasValue("SSRampRef"))                          {                              //if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                              // for now try setting anyway.                              Texture map = null;                              map = GetRamp(node.GetValue("SSRampRef"));                              if (map != null)                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          if (node.HasValue("SSRamp"))                          {                              Texture2D map = null;                              bool localLoad = Utils.LoadTexture(node.GetValue("SSRamp")' ref map' true' true' true);                              if ((object)map != null)                              {                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              }                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          yield return null;                          if (node.HasValue("SSSpec"))                          {                              try                              {                                  Vector4 col = KSPUtil.ParseVector4(node.GetValue("SSSpec"));                                  Color c = new Color(col.x' col.y' col.z' col.w);                                  t.gameObject.renderer.material.SetColor("_SpecColor"' c);                              }                              catch (Exception e)                              {                                  print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message);                              }                          }                          yield return null;                            // Fix mesh                          guiExtra = "Wrapping mesh";                          yield return null;                          bool rescale = true;                          bool doWrapHere = loadInfo.doWrap;                          node.TryGetValue("wrap"' ref doWrapHere);                          bool sphereVal = loadInfo.spheresOnly;                          bool sphereHere = node.TryGetValue("useSphericalSSM"' ref sphereVal);                          float origLocalScale = t.localScale.x; // assume uniform scale                          if (body.pqsController != null && doWrapHere)                          {                              MeshFilter m = (MeshFilter)t.GetComponent(typeof(MeshFilter));                              if (m == null || m.mesh == null)                              {                                  print("*RSS* Failure getting SSM for " + body.pqsController.name + ": mesh is null");                              }                              else                              {                                  char sep = System.IO.Path.DirectorySeparatorChar;                                  string filePath = KSPUtil.ApplicationRootPath + "GameData" + sep + "RealSolarSystem" + sep + "Plugins"                                              + sep + "PluginData" + sep + t.name;                                    filePath += ".obj";                                      bool wrap = true;                                  if (File.Exists(filePath))                                  {                                      try                                      {                                          print("*RSS* loading cached ScaledSpace mesh " + m.name);                                          ProfileTimer.Push("LoadSSM_" + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                            ObjLib.UpdateMeshFromFile(tMesh' filePath);                                          m.mesh = tMesh;                                          m.mesh.RecalculateBounds();                                          print("*RSS* Loaded " + filePath + " and wrapped.");                                          ProfileTimer.Pop("LoadSSM_" + body.name);                                          wrap = false;                                      }                                      catch (Exception ex)                                      {                                          Print("*RSS* Failed to load cached SSM: {0}"' ex);                                      }                                      yield return null;                                  }                                  if (wrap)                                  {                                      try                                      {                                          ProfileTimer.Push("Wrap time for " + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                          if (sphereVal)                                          {                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor);                                              Utils.ScaleVerts(tMesh' scaleFactor);                                          }                                          else                                          {                                              print("*RSS* wrapping ScaledSpace mesh " + m.name + " to PQS " +                                                    body.pqsController.name);                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale));                                              // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              Utils.MatchVerts(tMesh' body.pqsController' body.ocean ? body.Radius : 0.0'                                                  scaleFactor);                                              //ProfileTimer.Push("Recalc Normals");                                              tMesh.RecalculateNormals();                                                //ProfileTimer.Pop("Recalc Normals");                                              ObjLib.UpdateTangents(tMesh);                                              //print("*RSS* wrapped.");                                          }                                          m.mesh = tMesh;                                          try                                          {                                              ObjLib.MeshToFile(m' filePath);                                          }                                          catch (Exception e)                                          {                                              print("*RSS* Exception saving wrapped mesh " + filePath + ": " + e.Message);                                          }                                          //print("*RSS*: Done wrapping and exporting. Setting scale");                                            tMesh.RecalculateBounds();                                          // do normal rescaling below.                                          ProfileTimer.Pop("Wrap time for " + body.name);                                      }                                      catch (Exception e)                                      {                                          print("*RSS* Exception wrapping: " + e.Message);                                      }                                  }                                  yield return null;                                  //OnGui();                              }                          }                          atmo = t.FindChild("Atmosphere");                          //OnGui();                          if (rescale)                          {                              float scaleFactor = (float)((double)origLocalScale * body.Radius / origRadius * SSTScale);                              t.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                          }                          else                          {                              // rescale only atmo                              if (atmo != null)                              {                                  guiExtra = "Atmosphere";                                  yield return null;                                  print("*RSS* found atmo transform for " + node.name);                                  float scaleFactor = loadInfo.SSAtmoScale; // default to global default                                  if (!node.TryGetValue("SSAtmoScale"' ref scaleFactor)) // if no override multiplier                                  {                                      if (loadInfo.defaultAtmoScale) // use stock KSP multiplier                                          scaleFactor *= 1.025f;                                      else // or use atmosphere height-dependent multiplier                                          scaleFactor *= (float)((body.Radius + body.maxAtmosphereAltitude) / body.Radius);                                  }                                  scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet.                                  atmo.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                                  print("*RSS* final scale of atmo for " + body.name + " in scaledspace: " + atmo.localScale.x);                              }                          }                          print("*RSS* final scale of " + body.name + " in scaledspace: " + t.localScale.x);                          yield return null;                          guiExtra = "";                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The following statement contains a magic number: if (ScaledSpace.Instance != null)              {                  float SSTScale = 1.0f;                  node.TryGetValue("SSTScale"' ref SSTScale);                  foreach (Transform t in ScaledSpace.Instance.scaledSpaceTransforms)                  {                      if (t.name.Equals(node.name))                      {                          print("*RSS* Found scaledspace transform for " + t.name + "' scale " + t.localScale.x);                          scaledSpaceTransform = t;                          // replace                          int replaceColor = 0;                          string path = "";                          if (node.HasValue("SSColor"))                          {                              replaceColor = 1;                              path = node.GetValue("SSColor");                          }                          if (node.HasValue("SSColor32"))                          {                              replaceColor = 2;                              path = node.GetValue("SSColor32");                          }                          if (replaceColor > 0)                          {                              guiExtra = "Color map";                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' true' true' true);                              if ((object)map != null)                              {                                  Texture oldColor = t.gameObject.renderer.material.GetTexture("_MainTex");                                  if ((object)oldColor != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_MainTex") == oldColor)                                              m.SetTexture("_MainTex"' map);                                      }                                      DestroyImmediate(oldColor);                                      oldColor = null;                                      yield return null;                                  }                              }                          }                          yield return null;                          guiExtra = "";                          if (node.HasValue("SSBump"))                          {                              guiExtra = "Normal Map";                              path = node.GetValue("SSBump");                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' loadInfo.compressNormals' true' true);                              yield return null;                              if ((object)map != null)                              {                                  Texture oldBump = t.gameObject.renderer.material.GetTexture("_BumpMap");                                  if (oldBump != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_BumpMap") == oldBump)                                              m.SetTexture("_BumpMap"' map);                                      }                                      t.gameObject.renderer.material.SetTexture("_BumpMap"' map); // in case one wasn't set.                                      DestroyImmediate(oldBump);                                      oldBump = null;                                      yield return null;                                  }                              }                              yield return null;                              guiExtra = "";                              //OnGui();                          }                          /*if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                          {                              try                              {                                  System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG());                              }                              catch (Exception e)                              {                                  print("*RSS* Failed to get/write ramp for " + body.name + "' exception: " + e.Message);                              }                          }*/                          guiExtra = "Ramp and Specularity";                          yield return null;                          if (node.HasValue("SSRampRef"))                          {                              //if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                              // for now try setting anyway.                              Texture map = null;                              map = GetRamp(node.GetValue("SSRampRef"));                              if (map != null)                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          if (node.HasValue("SSRamp"))                          {                              Texture2D map = null;                              bool localLoad = Utils.LoadTexture(node.GetValue("SSRamp")' ref map' true' true' true);                              if ((object)map != null)                              {                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              }                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          yield return null;                          if (node.HasValue("SSSpec"))                          {                              try                              {                                  Vector4 col = KSPUtil.ParseVector4(node.GetValue("SSSpec"));                                  Color c = new Color(col.x' col.y' col.z' col.w);                                  t.gameObject.renderer.material.SetColor("_SpecColor"' c);                              }                              catch (Exception e)                              {                                  print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message);                              }                          }                          yield return null;                            // Fix mesh                          guiExtra = "Wrapping mesh";                          yield return null;                          bool rescale = true;                          bool doWrapHere = loadInfo.doWrap;                          node.TryGetValue("wrap"' ref doWrapHere);                          bool sphereVal = loadInfo.spheresOnly;                          bool sphereHere = node.TryGetValue("useSphericalSSM"' ref sphereVal);                          float origLocalScale = t.localScale.x; // assume uniform scale                          if (body.pqsController != null && doWrapHere)                          {                              MeshFilter m = (MeshFilter)t.GetComponent(typeof(MeshFilter));                              if (m == null || m.mesh == null)                              {                                  print("*RSS* Failure getting SSM for " + body.pqsController.name + ": mesh is null");                              }                              else                              {                                  char sep = System.IO.Path.DirectorySeparatorChar;                                  string filePath = KSPUtil.ApplicationRootPath + "GameData" + sep + "RealSolarSystem" + sep + "Plugins"                                              + sep + "PluginData" + sep + t.name;                                    filePath += ".obj";                                      bool wrap = true;                                  if (File.Exists(filePath))                                  {                                      try                                      {                                          print("*RSS* loading cached ScaledSpace mesh " + m.name);                                          ProfileTimer.Push("LoadSSM_" + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                            ObjLib.UpdateMeshFromFile(tMesh' filePath);                                          m.mesh = tMesh;                                          m.mesh.RecalculateBounds();                                          print("*RSS* Loaded " + filePath + " and wrapped.");                                          ProfileTimer.Pop("LoadSSM_" + body.name);                                          wrap = false;                                      }                                      catch (Exception ex)                                      {                                          Print("*RSS* Failed to load cached SSM: {0}"' ex);                                      }                                      yield return null;                                  }                                  if (wrap)                                  {                                      try                                      {                                          ProfileTimer.Push("Wrap time for " + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                          if (sphereVal)                                          {                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor);                                              Utils.ScaleVerts(tMesh' scaleFactor);                                          }                                          else                                          {                                              print("*RSS* wrapping ScaledSpace mesh " + m.name + " to PQS " +                                                    body.pqsController.name);                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale));                                              // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              Utils.MatchVerts(tMesh' body.pqsController' body.ocean ? body.Radius : 0.0'                                                  scaleFactor);                                              //ProfileTimer.Push("Recalc Normals");                                              tMesh.RecalculateNormals();                                                //ProfileTimer.Pop("Recalc Normals");                                              ObjLib.UpdateTangents(tMesh);                                              //print("*RSS* wrapped.");                                          }                                          m.mesh = tMesh;                                          try                                          {                                              ObjLib.MeshToFile(m' filePath);                                          }                                          catch (Exception e)                                          {                                              print("*RSS* Exception saving wrapped mesh " + filePath + ": " + e.Message);                                          }                                          //print("*RSS*: Done wrapping and exporting. Setting scale");                                            tMesh.RecalculateBounds();                                          // do normal rescaling below.                                          ProfileTimer.Pop("Wrap time for " + body.name);                                      }                                      catch (Exception e)                                      {                                          print("*RSS* Exception wrapping: " + e.Message);                                      }                                  }                                  yield return null;                                  //OnGui();                              }                          }                          atmo = t.FindChild("Atmosphere");                          //OnGui();                          if (rescale)                          {                              float scaleFactor = (float)((double)origLocalScale * body.Radius / origRadius * SSTScale);                              t.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                          }                          else                          {                              // rescale only atmo                              if (atmo != null)                              {                                  guiExtra = "Atmosphere";                                  yield return null;                                  print("*RSS* found atmo transform for " + node.name);                                  float scaleFactor = loadInfo.SSAtmoScale; // default to global default                                  if (!node.TryGetValue("SSAtmoScale"' ref scaleFactor)) // if no override multiplier                                  {                                      if (loadInfo.defaultAtmoScale) // use stock KSP multiplier                                          scaleFactor *= 1.025f;                                      else // or use atmosphere height-dependent multiplier                                          scaleFactor *= (float)((body.Radius + body.maxAtmosphereAltitude) / body.Radius);                                  }                                  scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet.                                  atmo.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                                  print("*RSS* final scale of atmo for " + body.name + " in scaledspace: " + atmo.localScale.x);                              }                          }                          print("*RSS* final scale of " + body.name + " in scaledspace: " + t.localScale.x);                          yield return null;                          guiExtra = "";                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The following statement contains a magic number: if (ScaledSpace.Instance != null)              {                  float SSTScale = 1.0f;                  node.TryGetValue("SSTScale"' ref SSTScale);                  foreach (Transform t in ScaledSpace.Instance.scaledSpaceTransforms)                  {                      if (t.name.Equals(node.name))                      {                          print("*RSS* Found scaledspace transform for " + t.name + "' scale " + t.localScale.x);                          scaledSpaceTransform = t;                          // replace                          int replaceColor = 0;                          string path = "";                          if (node.HasValue("SSColor"))                          {                              replaceColor = 1;                              path = node.GetValue("SSColor");                          }                          if (node.HasValue("SSColor32"))                          {                              replaceColor = 2;                              path = node.GetValue("SSColor32");                          }                          if (replaceColor > 0)                          {                              guiExtra = "Color map";                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' true' true' true);                              if ((object)map != null)                              {                                  Texture oldColor = t.gameObject.renderer.material.GetTexture("_MainTex");                                  if ((object)oldColor != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_MainTex") == oldColor)                                              m.SetTexture("_MainTex"' map);                                      }                                      DestroyImmediate(oldColor);                                      oldColor = null;                                      yield return null;                                  }                              }                          }                          yield return null;                          guiExtra = "";                          if (node.HasValue("SSBump"))                          {                              guiExtra = "Normal Map";                              path = node.GetValue("SSBump");                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' loadInfo.compressNormals' true' true);                              yield return null;                              if ((object)map != null)                              {                                  Texture oldBump = t.gameObject.renderer.material.GetTexture("_BumpMap");                                  if (oldBump != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_BumpMap") == oldBump)                                              m.SetTexture("_BumpMap"' map);                                      }                                      t.gameObject.renderer.material.SetTexture("_BumpMap"' map); // in case one wasn't set.                                      DestroyImmediate(oldBump);                                      oldBump = null;                                      yield return null;                                  }                              }                              yield return null;                              guiExtra = "";                              //OnGui();                          }                          /*if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                          {                              try                              {                                  System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG());                              }                              catch (Exception e)                              {                                  print("*RSS* Failed to get/write ramp for " + body.name + "' exception: " + e.Message);                              }                          }*/                          guiExtra = "Ramp and Specularity";                          yield return null;                          if (node.HasValue("SSRampRef"))                          {                              //if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                              // for now try setting anyway.                              Texture map = null;                              map = GetRamp(node.GetValue("SSRampRef"));                              if (map != null)                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          if (node.HasValue("SSRamp"))                          {                              Texture2D map = null;                              bool localLoad = Utils.LoadTexture(node.GetValue("SSRamp")' ref map' true' true' true);                              if ((object)map != null)                              {                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              }                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          yield return null;                          if (node.HasValue("SSSpec"))                          {                              try                              {                                  Vector4 col = KSPUtil.ParseVector4(node.GetValue("SSSpec"));                                  Color c = new Color(col.x' col.y' col.z' col.w);                                  t.gameObject.renderer.material.SetColor("_SpecColor"' c);                              }                              catch (Exception e)                              {                                  print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message);                              }                          }                          yield return null;                            // Fix mesh                          guiExtra = "Wrapping mesh";                          yield return null;                          bool rescale = true;                          bool doWrapHere = loadInfo.doWrap;                          node.TryGetValue("wrap"' ref doWrapHere);                          bool sphereVal = loadInfo.spheresOnly;                          bool sphereHere = node.TryGetValue("useSphericalSSM"' ref sphereVal);                          float origLocalScale = t.localScale.x; // assume uniform scale                          if (body.pqsController != null && doWrapHere)                          {                              MeshFilter m = (MeshFilter)t.GetComponent(typeof(MeshFilter));                              if (m == null || m.mesh == null)                              {                                  print("*RSS* Failure getting SSM for " + body.pqsController.name + ": mesh is null");                              }                              else                              {                                  char sep = System.IO.Path.DirectorySeparatorChar;                                  string filePath = KSPUtil.ApplicationRootPath + "GameData" + sep + "RealSolarSystem" + sep + "Plugins"                                              + sep + "PluginData" + sep + t.name;                                    filePath += ".obj";                                      bool wrap = true;                                  if (File.Exists(filePath))                                  {                                      try                                      {                                          print("*RSS* loading cached ScaledSpace mesh " + m.name);                                          ProfileTimer.Push("LoadSSM_" + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                            ObjLib.UpdateMeshFromFile(tMesh' filePath);                                          m.mesh = tMesh;                                          m.mesh.RecalculateBounds();                                          print("*RSS* Loaded " + filePath + " and wrapped.");                                          ProfileTimer.Pop("LoadSSM_" + body.name);                                          wrap = false;                                      }                                      catch (Exception ex)                                      {                                          Print("*RSS* Failed to load cached SSM: {0}"' ex);                                      }                                      yield return null;                                  }                                  if (wrap)                                  {                                      try                                      {                                          ProfileTimer.Push("Wrap time for " + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                          if (sphereVal)                                          {                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor);                                              Utils.ScaleVerts(tMesh' scaleFactor);                                          }                                          else                                          {                                              print("*RSS* wrapping ScaledSpace mesh " + m.name + " to PQS " +                                                    body.pqsController.name);                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale));                                              // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              Utils.MatchVerts(tMesh' body.pqsController' body.ocean ? body.Radius : 0.0'                                                  scaleFactor);                                              //ProfileTimer.Push("Recalc Normals");                                              tMesh.RecalculateNormals();                                                //ProfileTimer.Pop("Recalc Normals");                                              ObjLib.UpdateTangents(tMesh);                                              //print("*RSS* wrapped.");                                          }                                          m.mesh = tMesh;                                          try                                          {                                              ObjLib.MeshToFile(m' filePath);                                          }                                          catch (Exception e)                                          {                                              print("*RSS* Exception saving wrapped mesh " + filePath + ": " + e.Message);                                          }                                          //print("*RSS*: Done wrapping and exporting. Setting scale");                                            tMesh.RecalculateBounds();                                          // do normal rescaling below.                                          ProfileTimer.Pop("Wrap time for " + body.name);                                      }                                      catch (Exception e)                                      {                                          print("*RSS* Exception wrapping: " + e.Message);                                      }                                  }                                  yield return null;                                  //OnGui();                              }                          }                          atmo = t.FindChild("Atmosphere");                          //OnGui();                          if (rescale)                          {                              float scaleFactor = (float)((double)origLocalScale * body.Radius / origRadius * SSTScale);                              t.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                          }                          else                          {                              // rescale only atmo                              if (atmo != null)                              {                                  guiExtra = "Atmosphere";                                  yield return null;                                  print("*RSS* found atmo transform for " + node.name);                                  float scaleFactor = loadInfo.SSAtmoScale; // default to global default                                  if (!node.TryGetValue("SSAtmoScale"' ref scaleFactor)) // if no override multiplier                                  {                                      if (loadInfo.defaultAtmoScale) // use stock KSP multiplier                                          scaleFactor *= 1.025f;                                      else // or use atmosphere height-dependent multiplier                                          scaleFactor *= (float)((body.Radius + body.maxAtmosphereAltitude) / body.Radius);                                  }                                  scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet.                                  atmo.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                                  print("*RSS* final scale of atmo for " + body.name + " in scaledspace: " + atmo.localScale.x);                              }                          }                          print("*RSS* final scale of " + body.name + " in scaledspace: " + t.localScale.x);                          yield return null;                          guiExtra = "";                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadScaledSpace,The following statement contains a magic number: if (ScaledSpace.Instance != null)              {                  float SSTScale = 1.0f;                  node.TryGetValue("SSTScale"' ref SSTScale);                  foreach (Transform t in ScaledSpace.Instance.scaledSpaceTransforms)                  {                      if (t.name.Equals(node.name))                      {                          print("*RSS* Found scaledspace transform for " + t.name + "' scale " + t.localScale.x);                          scaledSpaceTransform = t;                          // replace                          int replaceColor = 0;                          string path = "";                          if (node.HasValue("SSColor"))                          {                              replaceColor = 1;                              path = node.GetValue("SSColor");                          }                          if (node.HasValue("SSColor32"))                          {                              replaceColor = 2;                              path = node.GetValue("SSColor32");                          }                          if (replaceColor > 0)                          {                              guiExtra = "Color map";                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' true' true' true);                              if ((object)map != null)                              {                                  Texture oldColor = t.gameObject.renderer.material.GetTexture("_MainTex");                                  if ((object)oldColor != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_MainTex") == oldColor)                                              m.SetTexture("_MainTex"' map);                                      }                                      DestroyImmediate(oldColor);                                      oldColor = null;                                      yield return null;                                  }                              }                          }                          yield return null;                          guiExtra = "";                          if (node.HasValue("SSBump"))                          {                              guiExtra = "Normal Map";                              path = node.GetValue("SSBump");                              Texture2D map = null;                              bool local = Utils.LoadTexture(path' ref map' loadInfo.compressNormals' true' true);                              yield return null;                              if ((object)map != null)                              {                                  Texture oldBump = t.gameObject.renderer.material.GetTexture("_BumpMap");                                  if (oldBump != null)                                  {                                      foreach (Material m in Resources.FindObjectsOfTypeAll(typeof(Material)))                                      {                                          if (m.GetTexture("_BumpMap") == oldBump)                                              m.SetTexture("_BumpMap"' map);                                      }                                      t.gameObject.renderer.material.SetTexture("_BumpMap"' map); // in case one wasn't set.                                      DestroyImmediate(oldBump);                                      oldBump = null;                                      yield return null;                                  }                              }                              yield return null;                              guiExtra = "";                              //OnGui();                          }                          /*if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                          {                              try                              {                                  System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "Ramp.png"' ((Texture2D)t.gameObject.renderer.material.GetTexture("_rimColorRamp")).EncodeToPNG());                              }                              catch (Exception e)                              {                                  print("*RSS* Failed to get/write ramp for " + body.name + "' exception: " + e.Message);                              }                          }*/                          guiExtra = "Ramp and Specularity";                          yield return null;                          if (node.HasValue("SSRampRef"))                          {                              //if (t.gameObject.renderer.material.GetTexture("_rimColorRamp") != null)                              // for now try setting anyway.                              Texture map = null;                              map = GetRamp(node.GetValue("SSRampRef"));                              if (map != null)                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          if (node.HasValue("SSRamp"))                          {                              Texture2D map = null;                              bool localLoad = Utils.LoadTexture(node.GetValue("SSRamp")' ref map' true' true' true);                              if ((object)map != null)                              {                                  t.gameObject.renderer.material.SetTexture("_rimColorRamp"' map);                              }                              else                                  print("*RSS* *ERROR* texture does not exist! " + node.GetValue("SSRamp"));                          }                          yield return null;                          if (node.HasValue("SSSpec"))                          {                              try                              {                                  Vector4 col = KSPUtil.ParseVector4(node.GetValue("SSSpec"));                                  Color c = new Color(col.x' col.y' col.z' col.w);                                  t.gameObject.renderer.material.SetColor("_SpecColor"' c);                              }                              catch (Exception e)                              {                                  print("*RSS* Error reading SSSpec as color4: original text: " + node.GetValue("SSSpec") + " --- exception " + e.Message);                              }                          }                          yield return null;                            // Fix mesh                          guiExtra = "Wrapping mesh";                          yield return null;                          bool rescale = true;                          bool doWrapHere = loadInfo.doWrap;                          node.TryGetValue("wrap"' ref doWrapHere);                          bool sphereVal = loadInfo.spheresOnly;                          bool sphereHere = node.TryGetValue("useSphericalSSM"' ref sphereVal);                          float origLocalScale = t.localScale.x; // assume uniform scale                          if (body.pqsController != null && doWrapHere)                          {                              MeshFilter m = (MeshFilter)t.GetComponent(typeof(MeshFilter));                              if (m == null || m.mesh == null)                              {                                  print("*RSS* Failure getting SSM for " + body.pqsController.name + ": mesh is null");                              }                              else                              {                                  char sep = System.IO.Path.DirectorySeparatorChar;                                  string filePath = KSPUtil.ApplicationRootPath + "GameData" + sep + "RealSolarSystem" + sep + "Plugins"                                              + sep + "PluginData" + sep + t.name;                                    filePath += ".obj";                                      bool wrap = true;                                  if (File.Exists(filePath))                                  {                                      try                                      {                                          print("*RSS* loading cached ScaledSpace mesh " + m.name);                                          ProfileTimer.Push("LoadSSM_" + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                            ObjLib.UpdateMeshFromFile(tMesh' filePath);                                          m.mesh = tMesh;                                          m.mesh.RecalculateBounds();                                          print("*RSS* Loaded " + filePath + " and wrapped.");                                          ProfileTimer.Pop("LoadSSM_" + body.name);                                          wrap = false;                                      }                                      catch (Exception ex)                                      {                                          Print("*RSS* Failed to load cached SSM: {0}"' ex);                                      }                                      yield return null;                                  }                                  if (wrap)                                  {                                      try                                      {                                          ProfileTimer.Push("Wrap time for " + body.name);                                          Mesh tMesh = new Mesh();                                          Utils.CopyMesh(loadInfo.joolMesh.mesh' tMesh);                                          if (sphereVal)                                          {                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale)); // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              print("*RSS* using Jool scaledspace mesh (spherical) for body " + body.pqsController.name + ". Vertex Scale " + scaleFactor);                                              Utils.ScaleVerts(tMesh' scaleFactor);                                          }                                          else                                          {                                              print("*RSS* wrapping ScaledSpace mesh " + m.name + " to PQS " +                                                    body.pqsController.name);                                              float scaleFactor = (float)(origRadius / (1000 * 6000 * (double)origLocalScale));                                              // scale mesh such that it will end up right.                                              // (need to scale it such that in the end localScale will = origLocalScale * radius/origRadius)                                              Utils.MatchVerts(tMesh' body.pqsController' body.ocean ? body.Radius : 0.0'                                                  scaleFactor);                                              //ProfileTimer.Push("Recalc Normals");                                              tMesh.RecalculateNormals();                                                //ProfileTimer.Pop("Recalc Normals");                                              ObjLib.UpdateTangents(tMesh);                                              //print("*RSS* wrapped.");                                          }                                          m.mesh = tMesh;                                          try                                          {                                              ObjLib.MeshToFile(m' filePath);                                          }                                          catch (Exception e)                                          {                                              print("*RSS* Exception saving wrapped mesh " + filePath + ": " + e.Message);                                          }                                          //print("*RSS*: Done wrapping and exporting. Setting scale");                                            tMesh.RecalculateBounds();                                          // do normal rescaling below.                                          ProfileTimer.Pop("Wrap time for " + body.name);                                      }                                      catch (Exception e)                                      {                                          print("*RSS* Exception wrapping: " + e.Message);                                      }                                  }                                  yield return null;                                  //OnGui();                              }                          }                          atmo = t.FindChild("Atmosphere");                          //OnGui();                          if (rescale)                          {                              float scaleFactor = (float)((double)origLocalScale * body.Radius / origRadius * SSTScale);                              t.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                          }                          else                          {                              // rescale only atmo                              if (atmo != null)                              {                                  guiExtra = "Atmosphere";                                  yield return null;                                  print("*RSS* found atmo transform for " + node.name);                                  float scaleFactor = loadInfo.SSAtmoScale; // default to global default                                  if (!node.TryGetValue("SSAtmoScale"' ref scaleFactor)) // if no override multiplier                                  {                                      if (loadInfo.defaultAtmoScale) // use stock KSP multiplier                                          scaleFactor *= 1.025f;                                      else // or use atmosphere height-dependent multiplier                                          scaleFactor *= (float)((body.Radius + body.maxAtmosphereAltitude) / body.Radius);                                  }                                  scaleFactor *= origLocalScale / t.localScale.x * (float)(body.Radius / origRadius); // since our parent transform changed' we no longer are the same scale as the planet.                                  atmo.localScale = new Vector3(scaleFactor' scaleFactor' scaleFactor);                                  print("*RSS* final scale of atmo for " + body.name + " in scaledspace: " + atmo.localScale.x);                              }                          }                          print("*RSS* final scale of " + body.name + " in scaledspace: " + t.localScale.x);                          yield return null;                          guiExtra = "";                      }                  }              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadExport,The following statement contains a magic number: if (node.HasNode("Export"))              {                  guiMinor = "Exporting maps";                  guiExtra = "";                  yield return null;                  //OnGui();                  int res = 2048;                  bool ocean = false;                  Color oceanColor;                  double maxHeight' oceanHeight;                  PQS bodyPQS = null;                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                      if (p.name.Equals(body.name))                      {                          bodyPQS = p;                          break;                      }                  if (bodyPQS != null)                  {                      maxHeight = bodyPQS.radiusDelta * 0.5;                      oceanHeight = 0;                      ocean = body.ocean;                      oceanColor = new Color(0.1255f' 0.22353f' 0.35683f);                      ConfigNode exportNode = node.GetNode("Export");                      if (exportNode.HasValue("resolution"))                      {                          if (int.TryParse(exportNode.GetValue("resolution")' out itmp))                              res = itmp;                      }                      if (exportNode.HasValue("maxHeight"))                      {                          if (double.TryParse(exportNode.GetValue("maxHeight")' out dtmp))                              maxHeight = dtmp;                      }                      if (exportNode.HasValue("ocean"))                      {                          if (bool.TryParse(exportNode.GetValue("ocean")' out btmp))                              ocean = btmp;                      }                      if (exportNode.HasValue("oceanHeight"))                      {                          if (double.TryParse(exportNode.GetValue("oceanHeight")' out dtmp))                              oceanHeight = dtmp;                      }                      if (exportNode.HasValue("oceanColor"))                      {                          try                          {                              ocean = true;                              Vector4 col = KSPUtil.ParseVector4(exportNode.GetValue("oceanColor"));                              oceanColor = new Color(col.x' col.y' col.z' col.w);                          }                          catch (Exception e)                          {                              print("*RSS* Error parsing as col3: original text: " + exportNode.GetValue("oceanColor") + " --- exception " + e.Message);                          }                      }                      Texture2D[] outputMaps = bodyPQS.CreateMaps(res' maxHeight' ocean' oceanHeight' oceanColor);                      yield return null;                      System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "1.png"' outputMaps[0].EncodeToPNG());                      yield return null;                      System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "2.png"' outputMaps[1].EncodeToPNG());                      yield return null;                  }                  guiMinor = "";                  //OnGui();              }
Magic Number,RealSolarSystem,RealSolarSystem,C:\repos\NathanKell_RealSolarSystem\Source\RealSolarSystem.cs,LoadExport,The following statement contains a magic number: if (node.HasNode("Export"))              {                  guiMinor = "Exporting maps";                  guiExtra = "";                  yield return null;                  //OnGui();                  int res = 2048;                  bool ocean = false;                  Color oceanColor;                  double maxHeight' oceanHeight;                  PQS bodyPQS = null;                  foreach (PQS p in Resources.FindObjectsOfTypeAll(typeof(PQS)))                      if (p.name.Equals(body.name))                      {                          bodyPQS = p;                          break;                      }                  if (bodyPQS != null)                  {                      maxHeight = bodyPQS.radiusDelta * 0.5;                      oceanHeight = 0;                      ocean = body.ocean;                      oceanColor = new Color(0.1255f' 0.22353f' 0.35683f);                      ConfigNode exportNode = node.GetNode("Export");                      if (exportNode.HasValue("resolution"))                      {                          if (int.TryParse(exportNode.GetValue("resolution")' out itmp))                              res = itmp;                      }                      if (exportNode.HasValue("maxHeight"))                      {                          if (double.TryParse(exportNode.GetValue("maxHeight")' out dtmp))                              maxHeight = dtmp;                      }                      if (exportNode.HasValue("ocean"))                      {                          if (bool.TryParse(exportNode.GetValue("ocean")' out btmp))                              ocean = btmp;                      }                      if (exportNode.HasValue("oceanHeight"))                      {                          if (double.TryParse(exportNode.GetValue("oceanHeight")' out dtmp))                              oceanHeight = dtmp;                      }                      if (exportNode.HasValue("oceanColor"))                      {                          try                          {                              ocean = true;                              Vector4 col = KSPUtil.ParseVector4(exportNode.GetValue("oceanColor"));                              oceanColor = new Color(col.x' col.y' col.z' col.w);                          }                          catch (Exception e)                          {                              print("*RSS* Error parsing as col3: original text: " + exportNode.GetValue("oceanColor") + " --- exception " + e.Message);                          }                      }                      Texture2D[] outputMaps = bodyPQS.CreateMaps(res' maxHeight' ocean' oceanHeight' oceanColor);                      yield return null;                      System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "1.png"' outputMaps[0].EncodeToPNG());                      yield return null;                      System.IO.File.WriteAllBytes(KSPUtil.ApplicationRootPath + body.name + "2.png"' outputMaps[1].EncodeToPNG());                      yield return null;                  }                  guiMinor = "";                  //OnGui();              }
Magic Number,RealSolarSystem,TimeWarpFixer,C:\repos\NathanKell_RealSolarSystem\Source\TimeWarpFixer.cs,Update,The following statement contains a magic number: if (!fixedTimeWarp && TimeWarp.fetch != null)              {                  fixedTimeWarp = true;                  ConfigNode twNode = null;                  foreach (ConfigNode node in GameDatabase.Instance.GetConfigNodes("REALSOLARSYSTEMSETTINGS"))                      twNode = node.GetNode("timeWarpRates");                  float ftmp;                  if (twNode != null)                  {                      for (int i = 1; i < 8; i++)                      {                          if (twNode.HasValue("rate" + i))                              if (float.TryParse(twNode.GetValue("rate" + i)' out ftmp))                                  TimeWarp.fetch.warpRates[i] = ftmp;                      }                  }                  Destroy(this);              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadAnimationCurve,The following statement contains a magic number: try              {                  for (int i = 0; i < curveData.Length; i++)                  {                      string[] keyTmp = curveData[i].Split(cParams' StringSplitOptions.RemoveEmptyEntries);                      if (keyTmp.Length == 4)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          key.inTangent = float.Parse(keyTmp[2]);                          key.outTangent = float.Parse(keyTmp[3]);                          animationCurve.AddKey(key);                      }                      else if (keyTmp.Length == 2)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          animationCurve.AddKey(key);                      }                      else                      {                          MonoBehaviour.print("*RSS* Invalid animationCurve data: animationCurve data must have exactly two or four parameters!");                      }                  }                  return animationCurve;              }              catch (Exception e)              {                  print("Caught exception while parsing animationcurve: " + e.Message);                  return null;              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadAnimationCurve,The following statement contains a magic number: try              {                  for (int i = 0; i < curveData.Length; i++)                  {                      string[] keyTmp = curveData[i].Split(cParams' StringSplitOptions.RemoveEmptyEntries);                      if (keyTmp.Length == 4)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          key.inTangent = float.Parse(keyTmp[2]);                          key.outTangent = float.Parse(keyTmp[3]);                          animationCurve.AddKey(key);                      }                      else if (keyTmp.Length == 2)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          animationCurve.AddKey(key);                      }                      else                      {                          MonoBehaviour.print("*RSS* Invalid animationCurve data: animationCurve data must have exactly two or four parameters!");                      }                  }                  return animationCurve;              }              catch (Exception e)              {                  print("Caught exception while parsing animationcurve: " + e.Message);                  return null;              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadAnimationCurve,The following statement contains a magic number: try              {                  for (int i = 0; i < curveData.Length; i++)                  {                      string[] keyTmp = curveData[i].Split(cParams' StringSplitOptions.RemoveEmptyEntries);                      if (keyTmp.Length == 4)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          key.inTangent = float.Parse(keyTmp[2]);                          key.outTangent = float.Parse(keyTmp[3]);                          animationCurve.AddKey(key);                      }                      else if (keyTmp.Length == 2)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          animationCurve.AddKey(key);                      }                      else                      {                          MonoBehaviour.print("*RSS* Invalid animationCurve data: animationCurve data must have exactly two or four parameters!");                      }                  }                  return animationCurve;              }              catch (Exception e)              {                  print("Caught exception while parsing animationcurve: " + e.Message);                  return null;              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadAnimationCurve,The following statement contains a magic number: try              {                  for (int i = 0; i < curveData.Length; i++)                  {                      string[] keyTmp = curveData[i].Split(cParams' StringSplitOptions.RemoveEmptyEntries);                      if (keyTmp.Length == 4)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          key.inTangent = float.Parse(keyTmp[2]);                          key.outTangent = float.Parse(keyTmp[3]);                          animationCurve.AddKey(key);                      }                      else if (keyTmp.Length == 2)                      {                          Keyframe key = new Keyframe();                          key.time = float.Parse(keyTmp[0]);                          key.value = float.Parse(keyTmp[1]);                          animationCurve.AddKey(key);                      }                      else                      {                          MonoBehaviour.print("*RSS* Invalid animationCurve data: animationCurve data must have exactly two or four parameters!");                      }                  }                  return animationCurve;              }              catch (Exception e)              {                  print("Caught exception while parsing animationcurve: " + e.Message);                  return null;              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,MatchVerts,The following statement contains a magic number: for (int i = 0; i < mesh.vertexCount; i++)              {                  Vector3 v = mesh.vertices[i];                  double height = pqs.GetSurfaceHeight(v);                  if (height < oceanHeight)                      height = oceanHeight;                  vertices[i] = v.normalized * (float)(1000.0 * height / pqs.radius * scaleFactor);              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadTexture,The following statement contains a magic number: if ((object)map == null)              {                  print("RSS Loading local texture " + path);                  path = KSPUtil.ApplicationRootPath + path;                  if (File.Exists(path))                  {                      try                      {                          map = new Texture2D(4' 4' TextureFormat.RGB24' true);                          if (path.ToLower().Contains(".dds"))                          {                              GameDatabase.TextureInfo tInfo = DDSLoader.DatabaseLoaderTexture_DDS.LoadDDS(path' !unreadable' path.Contains("NRM")' -1' upload);                              map = tInfo.texture;                          }                          else                          {                              map.LoadImage(System.IO.File.ReadAllBytes(path));                              if (compress)                                  map.Compress(true);                              if (upload)                                  map.Apply(true' unreadable);                          }                          return true;                      }                      catch (Exception e)                      {                          Debug.Log("*RSS* *ERROR* failed to load " + path + " with exception " + e.Message);                      }                  }                  else                      print("*RSS* *ERROR* texture does not exist! " + path);              }
Magic Number,RealSolarSystem,Utils,C:\repos\NathanKell_RealSolarSystem\Source\Utils.cs,LoadTexture,The following statement contains a magic number: if ((object)map == null)              {                  print("RSS Loading local texture " + path);                  path = KSPUtil.ApplicationRootPath + path;                  if (File.Exists(path))                  {                      try                      {                          map = new Texture2D(4' 4' TextureFormat.RGB24' true);                          if (path.ToLower().Contains(".dds"))                          {                              GameDatabase.TextureInfo tInfo = DDSLoader.DatabaseLoaderTexture_DDS.LoadDDS(path' !unreadable' path.Contains("NRM")' -1' upload);                              map = tInfo.texture;                          }                          else                          {                              map.LoadImage(System.IO.File.ReadAllBytes(path));                              if (compress)                                  map.Compress(true);                              if (upload)                                  map.Apply(true' unreadable);                          }                          return true;                      }                      catch (Exception e)                      {                          Debug.Log("*RSS* *ERROR* failed to load " + path + " with exception " + e.Message);                      }                  }                  else                      print("*RSS* *ERROR* texture does not exist! " + path);              }
Magic Number,RealSolarSystem,RSSWatchDog,C:\repos\NathanKell_RealSolarSystem\Source\Watchdogs.cs,FixedUpdate,The following statement contains a magic number: if (counter < 3600)                  return;
Missing Default,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,UpdateMeshFromFile,The following switch statement is missing a default case: switch (brokenString[0])                      {                          case "v":                              vertices.Add(new Vector3(System.Convert.ToSingle(brokenString[1]) * scaleFactor' System.Convert.ToSingle(brokenString[2]) * scaleFactor'                                  System.Convert.ToSingle(brokenString[3]) * scaleFactor));                              break;                          case "vn":                              normals.Add(new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])));                              break;                          case "t":                              tangents.Add(new Vector4(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                  System.Convert.ToSingle(brokenString[3])' System.Convert.ToSingle(brokenString[4])));                              break;                          case "vt":                              uv.Add(new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])));                              break;                      }
Missing Default,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,createMeshStruct,The following switch statement is missing a default case: switch (brokenString[0])                          {                              case "v":                                  vertices++;                                  break;                              case "vt":                                  vt++;                                  break;                              case "vn":                                  vn++;                                  break;                              case "f":                                  face = face + brokenString.Length - 1;                                  triangles = triangles + 3 * (brokenString.Length - 2); /*brokenString.Length is 3 or greater since a face must have at least                                                                                       3 vertices.  For each additional vertice' there is an additional                                                                                       triangle in the mesh (hence this formula).*/                                  break;                          }
Missing Default,RealSolarSystem,ObjLib,C:\repos\NathanKell_RealSolarSystem\Source\ObjLib.cs,populateMeshStruct,The following switch statement is missing a default case: switch (brokenString[0])                          {                              case "g":                                  break;                              case "usemtl":                                  break;                              case "usemap":                                  break;                              case "mtllib":                                  break;                              case "v":                                  mesh.vertices[v] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                           System.Convert.ToSingle(brokenString[3]));                                  v++;                                  break;                              case "vt":                                  mesh.uv[vt] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt++;                                  break;                              case "vt1":                                  mesh.uv[vt1] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt1++;                                  break;                              case "vt2":                                  mesh.uv[vt2] = new Vector2(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2]));                                  vt2++;                                  break;                              case "vn":                                  mesh.normals[vn] = new Vector3(System.Convert.ToSingle(brokenString[1])' System.Convert.ToSingle(brokenString[2])'                                                          System.Convert.ToSingle(brokenString[3]));                                  vn++;                                  break;                              case "vc":                                  break;                              case "f":                                    int j = 1;                                  List<int> intArray = new List<int>();                                  while (j < brokenString.Length && ("" + brokenString[j]).Length > 0)                                  {                                      Vector3 temp = new Vector3();                                      brokenBrokenString = brokenString[j].Split(splitIdentifier2' 3);    //Separate the face into individual components (vert' uv' normal)                                      temp.x = System.Convert.ToInt32(brokenBrokenString[0]);                                      if (brokenBrokenString.Length > 1)                                  //Some .obj files skip UV and normal                                      {                                          if (brokenBrokenString[1] != "")                                    //Some .obj files skip the uv and not the normal                                          {                                              temp.y = System.Convert.ToInt32(brokenBrokenString[1]);                                          }                                          temp.z = System.Convert.ToInt32(brokenBrokenString[2]);                                      }                                      j++;                                        mesh.faceData[f2] = temp;                                      intArray.Add(f2);                                      f2++;                                  }                                  j = 1;                                  while (j + 2 < brokenString.Length)     //Create triangles out of the face data.  There will generally be more than 1 triangle per face.                                  {                                      mesh.triangles[f] = intArray[0];                                      f++;                                      mesh.triangles[f] = intArray[j];                                      f++;                                      mesh.triangles[f] = intArray[j + 1];                                      f++;                                        j++;                                  }                                  break;                          }
