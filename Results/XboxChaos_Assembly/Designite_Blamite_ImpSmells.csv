Implementation smell,Namespace,Class,File,Method,Description
Long Method,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The method has 138 lines of code.
Long Method,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The method has 102 lines of code.
Long Method,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,HandleValueElement,The method has 135 lines of code.
Long Method,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The method has 155 lines of code.
Complex Method,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,Cyclomatic complexity of the method is 18
Complex Method,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,Cyclomatic complexity of the method is 23
Complex Method,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,Cyclomatic complexity of the method is 15
Complex Method,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,Cyclomatic complexity of the method is 17
Complex Method,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,DiscardInvalidTokens,Cyclomatic complexity of the method is 9
Complex Method,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,CharToString,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateCode,Cyclomatic complexity of the method is 16
Complex Method,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,Cyclomatic complexity of the method is 18
Complex Method,Blamite.Blam.ThirdGen.Shaders,ThirdGenShaderStreamer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Shaders\ThirdGenShaderStreamer.cs,ReadShaderInfo,Cyclomatic complexity of the method is 12
Complex Method,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,Serialize,Cyclomatic complexity of the method is 10
Complex Method,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,FreeBlock,Cyclomatic complexity of the method is 15
Complex Method,Blamite.Serialization.Settings,XMLLayoutLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLLayoutLoader.cs,IdentifyValueType,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,Cyclomatic complexity of the method is 8
Complex Method,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,Cyclomatic complexity of the method is 11
Complex Method,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,Cyclomatic complexity of the method is 13
Complex Method,Blamite.Injection,TagContainerWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerWriter.cs,WriteDataBlocks,Cyclomatic complexity of the method is 10
Complex Method,Blamite.Injection,TagContainerInjector,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,InjectTag,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Injection,TagContainerInjector,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,InjectResource,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Patching,DataComparer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\DataComparer.cs,CompareData,Cyclomatic complexity of the method is 11
Complex Method,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,HandleValueElement,Cyclomatic complexity of the method is 41
Complex Method,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,Cyclomatic complexity of the method is 44
Complex Method,Blamite.Plugins.Generation,MetaAnalyzer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,Cyclomatic complexity of the method is 9
Long Parameter List,Blamite.Blam,IndexedStringTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\IndexedStringTable.cs,IndexedStringTable,The method has 5 parameters. Parameters: reader' count' indexTable' data' key
Long Parameter List,Blamite.Blam.Resources.Sounds,SoundReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Sounds\SoundReader.cs,ReadSoundData,The method has 6 parameters. Parameters: reader' sound' cacheFile' resourcePages' resourceCacheFolder' buildInfo
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The method has 5 parameters. Parameters: x' y' z' w' layout
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,TransformElement,The method has 5 parameters. Parameters: x' y' z' w' usage
Long Parameter List,Blamite.Blam.Resources.Models,IVertexProcessor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\IVertexProcessor.cs,ProcessVertexElement,The method has 5 parameters. Parameters: x' y' z' w' layout
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadModelData,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadVertexBuffers,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionVertices,The method has 5 parameters. Parameters: reader' section' boundingBox' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadIndexBuffers,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The method has 5 parameters. Parameters: reader' section' baseIndex' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadVertices,The method has 5 parameters. Parameters: reader' layout' count' boundingBox' processor
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,TransformElement,The method has 6 parameters. Parameters: x' y' z' w' usage' boundingBox
Long Parameter List,Blamite.Blam.Scripting.Compiler,ScriptObjectReflexive,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Compiler\ScriptObjectReflexive.cs,ReadObjects,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting.Compiler,ScriptObjectReflexive,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Compiler\ScriptObjectReflexive.cs,ReadScriptObject,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,ScriptFunctionInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\ScriptFunctionInfo.cs,ScriptFunctionInfo,The method has 5 parameters. Parameters: name' opcode' returnType' flags' parameterTypes
Long Parameter List,Blamite.Blam.Scripting,Script,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Script.cs,Script,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,Script,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Script.cs,Load,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,ScriptValueType,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\ScriptValueType.cs,ScriptValueType,The method has 5 parameters. Parameters: name' opcode' size' quoted' tag
Long Parameter List,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,ThirdGenLanguage,The method has 5 parameters. Parameters: language' values' segmenter' localeArea' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Resources,ThirdGenResourceManager,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\ThirdGenResourceManager.cs,ThirdGenResourceManager,The method has 6 parameters. Parameters: gestalt' layoutTable' tags' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,ThirdGenSimulationDefinitionTable,The method has 6 parameters. Parameters: scenario' tags' reader' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,ThirdGenZoneSetTable,The method has 5 parameters. Parameters: gestalt' reader' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveZoneSetTable,The method has 6 parameters. Parameters: set' tagValues' countName' addressName' cache' stream
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveZoneSetTable,The method has 6 parameters. Parameters: sets' tagValues' countName' addressName' cache' stream
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,ThirdGenResourceGestalt,The method has 6 parameters. Parameters: reader' zoneTag' metaArea' allocator' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,LoadResource,The method has 6 parameters. Parameters: values' index' tags' pointers' infoBuffer' reader
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenScenarioScriptFile,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenScenarioScriptFile.cs,ThirdGenScenarioScriptFile,The method has 5 parameters. Parameters: scenarioTag' scenarioName' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The method has 7 parameters. Parameters: bits' countName' addressName' allocator' stream' cache' values
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenTagTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenTagTable.cs,ThirdGenTagTable,The method has 5 parameters. Parameters: reader' indexHeaderLocation' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Resources.Models,ThirdGenModelSection,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Models\ThirdGenModelSection.cs,LoadVertexGroups,The method has 5 parameters. Parameters: values' reader' metaArea' buildInfo' submeshes
Long Parameter List,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The method has 5 parameters. Parameters: address' oldSize' newSize' align' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveReader.cs,ReadReflexive,The method has 5 parameters. Parameters: reader' count' address' entryLayout' metaArea
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 5 parameters. Parameters: entries' address' layout' metaArea' writer
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 5 parameters. Parameters: entries' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 7 parameters. Parameters: entries' oldCount' oldAddress' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 8 parameters. Parameters: entries' oldCount' oldAddress' newCount' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Serialization,StringIDLayout,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StringIDLayout.cs,StringIDLayout,The method has 6 parameters. Parameters: indexStart' indexSize' setStart' setSize' lengthStart' lengthSize
Long Parameter List,Blamite.Serialization,VertexElementLayout,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\VertexElementLayout.cs,VertexElementLayout,The method has 5 parameters. Parameters: stream' offset' type' usage' usageIndex
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.IO,FileSegmenter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenter.cs,DefineSegment,The method has 5 parameters. Parameters: offset' size' offsetAlignment' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,FileSegmenterExtensions,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenterExtensions.cs,WrapSegment,The method has 5 parameters. Parameters: segmenter' offset' size' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,FileSegmenterExtensions,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenterExtensions.cs,WrapSegment,The method has 6 parameters. Parameters: segmenter' offset' size' offsetAlignment' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,TableSystem,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,CreateTable,The method has 5 parameters. Parameters: name' entrylength' count' maxcount' entries
Long Parameter List,Blamite.IO,TableSystem,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,CreateTable,The method has 5 parameters. Parameters: name' entrylength' count' maxcount' entry
Long Parameter List,Blamite.IO,StreamUtil,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\StreamUtil.cs,MakeFreeSpace,The method has 5 parameters. Parameters: stream' startOffset' originalEndOffset' requestedSize' pageSize
Long Parameter List,Blamite.Blam.SecondGen.Structures,SecondGenTagTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenTagTable.cs,ReadTags,The method has 5 parameters. Parameters: reader' tagTableOffset' numTags' buildInfo' metaArea
Long Parameter List,Blamite.Patching,DataComparer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\DataComparer.cs,CompareData,The method has 7 parameters. Parameters: originalReader' originalOffset' originalSize' newReader' newOffset' newSize' extraDataAtEnd
Long Parameter List,Blamite.Patching,PatchBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\PatchBuilder.cs,BuildPatch,The method has 5 parameters. Parameters: originalFile' originalReader' newFile' newReader' output
Long Parameter List,Blamite.Patching,SegmentChange,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\SegmentChange.cs,SegmentChange,The method has 5 parameters. Parameters: oldOffset' oldActualSize' newOffset' newActualSize' resizeAtEnd
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' length' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' length' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadDataRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadRange,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadTagRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadAscii,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadUtf16,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadReflexive,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadRaw,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadShader,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadUnicList,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' minval' maxval' smallchange' largechange' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadDataRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadTagRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadAscii,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadUtf16,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadRaw,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadShader,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadUnicList,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadReflexive,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Native,ProcessMemoryStream,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,ReadProcessMemory,The method has 5 parameters. Parameters: hProcess' lpBaseAddress' lpBuffer' nSize' lpNumberOfBytesRead
Long Parameter List,Blamite.Native,ProcessMemoryStream,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,WriteProcessMemory,The method has 5 parameters. Parameters: hProcess' lpBaseAddress' lpBuffer' nSize' lpNumberOfBytesWritten
Long Parameter List,Blamite.Util,AES,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\AES.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' length' key' iv
Long Parameter List,Blamite.Util,AES,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\AES.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' length' key' iv
Long Identifier,Blamite.Injection,TagContainer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainer.cs,,The length of the parameter _extractedResourcePageByPageIndex is 33.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter NoPatchMapHeaderRelativeAddress is 31.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter Patch1MapHeaderRelativeAddress is 30.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter Patch2MapHeaderRelativeAddress is 30.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); } " is 182.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "                   var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue); " is 167.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "                   var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue); " is 168.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); } " is 149.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); } " is 156.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); } " is 151.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); } " is 132.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); } " is 148.
Long Statement,Blamite.Blam.ThirdGen,ThirdGenCacheFile,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\ThirdGenCacheFile.cs,LoadSimulationDefinitions,The length of the statement  "			if (_tags != null && _buildInfo.Layouts.HasLayout("scnr") && _buildInfo.Layouts.HasLayout("simulation definition table entry")) " is 127.
Long Statement,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMapInfo,The length of the statement  "				throw new NotSupportedException("Engine version " + version + " of size 0x" + size.ToString("X") + " is not supported"); " is 120.
Long Statement,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguagePackLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguagePackLoader.cs,SaveLanguage,The length of the statement  "			var strings = pack.StringLists.SelectMany(l => _sortByStringId ? l.Strings.OrderBy(s => s.Key.Value).ToList() : l.Strings).ToList(); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,SaveChanges,The length of the statement  "			var newAddr = ReflexiveWriter.WriteReflexive(newTable' oldCount' oldAddress' _table.Count' entryLayout' _metaArea' _allocator' stream); " is 135.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,Load,The length of the statement  "			_table = ReflexiveReader.ReadReflexive(reader' count' address' entryLayout' _metaArea).Select((e) => _tags[new DatumIndex(e.GetInteger("datum index"))]).ToList(); " is 162.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(GlobalZoneSet' tagValues' "number of global zone sets"' "global zone set table address"' cache' stream); " is 121.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(UnattachedZoneSet' tagValues' "number of unattached zone sets"' "unattached zone set table address"' cache' stream); " is 133.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(DiscForbiddenZoneSet' tagValues' "number of disc forbidden zone sets"' "disc forbidden zone set table address"' cache' stream); " is 144.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(DiscAlwaysStreamingZoneSet' tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' cache' stream); " is 164.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(GeneralZoneSets' tagValues' "number of general zone sets"' "general zone set table address"' cache' stream); " is 125.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(CinematicZoneSets' tagValues' "number of cinematic zone sets"' "cinematic zone set table address"' cache' stream); " is 131.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(CustomZoneSets' tagValues' "number of custom zone sets"' "custom zone set table address"' cache' stream); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			GlobalZoneSet = ReadZoneSetTable(tagValues' "number of global zone sets"' "global zone set table address"' reader).FirstOrDefault(); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			UnattachedZoneSet = ReadZoneSetTable(tagValues' "number of unattached zone sets"' "unattached zone set table address"' reader).FirstOrDefault(); " is 144.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			DiscForbiddenZoneSet = ReadZoneSetTable(tagValues' "number of disc forbidden zone sets"' "disc forbidden zone set table address"' reader).FirstOrDefault(); " is 155.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			DiscAlwaysStreamingZoneSet = ReadZoneSetTable(tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' reader).FirstOrDefault(); " is 175.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			GeneralZoneSets = ReadZoneSetTable(tagValues' "number of general zone sets"' "general zone set table address"' reader).ToArray(); " is 129.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			BSPZoneSets2 = ReadZoneSetTable(tagValues' "number of bsp 2 zone sets"' "bsp 2 zone set table address"' reader).ToArray(); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			BSPZoneSets3 = ReadZoneSetTable(tagValues' "number of bsp 3 zone sets"' "bsp 3 zone set table address"' reader).ToArray(); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			CinematicZoneSets = ReadZoneSetTable(tagValues' "number of cinematic zone sets"' "cinematic zone set table address"' reader).ToArray(); " is 135.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			CustomZoneSets = ReadZoneSetTable(tagValues' "number of custom zone sets"' "custom zone set table address"' reader).ToArray(); " is 126.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,FreeZoneSets,The length of the statement  "			FreeZoneSetsInTable(tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' reader); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_activeResources' "number of raw pool bitfields"' "raw pool bitfield table address"' allocator' stream' cache' result); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownResources' "number of raw pool 2 bitfields"' "raw pool 2 bitfield table address"' allocator' stream' cache' result); " is 137.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownResources2' "number of raw pool 3 bitfields"' "raw pool 3 bitfield table address"' allocator' stream' cache' result); " is 138.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownTags' "number of tag 2 bitfields"' "tag 2 bitfield table address"' allocator' stream' cache' result); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Load,The length of the statement  "			_unknownResources = LoadBitArray(values' "number of raw pool 2 bitfields"' "raw pool 2 bitfield table address"' reader); " is 120.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Load,The length of the statement  "			_unknownResources2 = LoadBitArray(values' "number of raw pool 3 bitfields"' "raw pool 3 bitfield table address"' reader); " is 121.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,RebuildInteropData,The length of the statement  "			// If the offset mask for the debug section wasn't originally zero' then we have to subtract the first partition size from the debug base address " is 145.
Long Statement,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The length of the statement  "			// If the block is being made larger' check if there's free space immediately after the block that can be used to avoid a copy " is 126.
Long Statement,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,FreeBlock,The length of the statement  "			// 3. The block being freed is immediately before another block' in which case we change the next block's start address and size " is 128.
Long Statement,Blamite.Serialization.Settings,XMLLayoutLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLLayoutLoader.cs,ProcessStructReferences,The length of the statement  "					throw new InvalidOperationException("Unable to find layout \"" + queuedStruct.LayoutName + "\" referenced by structure \"" + queuedStruct.Name + "\""); " is 151.
Long Statement,Blamite.Injection,TagContainerInjector,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,WriteDataBlock,The length of the statement  "			if (tag == null && _dataBlockAddresses.ContainsKey(block)) // Don't write anything if the block has already been written " is 120.
Long Statement,Blamite.IO,FileSegmenter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenter.cs,ResizeSegment,The length of the statement  "			// FIXME: There's a bug here where changing the size of a SegmentResizeOrigin.Beginning segment won't move the data back if ActualSize doesn't change " is 149.
Long Statement,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRange,The length of the statement  "				"Range \"{0}\" at position {1}' visible = {2} Minimium Value = {3}' Maxamium Value = {4}. Large Change = {5}' Small Change = {6}."' " is 131.
Long Statement,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,EnterReflexive,The length of the statement  "			Debug.WriteLine("Reflexive \"{0}\" at {1}' visible = {2}' entrySize = {3}' align = {4}"' name' offset' visible' entrySize' align); " is 130.
Long Statement,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitDataReference,The length of the statement  "			Debug.WriteLine("Data reference \"{0}\" at {1}' format = {2}' visible = {3}' align = {4}"' name' offset' format' visible' align); " is 129.
Long Statement,Blamite.Plugins,TestPluginVisitor,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUnicList,The length of the statement  "			Debug.WriteLine("Unicode string list \"{0}\" at {1}' visible = {2}' languages = {3}"' name' offset' visible' languages); " is 120.
Complex Conditional,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The conditional expression  "headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd'"  is complex.
Complex Conditional,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The conditional expression  "headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h'"  is complex.
Complex Conditional,Blamite.Blam,TagTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\TagTable.cs,FindTagByClass,The conditional expression  "tag != null && tag.Class != null &&  				    (tag.Class.Magic == classMagic || tag.Class.ParentMagic == classMagic ||  				     tag.Class.GrandparentMagic == classMagic)"  is complex.
Complex Conditional,Blamite.Blam,TagTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\TagTable.cs,FindTagsByClass,The conditional expression  "tag != null && tag.Class != null &&  				    (tag.Class.Magic == classMagic || tag.Class.ParentMagic == classMagic ||  				     tag.Class.GrandparentMagic == classMagic)"  is complex.
Complex Conditional,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUInt16,The conditional expression  "lowerName.Contains("asset salt")  			    || lowerName.Contains("resource salt")  			    || lowerName.Contains("asset datum salt")  			    || lowerName.Contains("resource datum salt")"  is complex.
Complex Conditional,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUInt32,The conditional expression  "lowerName.Contains("asset index")  			    || lowerName.Contains("resource index")  			    || lowerName.Contains("asset datum")  			    || lowerName.Contains("resource datum")"  is complex.
Complex Conditional,Blamite.IO,TableSystem,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,LoadTables,The conditional expression  "_stream.ReadByte() != 0xDE || _stream.ReadByte() != 0xAD ||  			    _stream.ReadByte() != 0xBE || _stream.ReadByte() != 0xEF"  is complex.
Complex Conditional,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadColorFormat,The conditional expression  "format.Any(ch => ch != 'r' && ch != 'g' && ch != 'b' && ch != 'a')"  is complex.
Complex Conditional,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadColorFormat,The conditional expression  "ch != 'r' && ch != 'g' && ch != 'b' && ch != 'a'"  is complex.
Complex Conditional,Blamite.Plugins.Generation,MetaAnalyzer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The conditional expression  "offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding)"  is complex.
Complex Conditional,Blamite.Plugins.Generation,MetaAnalyzer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The conditional expression  "paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF))"  is complex.
Magic Number,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,LoadCacheFile,The following statement contains a magic number: byte[] headerMagic = reader.ReadBlock(4);
Magic Number,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd'
Magic Number,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd'
Magic Number,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h'
Magic Number,Blamite.Blam,CacheFileLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h'
Magic Number,Blamite.Blam,LengthBasedStringIDResolver,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\LengthBasedStringIDResolver.cs,LengthBasedStringIDResolver,The following statement contains a magic number: IDLayout = new StringIDLayout(24' 0' 8);
Magic Number,Blamite.Blam,LengthBasedStringIDResolver,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\LengthBasedStringIDResolver.cs,LengthBasedStringIDResolver,The following statement contains a magic number: IDLayout = new StringIDLayout(24' 0' 8);
Magic Number,Blamite.Blam,StringID,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\StringID.cs,CreateMask,The following statement contains a magic number: return (0xFFFFFFFF >> (32 - size));
Magic Number,Blamite.Blam,IndexedStringTable,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\IndexedStringTable.cs,SaveOffsets,The following statement contains a magic number: _indexTable.Resize(_strings.Count*4' stream);
Magic Number,Blamite.Blam,DatumIndex,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\DatumIndex.cs,DatumIndex,The following statement contains a magic number: Salt = (ushort) ((value >> 16) & 0xFFFF);
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,BoundingBox,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBox.cs,BoundingBox,The following statement contains a magic number: Unknown1 = 3;
Magic Number,Blamite.Blam.Resources.Models,BoundingBox,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBox.cs,Deserialize,The following statement contains a magic number: result.Unknown1 = (int) values.GetIntegerOrDefault("unknown 1"' 3);
Magic Number,Blamite.Blam.Resources.Models,IndexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\IndexBufferReader.cs,SkipIndexBuffer,The following statement contains a magic number: reader.Skip(count*2);
Magic Number,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The following statement contains a magic number: reader.SeekTo((reader.Position + 3) & ~3);
Magic Number,Blamite.Blam.Resources.Models,ModelReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The following statement contains a magic number: reader.SeekTo((reader.Position + 3) & ~3);
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,MapC,The following statement contains a magic number: code < 123
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,BuildBuffer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Mark,The following statement contains a magic number: data.Mark(bPos - 2);
Magic Number,Blamite.Blam.Scripting.Analysis,BufferElement,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Mark,The following statement contains a magic number: limit > brkIx + 16
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: return 1201;
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: return 1200;
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: return 65001;
Magic Number,Blamite.Blam.Scripting.Analysis,CodePageHandling,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,GetCodePage,The following statement contains a magic number: command = command.Substring(9);
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[0] = new State(-2'new int[]{-1'1});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[2] = new State(-1);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[3] = new State(-3);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[3] = new State(-3);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[4] = new State(-4);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[4] = new State(-4);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[10] = new State(-6);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[10] = new State(-6);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[11] = new State(-16);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[11] = new State(-16);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[12] = new State(-19);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[12] = new State(-19);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[13] = new State(-20);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[13] = new State(-20);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[14] = new State(-21);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[14] = new State(-21);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[15] = new State(-22);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[15] = new State(-22);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[16] = new State(-17);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[16] = new State(-17);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[19] = new State(-23);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[19] = new State(-23);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[21] = new State(-24);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[21] = new State(-24);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[22] = new State(-15);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[22] = new State(-15);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[23] = new State(-18);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[23] = new State(-18);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[24] = new State(-25);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[24] = new State(-25);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[25] = new State(-14);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[25] = new State(-14);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[26] = new State(-7);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[26] = new State(-7);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[27] = new State(-8);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[27] = new State(-8);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[33] = new State(-9);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[33] = new State(-9);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[41] = new State(-10);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[41] = new State(-10);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[43] = new State(-12);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[43] = new State(-12);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[45] = new State(-13);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[45] = new State(-13);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[46] = new State(-11);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[46] = new State(-11);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[47] = new State(-5);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[47] = new State(-5);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[1] = new Rule(-13' new int[]{-1'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[1] = new Rule(-13' new int[]{-1'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[2] = new Rule(-1' new int[]{});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[3] = new Rule(-1' new int[]{-1'-3});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[3] = new Rule(-1' new int[]{-1'-3});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,Shift,The following statement contains a magic number: tokensSinceLastError > 5
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,ReportError,The following statement contains a magic number: FsaState.ParserTable.Count < 7
Magic Number,QUT.Gppg,PushdownPrefixState<T>,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,Push,The following statement contains a magic number: var newarray = new T[array.Length*2];
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GetValue,The following statement contains a magic number: return expression.Value >> (32 - (type.Size*8));
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GetValue,The following statement contains a magic number: return expression.Value >> (32 - (type.Size*8));
Magic Number,Blamite.Blam.ThirdGen,PureBLF,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\PureBLF.cs,AddBLFChunk,The following statement contains a magic number: chunk.ChunkMagic.Length != 4
Magic Number,Blamite.Blam.ThirdGen.BLF,Campaign,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\Campaign.cs,UpdateLanguageCount,The following statement contains a magic number: switch (gameIdent)  			{  				case GameIdentifier.Halo3:  					languageCount = 12;  					break;  				case GameIdentifier.Halo4:  					languageCount = 17;  					break;  				default:  					throw new InvalidOperationException("The Campaign BLF file is from an unknown Halo Version");  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,Campaign,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\Campaign.cs,UpdateLanguageCount,The following statement contains a magic number: switch (gameIdent)  			{  				case GameIdentifier.Halo3:  					languageCount = 12;  					break;  				case GameIdentifier.Halo4:  					languageCount = 17;  					break;  				default:  					throw new InvalidOperationException("The Campaign BLF file is from an unknown Halo Version");  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: var ints = new int[64];
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: _stream.SeekTo(baseOffset + (i * 4));
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: i < 64
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following statement contains a magic number: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following statement contains a magic number: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateMPObjectTable,The following statement contains a magic number: var buffer = new int[64];
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateMPObjectTable,The following statement contains a magic number: i < 64
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following statement contains a magic number: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following statement contains a magic number: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}
Magic Number,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,Load,The following statement contains a magic number: LocaleIndexTable = segmenter.WrapSegment(localeIndexTableOffset' StringCount*8' 8' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,Load,The following statement contains a magic number: LocaleIndexTable = segmenter.WrapSegment(localeIndexTableOffset' StringCount*8' 8' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.ThirdGen.Resources.Sounds,ThirdGenSoundPlayback,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Sounds\ThirdGenSoundPlayback.cs,Load,The following statement contains a magic number: EncodedPermutationCount = ((int)values.GetInteger("encoded permutation count") >> 4) & 63;
Magic Number,Blamite.Blam.ThirdGen.Resources.Sounds,ThirdGenSoundPlayback,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Sounds\ThirdGenSoundPlayback.cs,Load,The following statement contains a magic number: EncodedPermutationCount = ((int)values.GetInteger("encoded permutation count") >> 4) & 63;
Magic Number,Blamite.Blam.ThirdGen.Shaders,ThirdGenShaderStreamer,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Shaders\ThirdGenShaderStreamer.cs,ReadShaderInfo,The following statement contains a magic number: debugValues.GetIntegerOrDefault("magic"' 0) >> 16 != 0x102A
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,AlignInfoBlockOffset,The following statement contains a magic number: (resource.Flags & 4) != 0
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: newAddress = allocator.Allocate(ints.Length*4' stream);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,FreeBitArray,The following statement contains a magic number: allocator.Free(oldAddress' oldCount*4);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment(sidIndexTableOff' StringIDCount*4' 4' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment(sidIndexTableOff' StringIDCount*4' 4' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment(nameIndexTableOff' FileNameCount*4' 4' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment(nameIndexTableOff' FileNameCount*4' 4' SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Allocate,The following statement contains a magic number: return Allocate(size' 4' stream);
Magic Number,Blamite.Blam.Util,MetaAllocator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The following statement contains a magic number: return Reallocate(address' oldSize' newSize' 4' stream);
Magic Number,Blamite.Blam.Util,AESKey,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\AESKey.cs,AESKey,The following statement contains a magic number: _key = new byte[16];
Magic Number,Blamite.Blam.Util,AESKey,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\AESKey.cs,AESKey,The following statement contains a magic number: _iv = new byte[16];
Magic Number,Blamite.Serialization.MapInfo,EngineDatabase,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\MapInfo\EngineDatabase.cs,RegisterEngine,The following statement contains a magic number: _engines[((uint)engine.LevlSize << 32) | (uint)engine.Version] = engine;
Magic Number,Blamite.Serialization.MapInfo,EngineDatabase,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\MapInfo\EngineDatabase.cs,FindEngine,The following statement contains a magic number: _engines.TryGetValue(((uint)size << 32) | (uint)version' out result);
Magic Number,Blamite.Serialization.Settings,SettingsGroup,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\SettingsGroup.cs,ParseLong,The following statement contains a magic number: return -long.Parse(str.Substring(3)' NumberStyles.HexNumber);
Magic Number,Blamite.Serialization.Settings,SettingsGroup,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\SettingsGroup.cs,ParseLong,The following statement contains a magic number: return long.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Serialization.Settings,XMLStringIDSetLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLStringIDSetLoader.cs,ProcessIDLayoutInfo,The following statement contains a magic number: int indexBits = XMLUtil.GetNumericAttribute(element' "indexBits"' 16);
Magic Number,Blamite.Serialization.Settings,XMLStringIDSetLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLStringIDSetLoader.cs,ProcessIDLayoutInfo,The following statement contains a magic number: int setBits = XMLUtil.GetNumericAttribute(element' "setBits"' 8);
Magic Number,Blamite.Serialization,LocaleSymbolCollection,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\LocaleSymbolCollection.cs,ReplaceTags,The following statement contains a magic number: locale = locale.Substring(0' tagStartPos) + replacement + locale.Substring(tagEndPos + 2);
Magic Number,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,EnterPlugin,The following statement contains a magic number: var block = new DataBlock(_tag.MetaLocation.AsPointer()' 1' 4' data);
Magic Number,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUnicList,The following statement contains a magic number: var fixup = new DataBlockUnicListFixup(i' (int)(offset + i * 4)' fixupStrings);
Magic Number,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,ReadShader,The following statement contains a magic number: _reader.Skip(-4);
Magic Number,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,GlobalShaderFixup,The following statement contains a magic number: i < 4
Magic Number,Blamite.Injection,DataBlockBuilder,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,GlobalShaderFixup,The following statement contains a magic number: var fixup = new DataBlockShaderFixup((int)offset + 4' data);
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: version > 6
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: int align = (version >= 3) ? reader.ReadInt32() : 4;
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: int align = (version >= 3) ? reader.ReadInt32() : 4;
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: version >= 2
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: version >= 4
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: version >= 6
Magic Number,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: version >= 5
Magic Number,Blamite.Injection,TagContainerWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerWriter.cs,WriteDataBlocks,The following statement contains a magic number: container.StartBlock("data"' 6);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: _stream.Read(_buffer' 0' 2);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort) ((_buffer[0] << 8) | _buffer[1]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort) ((_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: _stream.Read(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt64,The following statement contains a magic number: return (one << 32) | two;
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt64,The following statement contains a magic number: return (two << 32) | one;
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _stream.Read(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _buffer[0] = _buffer[3];
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _buffer[3] = temp;
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _buffer[1] = _buffer[2];
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _buffer[2] = temp;
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUTF16,The following statement contains a magic number: _currentString.Length*2 < size
Magic Number,Blamite.IO,EndianReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUTF16,The following statement contains a magic number: Skip(size - _currentString.Length*2);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt16,The following statement contains a magic number: _buffer[0] = (byte) (value >> 8);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt16,The following statement contains a magic number: _stream.Write(_buffer' 0' 2);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _buffer[0] = (byte) (value >> 24);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _buffer[1] = (byte) ((value >> 16) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _buffer[2] = (byte) ((value >> 8) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _buffer[2] = (byte) ((value >> 8) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _buffer[3] = (byte) (value & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _stream.Write(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[0] = (byte) (value >> 56);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[1] = (byte) ((value >> 48) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[2] = (byte) ((value >> 40) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[2] = (byte) ((value >> 40) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[3] = (byte) ((value >> 32) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[3] = (byte) ((value >> 32) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[4] = (byte) ((value >> 24) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[4] = (byte) ((value >> 24) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[5] = (byte) ((value >> 16) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[5] = (byte) ((value >> 16) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[6] = (byte) ((value >> 8) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[6] = (byte) ((value >> 8) & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _buffer[7] = (byte) (value & 0xFF);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _stream.Write(_buffer' 0' 8);
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: bytes[0] = bytes[3];
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: bytes[3] = temp;
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: bytes[1] = bytes[2];
Magic Number,Blamite.IO,EndianWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: bytes[2] = temp;
Magic Number,Blamite.IO,ContainerWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,StartBlock,The following statement contains a magic number: id.Length > 4
Magic Number,Blamite.IO,ContainerWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,StartBlock,The following statement contains a magic number: id = id.PadRight(4);
Magic Number,Blamite.IO,ContainerWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,EndBlock,The following statement contains a magic number: var blockSize = (int) (currentPos - blockSizePos + 4);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment((int) values.GetInteger("string index table offset")' StringIDCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment((int) values.GetInteger("string index table offset")' StringIDCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment((int) values.GetInteger("file index table offset")' FileNameCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment((int) values.GetInteger("file index table offset")' FileNameCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Patching,AssemblyPatchLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadPatchInfo,The following statement contains a magic number: version >= 2
Magic Number,Blamite.Patching,AssemblyPatchLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadDataChanges,The following statement contains a magic number: byte[] data = reader.ReadBlock(4);
Magic Number,Blamite.Patching,AssemblyPatchWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WritePatchInfo,The following statement contains a magic number: container.StartBlock("titl"' 2);
Magic Number,Blamite.Patching,AssemblyPatchWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteDataChanges,The following statement contains a magic number: List<DataChange> fourByteChanges = changes.Where(c => c.Data.Length == 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteDataChanges,The following statement contains a magic number: List<DataChange> otherChanges = changes.Where(c => c.Data.Length != 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteMetaChanges,The following statement contains a magic number: List<DataChange> fourByteChanges = patch.MetaChanges.Where(c => c.Data.Length == 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteMetaChanges,The following statement contains a magic number: List<DataChange> otherChanges = patch.MetaChanges.Where(c => c.Data.Length != 4).ToList();
Magic Number,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitVector3,The following statement contains a magic number: WriteBasicValue("float"' name + " Y"' offset + 4' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitVector3,The following statement contains a magic number: WriteBasicValue("float"' name + " Z"' offset + 8' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: WriteBasicValue("uint16"' "Language " + i + " " + name + " Index"' (uint)(offset + i * 4)' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: WriteBasicValue("uint16"' "Language " + i + " " + name + " Count"' (uint)(offset + i * 4 + 2)' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: WriteBasicValue("uint16"' "Language " + i + " " + name + " Count"' (uint)(offset + i * 4 + 2)' visible);
Magic Number,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadDataRef,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadReflexive,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseInt,The following statement contains a magic number: return int.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseInt,The following statement contains a magic number: return -int.Parse(str.Substring(3)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,AssemblyPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseUInt,The following statement contains a magic number: return str.StartsWith("0x") ? uint.Parse(str.Substring(2)' NumberStyles.HexNumber) : uint.Parse(str);
Magic Number,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitDataReference,The following statement contains a magic number: align != 4
Magic Number,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The following statement contains a magic number: switch (format.Length)  			{  				case 1:  					element = "color8";  					break;  				case 2:  					element = "color16";  					break;  				case 3:  					element = "color24";  					break;  				default:  					element = "color32";  					break;  			}
Magic Number,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The following statement contains a magic number: switch (format.Length)  			{  				case 1:  					element = "color8";  					break;  				case 2:  					element = "color16";  					break;  				case 3:  					element = "color24";  					break;  				default:  					element = "color32";  					break;  			}
Magic Number,Blamite.Plugins,AssemblyPluginWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,EnterReflexive,The following statement contains a magic number: align != 4
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadDataRef,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadRevision,The following statement contains a magic number: version += (suffix - 'a' + 1)*0.001f;
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadReflexive,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ParseInt,The following statement contains a magic number: return int.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,UniversalPluginLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ParseUInt,The following statement contains a magic number: return uint.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.RTE.H2Vista,H2VistaMapPointerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,ReadMapPointers,The following statement contains a magic number: reader.SeekTo(_mapHeaderAddress - 4);
Magic Number,Blamite.Util,CharConstant,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: int index = 4;
Magic Number,Blamite.Util,CharConstant,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: var chars = new char[4];
Magic Number,Blamite.Util,CharConstant,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: constant >>= 8;
Magic Number,Blamite.Util,CharConstant,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: index == 4
Magic Number,Blamite.Util,CharConstant,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,FromString,The following statement contains a magic number: result <<= 8;
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexString,The following statement contains a magic number: var builder = new StringBuilder(array.Length*2);
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexString,The following statement contains a magic number: builder.Append(chars[b >> 4]);
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexLines,The following statement contains a magic number: var builder = new StringBuilder(array.Length*2);
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexLines,The following statement contains a magic number: builder.Append(chars[array[i] >> 4]);
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: hex.Length%2 != 0
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: var result = new byte[hex.Length/2];
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: result[i/2] |= (byte) (value << (4*(1 - i%2)));
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: result[i/2] |= (byte) (value << (4*(1 - i%2)));
Magic Number,Blamite.Util,FunctionHelpers,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: result[i/2] |= (byte) (value << (4*(1 - i%2)));
Magic Number,Blamite.Util,ListSearching,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\ListSearching.cs,BinarySearch,The following statement contains a magic number: int middle = (lower + upper)/2;
Magic Number,Blamite.Util,XMLUtil,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\XMLUtil.cs,ParseNumber,The following statement contains a magic number: return int.TryParse(numberStr.Substring(2)' NumberStyles.HexNumber' null' out result);
Magic Number,System,Half,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\Half.cs,GetTypeCode,The following statement contains a magic number: return (TypeCode) 255;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,ConvertMantissa,The following statement contains a magic number: var m = (uint) (i << 13);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: var mantissaTable = new uint[2048];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: i < 1024
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: i < 2048
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: var exponentTable = new uint[64];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint) (i << 23);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: i < 31
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[31] = 0x47800000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[32] = 0x80000000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: i < 63
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[63] = 0xc7800000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: var offsetTable = new ushort[64];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[i] = 1024;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: i < 32
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[32] = 0;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[i] = 1024;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: i < 64
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: var baseTable = new ushort[512];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: var e = (sbyte) (127 - i);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: e > 24
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: i < 256
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: var shiftTable = new sbyte[512];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: var e = (sbyte) (127 - i);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: shiftTable[i | 0x000] = 24;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: shiftTable[i | 0x100] = 24;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: e > 24
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: i < 256
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,SingleToHalf,The following statement contains a magic number: var result = (ushort) (baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,SingleToHalf,The following statement contains a magic number: var result = (ushort) (baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Missing Default,Blamite.Blam.Resources.Models,BoundingBoxCalculator,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBoxCalculator.cs,ProcessVertex,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					CalculatedBox.MinX = Math.Min(CalculatedBox.MinX' x);  					CalculatedBox.MinY = Math.Min(CalculatedBox.MinY' y);  					CalculatedBox.MinZ = Math.Min(CalculatedBox.MinZ' z);  					CalculatedBox.MaxX = Math.Max(CalculatedBox.MaxX' x);  					CalculatedBox.MaxY = Math.Max(CalculatedBox.MaxY' y);  					CalculatedBox.MaxZ = Math.Max(CalculatedBox.MaxZ' z);  					break;    				case VertexElementUsage.TexCoords:  					CalculatedBox.MinU = Math.Min(CalculatedBox.MinU' x);  					CalculatedBox.MinV = Math.Min(CalculatedBox.MinV' y);  					CalculatedBox.MaxU = Math.Max(CalculatedBox.MaxU' x);  					CalculatedBox.MaxV = Math.Max(CalculatedBox.MaxV' y);  					break;  			}
Missing Default,Blamite.Blam.Resources.Models,VertexBufferWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,TransformElement,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					x = (x - _bbox.MinX)/(_bbox.MaxX - _bbox.MinX);  					y = (y - _bbox.MinY)/(_bbox.MaxY - _bbox.MinY);  					z = (z - _bbox.MinZ)/(_bbox.MaxZ - _bbox.MinZ);  					break;    				case VertexElementUsage.TexCoords:  					x = (x - _bbox.MinU)/(_bbox.MaxU - _bbox.MinU);  					y = (y - _bbox.MinV)/(_bbox.MaxV - _bbox.MinV);  					break;  			}
Missing Default,Blamite.Blam.Resources.Models,VertexBufferReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,TransformElement,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					x = x*(boundingBox.MaxX - boundingBox.MinX) + boundingBox.MinX;  					y = y*(boundingBox.MaxY - boundingBox.MinY) + boundingBox.MinY;  					z = z*(boundingBox.MaxZ - boundingBox.MinZ) + boundingBox.MinZ;  					break;    				case VertexElementUsage.TexCoords:  					x = x*(boundingBox.MaxU - boundingBox.MinU) + boundingBox.MinU;  					y = y*(boundingBox.MaxV - boundingBox.MinV) + boundingBox.MinV;  					break;  			}
Missing Default,Blamite.Blam.Scripting.Analysis,Guesser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following switch statement is missing a default case: switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }
Missing Default,Blamite.Blam.Scripting.Analysis,LispScriptParser,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following switch statement is missing a default case: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Missing Default,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following switch statement is missing a default case: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}
Missing Default,Blamite.Blam.ThirdGen.BLF,MapInfo,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following switch statement is missing a default case: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}
Missing Default,Blamite.Serialization,StructureReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following switch statement is missing a default case: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Missing Default,Blamite.Serialization,StructureWriter,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following switch statement is missing a default case: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Missing Default,Blamite.Injection,TagContainerReader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadBlocks,The following switch statement is missing a default case: switch (containerFile.BlockName)  				{  					case "data":  						// Data block  						tags.AddDataBlock(ReadDataBlock(reader' containerFile.BlockVersion));  						break;    					case "tag!":  						// Extracted tag  						tags.AddTag(ReadTag(reader' containerFile.BlockVersion));  						break;    					case "ersp":  						// Extracted Raw Resource Page  						tags.AddExtractedResourcePage(ReadExtractedResourcePage(reader' containerFile.BlockVersion));  						break;    					case "rspg":  						// Resource page  						tags.AddResourcePage(ReadResourcePage(reader' containerFile.BlockVersion));  						break;    					case "rsrc":  						// Resource info  						tags.AddResource(ReadResource(reader' containerFile.BlockVersion));  						break;  				}
Missing Default,Blamite.Patching,AssemblyPatchLoader,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadBlocks,The following switch statement is missing a default case: switch (container.BlockName)  				{  					case "titl":  						ReadPatchInfo(reader' container.BlockVersion' result);  						break;    					case "segm":  						ReadSegmentChanges(reader' result);  						break;    					case "blfc":  						ReadBlfInfo(reader' result);  						break;    						#region Deprecated    					case "meta":  						ReadMetaChanges(reader' result);  						break;    					case "locl":  						ReadLocaleChanges(reader' result);  						break;    						#endregion Deprecated  				}
Missing Default,Blamite.Native,ProcessMemoryStream,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,Seek,The following switch statement is missing a default case: switch (origin)  			{  				case SeekOrigin.Begin:  					Position = offset;  					break;    				case SeekOrigin.Current:  					Position += offset;  					break;    				case SeekOrigin.End:  					Position = uint.MaxValue - offset;  					break;  			}
Missing Default,Blamite.Util,TypeUtil,D:\research\architectureSmells\repos\XboxChaos_Assembly\src\Blamite\Util\TypeUtil.cs,IsInteger,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.Byte:  				case TypeCode.Int16:  				case TypeCode.Int32:  				case TypeCode.Int64:  				case TypeCode.SByte:  				case TypeCode.UInt16:  				case TypeCode.UInt32:  				case TypeCode.UInt64:  					return true;  			}
