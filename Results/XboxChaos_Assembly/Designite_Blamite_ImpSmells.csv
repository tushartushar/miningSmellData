Implementation smell,Namespace,Class,File,Method,Description
Long Method,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The method has 138 lines of code.
Long Method,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The method has 102 lines of code.
Long Method,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,HandleValueElement,The method has 135 lines of code.
Long Method,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The method has 155 lines of code.
Complex Method,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,Cyclomatic complexity of the method is 8
Complex Method,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,DiscardInvalidTokens,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateCode,Cyclomatic complexity of the method is 15
Complex Method,Blamite.Blam.ThirdGen.Shaders,ThirdGenShaderStreamer,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Shaders\ThirdGenShaderStreamer.cs,ReadShaderInfo,Cyclomatic complexity of the method is 12
Complex Method,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,Serialize,Cyclomatic complexity of the method is 10
Complex Method,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,FreeBlock,Cyclomatic complexity of the method is 15
Complex Method,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,Cyclomatic complexity of the method is 13
Complex Method,Blamite.Injection,TagContainerWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerWriter.cs,WriteDataBlocks,Cyclomatic complexity of the method is 10
Complex Method,Blamite.Injection,TagContainerInjector,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,InjectTag,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Injection,TagContainerInjector,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,InjectResource,Cyclomatic complexity of the method is 9
Complex Method,Blamite.Patching,DataComparer,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\DataComparer.cs,CompareData,Cyclomatic complexity of the method is 10
Long Parameter List,Blamite.Blam,IndexedStringTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\IndexedStringTable.cs,IndexedStringTable,The method has 5 parameters. Parameters: reader' count' indexTable' data' key
Long Parameter List,Blamite.Blam.Resources.Sounds,SoundReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Sounds\SoundReader.cs,ReadSoundData,The method has 6 parameters. Parameters: reader' sound' cacheFile' resourcePages' resourceCacheFolder' buildInfo
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The method has 5 parameters. Parameters: x' y' z' w' layout
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,TransformElement,The method has 5 parameters. Parameters: x' y' z' w' usage
Long Parameter List,Blamite.Blam.Resources.Models,IVertexProcessor,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\IVertexProcessor.cs,ProcessVertexElement,The method has 5 parameters. Parameters: x' y' z' w' layout
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadModelData,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadVertexBuffers,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionVertices,The method has 5 parameters. Parameters: reader' section' boundingBox' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadIndexBuffers,The method has 5 parameters. Parameters: reader' model' sectionsToRead' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The method has 5 parameters. Parameters: reader' section' baseIndex' buildInfo' processor
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadVertices,The method has 5 parameters. Parameters: reader' layout' count' boundingBox' processor
Long Parameter List,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,TransformElement,The method has 6 parameters. Parameters: x' y' z' w' usage' boundingBox
Long Parameter List,Blamite.Blam.Scripting.Compiler,ScriptObjectReflexive,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Compiler\ScriptObjectReflexive.cs,ReadObjects,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting.Compiler,ScriptObjectReflexive,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Compiler\ScriptObjectReflexive.cs,ReadScriptObject,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,ScriptFunctionInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\ScriptFunctionInfo.cs,ScriptFunctionInfo,The method has 5 parameters. Parameters: name' opcode' returnType' flags' parameterTypes
Long Parameter List,Blamite.Blam.Scripting,Script,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Script.cs,Script,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,Script,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Script.cs,Load,The method has 5 parameters. Parameters: values' reader' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.Scripting,ScriptValueType,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\ScriptValueType.cs,ScriptValueType,The method has 5 parameters. Parameters: name' opcode' size' quoted' tag
Long Parameter List,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,ThirdGenLanguage,The method has 5 parameters. Parameters: language' values' segmenter' localeArea' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Resources,ThirdGenResourceManager,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\ThirdGenResourceManager.cs,ThirdGenResourceManager,The method has 6 parameters. Parameters: gestalt' layoutTable' tags' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,ThirdGenSimulationDefinitionTable,The method has 6 parameters. Parameters: scenario' tags' reader' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,ThirdGenZoneSetTable,The method has 5 parameters. Parameters: gestalt' reader' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveZoneSetTable,The method has 6 parameters. Parameters: set' tagValues' countName' addressName' cache' stream
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveZoneSetTable,The method has 6 parameters. Parameters: sets' tagValues' countName' addressName' cache' stream
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,ThirdGenResourceGestalt,The method has 6 parameters. Parameters: reader' zoneTag' metaArea' allocator' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,LoadResource,The method has 6 parameters. Parameters: values' index' tags' pointers' infoBuffer' reader
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenScenarioScriptFile,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenScenarioScriptFile.cs,ThirdGenScenarioScriptFile,The method has 5 parameters. Parameters: scenarioTag' scenarioName' metaArea' stringIDs' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The method has 7 parameters. Parameters: bits' countName' addressName' allocator' stream' cache' values
Long Parameter List,Blamite.Blam.ThirdGen.Structures,ThirdGenTagTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenTagTable.cs,ThirdGenTagTable,The method has 5 parameters. Parameters: reader' indexHeaderLocation' metaArea' allocator' buildInfo
Long Parameter List,Blamite.Blam.ThirdGen.Resources.Models,ThirdGenModelSection,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Models\ThirdGenModelSection.cs,LoadVertexGroups,The method has 5 parameters. Parameters: values' reader' metaArea' buildInfo' submeshes
Long Parameter List,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The method has 5 parameters. Parameters: address' oldSize' newSize' align' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveReader.cs,ReadReflexive,The method has 5 parameters. Parameters: reader' count' address' entryLayout' metaArea
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 5 parameters. Parameters: entries' address' layout' metaArea' writer
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 5 parameters. Parameters: entries' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 7 parameters. Parameters: entries' oldCount' oldAddress' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Blam.Util,ReflexiveWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\ReflexiveWriter.cs,WriteReflexive,The method has 8 parameters. Parameters: entries' oldCount' oldAddress' newCount' layout' metaArea' allocator' stream
Long Parameter List,Blamite.Serialization,StringIDLayout,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StringIDLayout.cs,StringIDLayout,The method has 6 parameters. Parameters: indexStart' indexSize' setStart' setSize' lengthStart' lengthSize
Long Parameter List,Blamite.Serialization,VertexElementLayout,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\VertexElementLayout.cs,VertexElementLayout,The method has 5 parameters. Parameters: stream' offset' type' usage' usageIndex
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.IO,FileSegmenter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenter.cs,DefineSegment,The method has 5 parameters. Parameters: offset' size' offsetAlignment' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,FileSegmenterExtensions,C:\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenterExtensions.cs,WrapSegment,The method has 5 parameters. Parameters: segmenter' offset' size' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,FileSegmenterExtensions,C:\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenterExtensions.cs,WrapSegment,The method has 6 parameters. Parameters: segmenter' offset' size' offsetAlignment' sizeAlignment' resizeOrigin
Long Parameter List,Blamite.IO,TableSystem,C:\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,CreateTable,The method has 5 parameters. Parameters: name' entrylength' count' maxcount' entries
Long Parameter List,Blamite.IO,TableSystem,C:\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,CreateTable,The method has 5 parameters. Parameters: name' entrylength' count' maxcount' entry
Long Parameter List,Blamite.IO,StreamUtil,C:\repos\XboxChaos_Assembly\src\Blamite\IO\StreamUtil.cs,MakeFreeSpace,The method has 5 parameters. Parameters: stream' startOffset' originalEndOffset' requestedSize' pageSize
Long Parameter List,Blamite.Blam.SecondGen.Structures,SecondGenTagTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenTagTable.cs,ReadTags,The method has 5 parameters. Parameters: reader' tagTableOffset' numTags' buildInfo' metaArea
Long Parameter List,Blamite.Patching,DataComparer,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\DataComparer.cs,CompareData,The method has 7 parameters. Parameters: originalReader' originalOffset' originalSize' newReader' newOffset' newSize' extraDataAtEnd
Long Parameter List,Blamite.Patching,PatchBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\PatchBuilder.cs,BuildPatch,The method has 5 parameters. Parameters: originalFile' originalReader' newFile' newReader' output
Long Parameter List,Blamite.Patching,SegmentChange,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\SegmentChange.cs,SegmentChange,The method has 5 parameters. Parameters: oldOffset' oldActualSize' newOffset' newActualSize' resizeAtEnd
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' length' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' length' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadDataRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadRange,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadTagRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadAscii,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadUtf16,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadReflexive,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadRaw,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadShader,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadUnicList,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' min' max' smallChange' largeChange' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,IPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\IPluginVisitor.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRange,The method has 9 parameters. Parameters: name' offset' visible' type' minval' maxval' smallchange' largechange' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitTagReference,The method has 6 parameters. Parameters: name' offset' visible' withClass' showJumpTo' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,EnterReflexive,The method has 6 parameters. Parameters: name' offset' visible' entrySize' align' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitDataReference,The method has 6 parameters. Parameters: name' offset' format' visible' align' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitAscii,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUtf16,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitColorInt,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitColorF,The method has 5 parameters. Parameters: name' offset' visible' format' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRawData,The method has 5 parameters. Parameters: name' offset' visible' size' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitShader,The method has 5 parameters. Parameters: name' offset' visible' type' pluginLine
Long Parameter List,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUnicList,The method has 5 parameters. Parameters: name' offset' visible' languages' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadDataRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadTagRef,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadAscii,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadUtf16,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadRaw,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadShader,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadUnicList,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadReflexive,The method has 6 parameters. Parameters: reader' name' offset' visible' visitor' pluginLine
Long Parameter List,Blamite.Native,ProcessMemoryStream,C:\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,ReadProcessMemory,The method has 5 parameters. Parameters: hProcess' lpBaseAddress' lpBuffer' nSize' lpNumberOfBytesRead
Long Parameter List,Blamite.Native,ProcessMemoryStream,C:\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,WriteProcessMemory,The method has 5 parameters. Parameters: hProcess' lpBaseAddress' lpBuffer' nSize' lpNumberOfBytesWritten
Long Parameter List,Blamite.Util,AES,C:\repos\XboxChaos_Assembly\src\Blamite\Util\AES.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' length' key' iv
Long Parameter List,Blamite.Util,AES,C:\repos\XboxChaos_Assembly\src\Blamite\Util\AES.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' length' key' iv
Long Identifier,Blamite.Injection,TagContainer,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainer.cs,,The length of the parameter _extractedResourcePageByPageIndex is 33.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,C:\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter NoPatchMapHeaderRelativeAddress is 31.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,C:\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter Patch1MapHeaderRelativeAddress is 30.
Long Identifier,Blamite.RTE.H2Vista,H2VistaMapPointerReader,C:\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,,The length of the parameter Patch2MapHeaderRelativeAddress is 30.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); } " is 182.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "                   var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue); " is 167.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "                   var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue); " is 168.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); } " is 149.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); } " is 156.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); } " is 151.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); } " is 132.
Long Statement,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The length of the statement  "{ CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); } " is 148.
Long Statement,Blamite.Blam.ThirdGen,ThirdGenCacheFile,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\ThirdGenCacheFile.cs,LoadSimulationDefinitions,The length of the statement  "			if (_tags != null && _buildInfo.Layouts.HasLayout("scnr") && _buildInfo.Layouts.HasLayout("simulation definition table entry")) " is 127.
Long Statement,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMapInfo,The length of the statement  "				throw new NotSupportedException("Engine version " + version + " of size 0x" + size.ToString("X") + " is not supported"); " is 120.
Long Statement,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguagePackLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguagePackLoader.cs,SaveLanguage,The length of the statement  "			var strings = pack.StringLists.SelectMany(l => _sortByStringId ? l.Strings.OrderBy(s => s.Key.Value).ToList() : l.Strings).ToList(); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,SaveChanges,The length of the statement  "			var newAddr = ReflexiveWriter.WriteReflexive(newTable' oldCount' oldAddress' _table.Count' entryLayout' _metaArea' _allocator' stream); " is 135.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenSimulationDefinitionTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenSimulationDefinitionTable.cs,Load,The length of the statement  "			_table = ReflexiveReader.ReadReflexive(reader' count' address' entryLayout' _metaArea).Select((e) => _tags[new DatumIndex(e.GetInteger("datum index"))]).ToList(); " is 162.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(GlobalZoneSet' tagValues' "number of global zone sets"' "global zone set table address"' cache' stream); " is 121.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(UnattachedZoneSet' tagValues' "number of unattached zone sets"' "unattached zone set table address"' cache' stream); " is 133.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(DiscForbiddenZoneSet' tagValues' "number of disc forbidden zone sets"' "disc forbidden zone set table address"' cache' stream); " is 144.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(DiscAlwaysStreamingZoneSet' tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' cache' stream); " is 164.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(GeneralZoneSets' tagValues' "number of general zone sets"' "general zone set table address"' cache' stream); " is 125.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(CinematicZoneSets' tagValues' "number of cinematic zone sets"' "cinematic zone set table address"' cache' stream); " is 131.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,SaveChanges,The length of the statement  "			SaveZoneSetTable(CustomZoneSets' tagValues' "number of custom zone sets"' "custom zone set table address"' cache' stream); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			GlobalZoneSet = ReadZoneSetTable(tagValues' "number of global zone sets"' "global zone set table address"' reader).FirstOrDefault(); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			UnattachedZoneSet = ReadZoneSetTable(tagValues' "number of unattached zone sets"' "unattached zone set table address"' reader).FirstOrDefault(); " is 144.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			DiscForbiddenZoneSet = ReadZoneSetTable(tagValues' "number of disc forbidden zone sets"' "disc forbidden zone set table address"' reader).FirstOrDefault(); " is 155.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			DiscAlwaysStreamingZoneSet = ReadZoneSetTable(tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' reader).FirstOrDefault(); " is 175.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			GeneralZoneSets = ReadZoneSetTable(tagValues' "number of general zone sets"' "general zone set table address"' reader).ToArray(); " is 129.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			BSPZoneSets2 = ReadZoneSetTable(tagValues' "number of bsp 2 zone sets"' "bsp 2 zone set table address"' reader).ToArray(); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			BSPZoneSets3 = ReadZoneSetTable(tagValues' "number of bsp 3 zone sets"' "bsp 3 zone set table address"' reader).ToArray(); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			CinematicZoneSets = ReadZoneSetTable(tagValues' "number of cinematic zone sets"' "cinematic zone set table address"' reader).ToArray(); " is 135.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,Load,The length of the statement  "			CustomZoneSets = ReadZoneSetTable(tagValues' "number of custom zone sets"' "custom zone set table address"' reader).ToArray(); " is 126.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSetTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSetTable.cs,FreeZoneSets,The length of the statement  "			FreeZoneSetsInTable(tagValues' "number of disc always streaming zone sets"' "disc always streaming zone set table address"' reader); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_activeResources' "number of raw pool bitfields"' "raw pool bitfield table address"' allocator' stream' cache' result); " is 132.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownResources' "number of raw pool 2 bitfields"' "raw pool 2 bitfield table address"' allocator' stream' cache' result); " is 137.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownResources2' "number of raw pool 3 bitfields"' "raw pool 3 bitfield table address"' allocator' stream' cache' result); " is 138.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Serialize,The length of the statement  "			SaveBitArray(_unknownTags' "number of tag 2 bitfields"' "tag 2 bitfield table address"' allocator' stream' cache' result); " is 122.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Load,The length of the statement  "			_unknownResources = LoadBitArray(values' "number of raw pool 2 bitfields"' "raw pool 2 bitfield table address"' reader); " is 120.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,Load,The length of the statement  "			_unknownResources2 = LoadBitArray(values' "number of raw pool 3 bitfields"' "raw pool 3 bitfield table address"' reader); " is 121.
Long Statement,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,RebuildInteropData,The length of the statement  "			// If the offset mask for the debug section wasn't originally zero' then we have to subtract the first partition size from the debug base address " is 145.
Long Statement,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The length of the statement  "			// If the block is being made larger' check if there's free space immediately after the block that can be used to avoid a copy " is 126.
Long Statement,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,FreeBlock,The length of the statement  "			// 3. The block being freed is immediately before another block' in which case we change the next block's start address and size " is 128.
Long Statement,Blamite.Serialization.Settings,XMLLayoutLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLLayoutLoader.cs,ProcessStructReferences,The length of the statement  "					throw new InvalidOperationException("Unable to find layout \"" + queuedStruct.LayoutName + "\" referenced by structure \"" + queuedStruct.Name + "\""); " is 151.
Long Statement,Blamite.Injection,TagContainerInjector,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerInjector.cs,WriteDataBlock,The length of the statement  "			if (tag == null && _dataBlockAddresses.ContainsKey(block)) // Don't write anything if the block has already been written " is 120.
Long Statement,Blamite.IO,FileSegmenter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\FileSegmenter.cs,ResizeSegment,The length of the statement  "			// FIXME: There's a bug here where changing the size of a SegmentResizeOrigin.Beginning segment won't move the data back if ActualSize doesn't change " is 149.
Long Statement,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitRange,The length of the statement  "				"Range \"{0}\" at position {1}' visible = {2} Minimium Value = {3}' Maxamium Value = {4}. Large Change = {5}' Small Change = {6}."' " is 131.
Long Statement,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,EnterReflexive,The length of the statement  "			Debug.WriteLine("Reflexive \"{0}\" at {1}' visible = {2}' entrySize = {3}' align = {4}"' name' offset' visible' entrySize' align); " is 130.
Long Statement,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitDataReference,The length of the statement  "			Debug.WriteLine("Data reference \"{0}\" at {1}' format = {2}' visible = {3}' align = {4}"' name' offset' format' visible' align); " is 129.
Long Statement,Blamite.Plugins,TestPluginVisitor,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\TestPluginVisitor.cs,VisitUnicList,The length of the statement  "			Debug.WriteLine("Unicode string list \"{0}\" at {1}' visible = {2}' languages = {3}"' name' offset' visible' languages); " is 120.
Complex Conditional,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The conditional expression  "headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd'"  is complex.
Complex Conditional,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The conditional expression  "headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h'"  is complex.
Complex Conditional,Blamite.Blam,TagTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\TagTable.cs,FindTagByClass,The conditional expression  "tag != null && tag.Class != null &&  				    (tag.Class.Magic == classMagic || tag.Class.ParentMagic == classMagic ||  				     tag.Class.GrandparentMagic == classMagic)"  is complex.
Complex Conditional,Blamite.Blam,TagTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\TagTable.cs,FindTagsByClass,The conditional expression  "tag != null && tag.Class != null &&  				    (tag.Class.Magic == classMagic || tag.Class.ParentMagic == classMagic ||  				     tag.Class.GrandparentMagic == classMagic)"  is complex.
Complex Conditional,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUInt16,The conditional expression  "lowerName.Contains("asset salt")  			    || lowerName.Contains("resource salt")  			    || lowerName.Contains("asset datum salt")  			    || lowerName.Contains("resource datum salt")"  is complex.
Complex Conditional,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUInt32,The conditional expression  "lowerName.Contains("asset index")  			    || lowerName.Contains("resource index")  			    || lowerName.Contains("asset datum")  			    || lowerName.Contains("resource datum")"  is complex.
Complex Conditional,Blamite.IO,TableSystem,C:\repos\XboxChaos_Assembly\src\Blamite\IO\TableSystem.cs,LoadTables,The conditional expression  "_stream.ReadByte() != 0xDE || _stream.ReadByte() != 0xAD ||  			    _stream.ReadByte() != 0xBE || _stream.ReadByte() != 0xEF"  is complex.
Complex Conditional,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadColorFormat,The conditional expression  "format.Any(ch => ch != 'r' && ch != 'g' && ch != 'b' && ch != 'a')"  is complex.
Complex Conditional,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadColorFormat,The conditional expression  "ch != 'r' && ch != 'g' && ch != 'b' && ch != 'a'"  is complex.
Complex Conditional,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The conditional expression  "offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding)"  is complex.
Complex Conditional,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The conditional expression  "paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF))"  is complex.
Magic Number,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,LoadCacheFile,The following statement contains a magic number: byte[] headerMagic = reader.ReadBlock(4);
Magic Number,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: if (headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd')  				return Endian.BigEndian;
Magic Number,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: if (headerMagic[0] == 'h' && headerMagic[1] == 'e' && headerMagic[2] == 'a' && headerMagic[3] == 'd')  				return Endian.BigEndian;
Magic Number,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: if (headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h')  				return Endian.LittleEndian;
Magic Number,Blamite.Blam,CacheFileLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\CacheFileLoader.cs,DetermineCacheFileEndianness,The following statement contains a magic number: if (headerMagic[0] == 'd' && headerMagic[1] == 'a' && headerMagic[2] == 'e' && headerMagic[3] == 'h')  				return Endian.LittleEndian;
Magic Number,Blamite.Blam,LengthBasedStringIDResolver,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\LengthBasedStringIDResolver.cs,LengthBasedStringIDResolver,The following statement contains a magic number: IDLayout = new StringIDLayout(24' 0' 8);
Magic Number,Blamite.Blam,LengthBasedStringIDResolver,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\LengthBasedStringIDResolver.cs,LengthBasedStringIDResolver,The following statement contains a magic number: IDLayout = new StringIDLayout(24' 0' 8);
Magic Number,Blamite.Blam,StringID,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\StringID.cs,CreateMask,The following statement contains a magic number: return (0xFFFFFFFF >> (32 - size));
Magic Number,Blamite.Blam,IndexedStringTable,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\IndexedStringTable.cs,SaveOffsets,The following statement contains a magic number: _indexTable.Resize(_strings.Count*4' stream);
Magic Number,Blamite.Blam,DatumIndex,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\DatumIndex.cs,DatumIndex,The following statement contains a magic number: Salt = (ushort) ((value >> 16) & 0xFFFF);
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,WriteElement,The following statement contains a magic number: switch (layout.Type)  			{  				case VertexElementType.UDec4N:  					val = (uint) (x*1023.0f) & 0x3FF;  					val |= ((uint) (y*1023.0f) & 0x3FF) << 10;  					val |= ((uint) (z*1023.0f) & 0x3FF) << 20;  					val |= (uint) (w*3.0f) << 30;  					_writer.WriteUInt32(val);  					break;    				case VertexElementType.UShort2N:  					_writer.WriteUInt16((ushort) (x*65535.0f));  					_writer.WriteUInt16((ushort) (y*65535.0f));  					_writer.WriteUInt16((ushort) (z*65535.0f));  					break;    				case VertexElementType.DHen3N:  					val = (((uint) (x*511.0f) << 22) & 0xFFC00000) >> 22;  					val |= (((uint) (y*1023.0f) << 21) & 0xFFE00000) >> 11;  					val |= ((uint) (z*1023.0f) << 21) & 0xFFE00000;  					_writer.WriteUInt32(val);  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' layout.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,BoundingBox,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBox.cs,BoundingBox,The following statement contains a magic number: Unknown1 = 3;
Magic Number,Blamite.Blam.Resources.Models,BoundingBox,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBox.cs,Deserialize,The following statement contains a magic number: result.Unknown1 = (int) values.GetIntegerOrDefault("unknown 1"' 3);
Magic Number,Blamite.Blam.Resources.Models,IndexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\IndexBufferReader.cs,SkipIndexBuffer,The following statement contains a magic number: reader.Skip(count*2);
Magic Number,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The following statement contains a magic number: reader.SeekTo((reader.Position + 3) & ~3);
Magic Number,Blamite.Blam.Resources.Models,ModelReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\ModelReader.cs,ReadSectionIndices,The following statement contains a magic number: reader.SeekTo((reader.Position + 3) & ~3);
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,SkipExtraElements,The following statement contains a magic number: switch (section.ExtraElementsType)  			{  				case ExtraVertexElementType.Byte:  					reader.Skip((totalVertices*section.ExtraElementsPerVertex + 3) & ~3);  					break;  				case ExtraVertexElementType.Float3:  					reader.Skip(totalVertices*section.ExtraElementsPerVertex*3);  					break;  				case ExtraVertexElementType.None:  					break;  				default:  					throw new InvalidOperationException("Unsupported extra vertex element type: " + section.ExtraElementsType);  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,ReadElement,The following statement contains a magic number: switch (element.Type)  			{  				case VertexElementType.Float2:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					break;    				case VertexElementType.Float3:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					break;    				case VertexElementType.Float4:  					x = reader.ReadFloat();  					y = reader.ReadFloat();  					z = reader.ReadFloat();  					w = reader.ReadFloat();  					break;    				case VertexElementType.UByte4:  					x = reader.ReadByte();  					y = reader.ReadByte();  					z = reader.ReadByte();  					w = reader.ReadByte();  					break;    				case VertexElementType.UByte4N:  					x = reader.ReadByte()/255.0f;  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					w = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.Byte4N:  					x = reader.ReadSByte()/127.0f;  					y = reader.ReadSByte()/127.0f;  					z = reader.ReadSByte()/127.0f;  					w = reader.ReadSByte()/127.0f;  					break;    				case VertexElementType.Float16_2:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.Float16_4:  					x = Half.ToHalf(reader.ReadUInt16());  					y = Half.ToHalf(reader.ReadUInt16());  					z = Half.ToHalf(reader.ReadUInt16());  					w = Half.ToHalf(reader.ReadUInt16());  					break;    				case VertexElementType.UShort2:  					x = reader.ReadUInt16();  					y = reader.ReadUInt16();  					break;    				case VertexElementType.UShort2N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.UShort4N:  					x = reader.ReadUInt16()/65535.0f;  					y = reader.ReadUInt16()/65535.0f;  					z = reader.ReadUInt16()/65535.0f;  					w = reader.ReadUInt16()/65535.0f;  					break;    				case VertexElementType.Short4N:  					x = reader.ReadInt16()/32767.0f;  					y = reader.ReadInt16()/32767.0f;  					z = reader.ReadInt16()/32767.0f;  					w = reader.ReadInt16()/32767.0f;  					break;    				case VertexElementType.D3DColor:  					w = reader.ReadByte()/255.0f; // W is set here because alpha comes first but ends up last in the vector  					y = reader.ReadByte()/255.0f;  					z = reader.ReadByte()/255.0f;  					x = reader.ReadByte()/255.0f;  					break;    				case VertexElementType.DHen3N:  					value = reader.ReadUInt32();  					x = (((int) ((value << 22) & 0xFFC00000)) >> 22)/511.0f;  					y = (((int) ((value << 11) & 0xFFE00000)) >> 21)/1023.0f;  					z = (((int) (value & 0xFFE00000)) >> 21)/1023.0f;  					break;    				case VertexElementType.UDec4N:  					value = reader.ReadUInt32();  					x = (value & 0x3FF)/1023.0f;  					y = ((value >> 10) & 0x3FF)/1023.0f;  					z = ((value >> 20) & 0x3FF)/1023.0f;  					w = (value >> 30)/3.0f;  					break;    				default:  					throw new NotSupportedException("Unsupported vertex element type: " +  					                                Enum.GetName(typeof (VertexElementType)' element.Type));  			}
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,MapC,The following statement contains a magic number: if (code < 123) // '\0' <= code <= 'z'          return mapC0[code - 0];        else // '{' <= code <= '\U0010FFFF'          return (sbyte)0;
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,NextState,The following statement contains a magic number: if (code == ScanBuff.EndOfFile)          return eofNum;      else          unchecked {              int rslt;              int idx = MapC(code) - NxS[state].min;              if (idx < 0) idx += 28;              if ((uint)idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;              else rslt = NxS[state].nxt[idx];              return rslt;          }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,GetCode,The following statement contains a magic number: if (code > ScanBuff.EndOfFile)              {  #if (!BYTEMODE)                  if (code >= 0xD800 && code <= 0xDBFF)                  {                      int next = buffer.Read();                      if (next < 0xDC00 || next > 0xDFFF)                          code = ScanBuff.UnicodeReplacementChar;                      else                          code = (0x10000 + ((code & 0x3FF) << 10) + (next & 0x3FF));                  }  #endif                  cCol++;              }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptScanner,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )                  {                      int next;              // next state to enter                     #if BACKUP                      Result rslt = Result.noMatch;  #endif // BACKUP  #if LEFTANCHORS                      for (;;)                      {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart)                               break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart)                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                                            while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum  #if BACKUP                          if (state <= maxAccept && next > maxAccept) // need to prepare backup data                          {                              // ctx is an object. The fields may be                               // mutated by the call to Recurse2.                              // On return the data in ctx is the                              // *latest* accept state that was found.                                                            rslt = Recurse2(ref ctx' next);                              if (rslt == Result.noMatch)                                   RestoreStateAndPos(ref ctx);                              break;                          }                          else  #endif // BACKUP                          {                              state = next;                              GetCode();                          }                      if (state <= maxAccept)                       {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)LispScriptTokens.EOF;              break;          case 1:          case 4:          case 27:  /* ignore */              break;          case 2:          case 3:          case 8:          case 9:          case 10:          case 15:          case 16:          case 18:          case 19:          case 20:          case 22:          case 23:          case 28:          case 29:          case 30:          case 31:          case 32:          case 33:          case 35:          case 36:          case 37:          case 38:  BEGIN(INITIAL); yylval.StringValue = yytext; return (int)LispScriptTokens.NAME;              break;          case 5:  BEGIN(AFTEROPEN); return (int)'(';              break;          case 6:  BEGIN(INITIAL); return (int)')';              break;          case 7:  BEGIN(INITIAL); return (int)''';              break;          case 11:          case 14:  BEGIN(INITIAL); yylval.FloatValue = float.Parse(yytext); return (int)LispScriptTokens.FLOAT;              break;          case 12:  BEGIN(INITIAL); yy_push_state(COMMENT);              break;          case 13:  BEGIN(INITIAL); yylval.StringValue = yytext.Substring(1' yytext.Length - 2); return (int)LispScriptTokens.STRING;              break;          case 17:  BEGIN(INITIAL); return (int)LispScriptTokens.NONE;              break;          case 21:  BEGIN(INITIAL); yylval.BooleanValue = false; return (int)LispScriptTokens.BOOLEAN;              break;          case 24:  BEGIN(INITIAL); yylval.BooleanValue = true; return (int)LispScriptTokens.BOOLEAN;              break;          case 25:          case 26:  yy_pop_state();              break;          case 34:  BEGIN(INITIAL); return (int)LispScriptTokens.SCRIPT;              break;          case 39:  BEGIN(INITIAL); return (int)LispScriptTokens.GLOBAL;              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Blamite.Blam.Scripting.Analysis,BuildBuffer,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Mark,The following statement contains a magic number: data.Mark(bPos - 2);
Magic Number,Blamite.Blam.Scripting.Analysis,BuildBuffer,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,BuildBuffer,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,BufferElement,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Mark,The following statement contains a magic number: if (limit > brkIx + 16) // Rotate blocks                  {                      StringBuilder temp = bldr;                      bldr = next;                      next = temp;                      next.Length = 0;                      minIx = brkIx;                      brkIx = maxIx;                  }
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Get,The following statement contains a magic number: if (preamble != 0)  // There is a valid BOM here!                  encoding = Encoding.GetEncoding(preamble);              else if (fallbackCodePage == -1) // Fallback is "raw" bytes                  return Raw(stream);              else if (fallbackCodePage != -2) // Anything but "guess"                  encoding = Encoding.GetEncoding(fallbackCodePage);              else // This is the "guess" option              {                  int guess = new Guesser(stream).GuessCodePage();                  stream.Seek(0' SeekOrigin.Begin);                  if (guess == -1) // ==> this is a 7-bit file                      encoding = Encoding.ASCII;                  else if (guess == 65001)                      encoding = Encoding.UTF8;                  else             // ==> use the machine default                      encoding = Encoding.Default;              }
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Get,The following statement contains a magic number: if (preamble != 0)  // There is a valid BOM here!                  encoding = Encoding.GetEncoding(preamble);              else if (fallbackCodePage == -1) // Fallback is "raw" bytes                  return Raw(stream);              else if (fallbackCodePage != -2) // Anything but "guess"                  encoding = Encoding.GetEncoding(fallbackCodePage);              else // This is the "guess" option              {                  int guess = new Guesser(stream).GuessCodePage();                  stream.Seek(0' SeekOrigin.Begin);                  if (guess == -1) // ==> this is a 7-bit file                      encoding = Encoding.ASCII;                  else if (guess == 65001)                      encoding = Encoding.UTF8;                  else             // ==> use the machine default                      encoding = Encoding.Default;              }
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: if (b0 == 0xfe && b1 == 0xff)                  return 1201;
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: if (b0 == 0xff && b1 == 0xfe)                  return 1200;
Magic Number,Blamite.Blam.Scripting.Analysis,BlockReaderFactory,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Preamble,The following statement contains a magic number: if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)                  return 65001;
Magic Number,Blamite.Blam.Scripting.Analysis,CodePageHandling,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,GetCodePage,The following statement contains a magic number: if (command.StartsWith("CodePage:"' StringComparison.OrdinalIgnoreCase))                  command = command.Substring(9);
Magic Number,Blamite.Blam.Scripting.Analysis,CodePageHandling,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,GetCodePage,The following statement contains a magic number: try              {                  if (command.Equals("RAW"))                      return -1;                  else if (command.Equals("GUESS"))                      return -2;                  else if (command.Equals("DEFAULT"))                      return 0;                  else if (char.IsDigit(command[0]))                      return int.Parse(command' CultureInfo.InvariantCulture);                  else                  {                      Encoding enc = Encoding.GetEncoding(command);                      return enc.CodePage;                  }              }              catch (FormatException)              {                  Console.Error.WriteLine(                      "Invalid format \"{0}\"' using machine default"' option);              }              catch (ArgumentException)              {                  Console.Error.WriteLine(                      "Unknown code page \"{0}\"' using machine default"' option);              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[7] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[9] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Guesser,The following statement contains a magic number: nextState[10] = nextState[2];
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following statement contains a magic number: for (; ; )              {                  int next;                  state = currentStart;                  while ((next = NextState()) == goStart)                      code = buffer.Read();                    state = next;                  code = buffer.Read();                    while ((next = NextState()) > eofNum)                  {                      state = next;                      code = buffer.Read();                  }                  if (state <= maxAccept)                  {                      #region ActionSwitch  #pragma warning disable 162                      switch (state)                      {                          case eofNum:                              switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }                              return EndToken;                          case 1: // Recognized '{Upper128}''	Shortest string "\xC0"                          case 2: // Recognized '{Upper128}''	Shortest string "\x80"                          case 3: // Recognized '{Upper128}''	Shortest string "\xE0"                          case 4: // Recognized '{Upper128}''	Shortest string "\xF0"                              uppr++;                              break;                          case 5: // Recognized '{Utf8pfx4}{Utf8cont}''	Shortest string "\xF0\x80"                              uppr += 2;                              break;                          case 6: // Recognized '{Utf8pfx4}{Utf8cont}{2}''	Shortest string "\xF0\x80\x80"                              uppr += 3;                              break;                          case 7: // Recognized '{Utf8pfx4}{Utf8cont}{3}''	Shortest string "\xF0\x80\x80\x80"                              utfX += 3;                              break;                          case 8: // Recognized '{Utf8pfx3}{Utf8cont}''	Shortest string "\xE0\x80"                              uppr += 2;                              break;                          case 9: // Recognized '{Utf8pfx3}{Utf8cont}{2}''	Shortest string "\xE0\x80\x80"                              utfX += 2;                              break;                          case 10: // Recognized '{Utf8pfx2}{Utf8cont}''	Shortest string "\xC0\x80"                              utfX++;                              break;                          default:                              break;                      }  #pragma warning restore 162                      #endregion                  }              }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[0] = new State(-2'new int[]{-1'1});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[1] = new State(new int[]{46'2'40'5}'new int[]{-3'3'-4'4'-5'47});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[2] = new State(-1);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[3] = new State(-3);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[3] = new State(-3);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[4] = new State(-4);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[4] = new State(-4);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[5] = new State(new int[]{47'6'48'28});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[6] = new State(new int[]{49'7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[7] = new State(new int[]{49'8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[8] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'9'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[9] = new State(new int[]{41'10});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[10] = new State(-6);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[10] = new State(-6);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[11] = new State(-16);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[11] = new State(-16);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[12] = new State(-19);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[12] = new State(-19);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[13] = new State(-20);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[13] = new State(-20);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[14] = new State(-21);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[14] = new State(-21);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[15] = new State(-22);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[15] = new State(-22);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[16] = new State(-17);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[16] = new State(-17);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[17] = new State(new int[]{49'26'50'27}'new int[]{-2'18});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[18] = new State(new int[]{41'19'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'20'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[19] = new State(-23);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[19] = new State(-23);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[20] = new State(new int[]{41'21'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[21] = new State(-24);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[21] = new State(-24);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[22] = new State(-15);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[22] = new State(-15);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[23] = new State(-18);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[23] = new State(-18);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[24] = new State(-25);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[24] = new State(-25);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[25] = new State(-14);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[25] = new State(-14);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[26] = new State(-7);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[26] = new State(-7);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[27] = new State(-8);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[27] = new State(-8);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[28] = new State(new int[]{49'29});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[29] = new State(new int[]{49'30});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[30] = new State(new int[]{40'34'49'26'50'27}'new int[]{-2'31});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[31] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'32'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[32] = new State(new int[]{41'33'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[33] = new State(-9);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[33] = new State(-9);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[34] = new State(new int[]{49'26'50'27}'new int[]{-2'35});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[35] = new State(new int[]{40'36});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[36] = new State(new int[]{49'44}'new int[]{-12'37'-11'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[37] = new State(new int[]{41'38'44'42});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[38] = new State(new int[]{41'39});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[39] = new State(new int[]{50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-10'40'-6'25'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[40] = new State(new int[]{41'41'50'12'51'13'52'14'53'15'40'17'49'24}'new int[]{-6'22'-7'11'-8'16'-9'23});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[41] = new State(-10);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[41] = new State(-10);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[42] = new State(new int[]{49'44}'new int[]{-11'43});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[43] = new State(-12);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[43] = new State(-12);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[44] = new State(new int[]{49'45});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[45] = new State(-13);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[45] = new State(-13);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[46] = new State(-11);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[46] = new State(-11);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[47] = new State(-5);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: states[47] = new State(-5);
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[1] = new Rule(-13' new int[]{-1'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[1] = new Rule(-13' new int[]{-1'46});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[2] = new Rule(-1' new int[]{});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[3] = new Rule(-1' new int[]{-1'-3});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[3] = new Rule(-1' new int[]{-1'-3});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[4] = new Rule(-3' new int[]{-4});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[5] = new Rule(-3' new int[]{-5});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[6] = new Rule(-4' new int[]{40'47'49'49'-6'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[7] = new Rule(-2' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[8] = new Rule(-2' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[9] = new Rule(-5' new int[]{40'48'49'49'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[10] = new Rule(-5' new int[]{40'48'49'49'40'-2'40'-12'41'41'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[11] = new Rule(-12' new int[]{-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[12] = new Rule(-12' new int[]{-12'44'-11});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[13] = new Rule(-11' new int[]{49'49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[14] = new Rule(-10' new int[]{-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[15] = new Rule(-10' new int[]{-10'-6});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[16] = new Rule(-6' new int[]{-7});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[17] = new Rule(-6' new int[]{-8});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[18] = new Rule(-6' new int[]{-9});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[19] = new Rule(-7' new int[]{50});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[20] = new Rule(-7' new int[]{51});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[21] = new Rule(-7' new int[]{52});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[22] = new Rule(-7' new int[]{53});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[23] = new Rule(-8' new int[]{40'-2'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[24] = new Rule(-8' new int[]{40'-2'-10'41});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,LispScriptParser,The following statement contains a magic number: rules[25] = new Rule(-9' new int[]{49});
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,Shift,The following statement contains a magic number: if (recovering)  			{  				if (NextToken != errorToken)  					tokensSinceLastError++;    				if (tokensSinceLastError > 5)  					recovering = false;  			}
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,ReportError,The following statement contains a magic number: if (FsaState.ParserTable.Count < 7)  			{  				bool first = true;  				foreach (int terminal in FsaState.ParserTable.Keys)  				{  					if (first)  						errorMsg.Append("' expecting ");  					else  						errorMsg.Append("' or ");    					errorMsg.Append(TerminalToString(terminal));  					first = false;  				}  			}
Magic Number,QUT.Gppg,State,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < goToList.Length; i += 2)  				Goto.Add(goToList[i]' goToList[i + 1]);
Magic Number,QUT.Gppg,State,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < actions.Length; i += 2)  				ParserTable.Add(actions[i]' actions[i + 1]);
Magic Number,QUT.Gppg,State,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < goToList.Length; i += 2)  				Goto.Add(goToList[i]' goToList[i + 1]);
Magic Number,QUT.Gppg,PushdownPrefixState<T>,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\ShiftReduceParserCode.cs,Push,The following statement contains a magic number: if (tos >= array.Length)  			{  				var newarray = new T[array.Length*2];  				Array.Copy(array' newarray' tos);  				array = newarray;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GenerateExpressionCode,The following statement contains a magic number: switch (type.Name)  			{  				case "void":  					return false;  				case "boolean":  					if (value > 0)  						output.Write("true");  					else  						output.Write("false");  					break;  				case "short":  				case "long":  					// Signed integer  					output.Write((int) value);  					break;  				case "real":  					// Eww  					var floatBytes = new byte[4];  					floatBytes[0] = (byte) (value & 0xFF);  					floatBytes[1] = (byte) ((value >> 8) & 0xFF);  					floatBytes[2] = (byte) ((value >> 16) & 0xFF);  					floatBytes[3] = (byte) ((value >> 24) & 0xFF);  					output.Write(BitConverter.ToSingle(floatBytes' 0));  					break;  				case "function_name":  					if (_nextFunctionIsScript)  					{  						output.Write(_scripts.Scripts[expression.Opcode].Name);  						_nextFunctionIsScript = false;  					}  					else  					{  						ScriptFunctionInfo info = _opcodes.GetFunctionInfo(expression.Opcode);  						if (info == null)  							throw new InvalidOperationException("Unrecognized function opcode 0x" + expression.Opcode.ToString("X"));    						output.Write(info.Name);  					}  					break;  				case "unit_seat_mapping":  					// This isn't the technical way of doing this'  					// but since seat mapping names aren't stored anywhere'  					// it would be tricky to resolve them unless we just use an index for now  					if (expression.Value != 0xFFFFFFFF)  						output.Write(expression.Value & 0xFFFF);  					else  						output.Write("none");  					break;  				default:  					string enumValue = actualType.GetEnumValue(value);  					if (enumValue != null)  					{  						output.Write(enumValue);  					}  					else if (expression.Value == 0xFFFFFFFF)  					{  						output.Write("none");  					}  					else  					{  						enumValue = expression.StringValue;  						if (enumValue != null)  							output.Write(enumValue);  						else  							output.Write("0x{0:X}"' value);  					}  					break;  			}
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GetValue,The following statement contains a magic number: return expression.Value >> (32 - (type.Size*8));
Magic Number,Blamite.Blam.Scripting,BlamScriptGenerator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\BlamScriptGenerator.cs,GetValue,The following statement contains a magic number: return expression.Value >> (32 - (type.Size*8));
Magic Number,Blamite.Blam.SecondGen,SecondGenCacheFile,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\SecondGenCacheFile.cs,CalculateChecksum,The following statement contains a magic number: for (int offset = _header.HeaderSize; offset < _header.FileSize; offset += 4)  				checksum ^= reader.ReadUInt32();
Magic Number,Blamite.Blam.ThirdGen,PureBLF,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\PureBLF.cs,AddBLFChunk,The following statement contains a magic number: if (chunk.ChunkMagic.Length != 4)  				throw new Exception("Chunk Magic has to be 4 chars long");
Magic Number,Blamite.Blam.ThirdGen.BLF,Campaign,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\Campaign.cs,UpdateLanguageCount,The following statement contains a magic number: switch (gameIdent)  			{  				case GameIdentifier.Halo3:  					languageCount = 12;  					break;  				case GameIdentifier.Halo4:  					languageCount = 17;  					break;  				default:  					throw new InvalidOperationException("The Campaign BLF file is from an unknown Halo Version");  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,Campaign,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\Campaign.cs,UpdateLanguageCount,The following statement contains a magic number: switch (gameIdent)  			{  				case GameIdentifier.Halo3:  					languageCount = 12;  					break;  				case GameIdentifier.Halo4:  					languageCount = 17;  					break;  				default:  					throw new InvalidOperationException("The Campaign BLF file is from an unknown Halo Version");  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: var ints = new int[64];
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: for (int i = 0; i < 64; i++)  			{  				_stream.SeekTo(baseOffset + (i * 4));  				ints[i] = _stream.ReadInt32();  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadMPObjectTable,The following statement contains a magic number: for (int i = 0; i < 64; i++)  			{  				_stream.SeekTo(baseOffset + (i * 4));  				ints[i] = _stream.ReadInt32();  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following statement contains a magic number: for (int i = 0; i < Engine.InsertionCount; i++)  			{  				_mapInformation.MapCheckpoints.Add(new Checkpoint());    				if (Engine.InsertionUsesVisibility)  				{  					_stream.SeekTo(baseOffset + (i * Engine.InsertionSize));  					int visible = _stream.ReadByte();  					_mapInformation.MapCheckpoints[i].IsVisible = visible == 1;  				}  				if (Engine.InsertionUsesUsage)  				{  					_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 1);  					int used = _stream.ReadByte();  					_mapInformation.MapCheckpoints[i].IsUsed = used == 1;  				}  				  				switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}    				int namesBaseOffset = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionNameOffset);  				for (int n = 0; n < Engine.LanguageCount; n++)  				{  					_stream.SeekTo(namesBaseOffset + (n * 0x40));  					_mapInformation.MapCheckpoints[i].CheckpointNames.Add(_stream.ReadUTF16());  				}    				int descriptionsBaseOffset = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionDescriptionOffset);  				for (int d = 0; d < Engine.LanguageCount; d++)  				{  					_stream.SeekTo(descriptionsBaseOffset + (d * 0x100));  					_mapInformation.MapCheckpoints[i].CheckpointDescriptions.Add(_stream.ReadUTF16());  				}  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following statement contains a magic number: for (int i = 0; i < Engine.InsertionCount; i++)  			{  				_mapInformation.MapCheckpoints.Add(new Checkpoint());    				if (Engine.InsertionUsesVisibility)  				{  					_stream.SeekTo(baseOffset + (i * Engine.InsertionSize));  					int visible = _stream.ReadByte();  					_mapInformation.MapCheckpoints[i].IsVisible = visible == 1;  				}  				if (Engine.InsertionUsesUsage)  				{  					_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 1);  					int used = _stream.ReadByte();  					_mapInformation.MapCheckpoints[i].IsUsed = used == 1;  				}  				  				switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}    				int namesBaseOffset = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionNameOffset);  				for (int n = 0; n < Engine.LanguageCount; n++)  				{  					_stream.SeekTo(namesBaseOffset + (n * 0x40));  					_mapInformation.MapCheckpoints[i].CheckpointNames.Add(_stream.ReadUTF16());  				}    				int descriptionsBaseOffset = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionDescriptionOffset);  				for (int d = 0; d < Engine.LanguageCount; d++)  				{  					_stream.SeekTo(descriptionsBaseOffset + (d * 0x100));  					_mapInformation.MapCheckpoints[i].CheckpointDescriptions.Add(_stream.ReadUTF16());  				}  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateMPObjectTable,The following statement contains a magic number: var buffer = new int[64];
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateMPObjectTable,The following statement contains a magic number: for (int i = 0; i < 64; i++)  				_stream.WriteInt32(buffer[i]);
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following statement contains a magic number: for (int i = 0; i < Engine.InsertionCount; i++)  			{  				if (Engine.InsertionUsesVisibility)  				{  					_stream.SeekTo(baseOffset + (i*Engine.InsertionSize));  					_stream.WriteByte((byte) (_mapInformation.MapCheckpoints[i].IsVisible ? 0x1 : 0x0));  				}  				if (Engine.InsertionUsesUsage)  				{  					_stream.SeekTo(baseOffset + (i*Engine.InsertionSize) + 1);  					_stream.WriteByte((byte) (_mapInformation.MapCheckpoints[i].IsUsed ? 0x1 : 0x0));  				}    				switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}    				int baseOffsetNames = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionNameOffset);  				for (int n = 0; n < Engine.LanguageCount; n++)  				{  					int nameSeek = baseOffsetNames + (n * 0x40);  					_stream.SeekTo(nameSeek);  					_stream.WriteUTF16(_mapInformation.MapCheckpoints[i].CheckpointNames[n]);  				}    				int baseOffsetDescriptions = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionDescriptionOffset);  				for (int d = 0; d < Engine.LanguageCount; d++)  				{  					int descriptionSeek = baseOffsetDescriptions + (d * 0x100);  					_stream.SeekTo(descriptionSeek);  					_stream.WriteUTF16(_mapInformation.MapCheckpoints[i].CheckpointDescriptions[d]);  				}  			}
Magic Number,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following statement contains a magic number: for (int i = 0; i < Engine.InsertionCount; i++)  			{  				if (Engine.InsertionUsesVisibility)  				{  					_stream.SeekTo(baseOffset + (i*Engine.InsertionSize));  					_stream.WriteByte((byte) (_mapInformation.MapCheckpoints[i].IsVisible ? 0x1 : 0x0));  				}  				if (Engine.InsertionUsesUsage)  				{  					_stream.SeekTo(baseOffset + (i*Engine.InsertionSize) + 1);  					_stream.WriteByte((byte) (_mapInformation.MapCheckpoints[i].IsUsed ? 0x1 : 0x0));  				}    				switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}    				int baseOffsetNames = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionNameOffset);  				for (int n = 0; n < Engine.LanguageCount; n++)  				{  					int nameSeek = baseOffsetNames + (n * 0x40);  					_stream.SeekTo(nameSeek);  					_stream.WriteUTF16(_mapInformation.MapCheckpoints[i].CheckpointNames[n]);  				}    				int baseOffsetDescriptions = (baseOffset + (i * Engine.InsertionSize) + Engine.InsertionDescriptionOffset);  				for (int d = 0; d < Engine.LanguageCount; d++)  				{  					int descriptionSeek = baseOffsetDescriptions + (d * 0x100);  					_stream.SeekTo(descriptionSeek);  					_stream.WriteUTF16(_mapInformation.MapCheckpoints[i].CheckpointDescriptions[d]);  				}  			}
Magic Number,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,Load,The following statement contains a magic number: if (StringCount > 0)  			{  				// Index table offset' segment' and pointer  				int localeIndexTableOffset = localeArea.PointerToOffset(values.GetInteger("locale index table offset"));  				LocaleIndexTable = segmenter.WrapSegment(localeIndexTableOffset' StringCount*8' 8' SegmentResizeOrigin.End);  				LocaleIndexTableLocation = localeArea.AddSegment(LocaleIndexTable);    				// Data offset' segment' and pointer  				int localeDataOffset = localeArea.PointerToOffset(values.GetInteger("locale data index offset"));  				var localeDataSize = (int) values.GetInteger("locale table size");  				LocaleData = segmenter.WrapSegment(localeDataOffset' localeDataSize' _sizeAlign' SegmentResizeOrigin.End);  				LocaleDataLocation = localeArea.AddSegment(LocaleData);    				// Load hashes if they exist  				if (values.HasRaw("index table hash"))  					IndexTableHash = values.GetRaw("index table hash");  				if (values.HasRaw("string data hash"))  					StringDataHash = values.GetRaw("string data hash");  			}
Magic Number,Blamite.Blam.ThirdGen.Localization,ThirdGenLanguage,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Localization\ThirdGenLanguage.cs,Load,The following statement contains a magic number: if (StringCount > 0)  			{  				// Index table offset' segment' and pointer  				int localeIndexTableOffset = localeArea.PointerToOffset(values.GetInteger("locale index table offset"));  				LocaleIndexTable = segmenter.WrapSegment(localeIndexTableOffset' StringCount*8' 8' SegmentResizeOrigin.End);  				LocaleIndexTableLocation = localeArea.AddSegment(LocaleIndexTable);    				// Data offset' segment' and pointer  				int localeDataOffset = localeArea.PointerToOffset(values.GetInteger("locale data index offset"));  				var localeDataSize = (int) values.GetInteger("locale table size");  				LocaleData = segmenter.WrapSegment(localeDataOffset' localeDataSize' _sizeAlign' SegmentResizeOrigin.End);  				LocaleDataLocation = localeArea.AddSegment(LocaleData);    				// Load hashes if they exist  				if (values.HasRaw("index table hash"))  					IndexTableHash = values.GetRaw("index table hash");  				if (values.HasRaw("string data hash"))  					StringDataHash = values.GetRaw("string data hash");  			}
Magic Number,Blamite.Blam.ThirdGen.Resources.Sounds,ThirdGenSoundPlayback,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Sounds\ThirdGenSoundPlayback.cs,Load,The following statement contains a magic number: EncodedPermutationCount = ((int)values.GetInteger("encoded permutation count") >> 4) & 63;
Magic Number,Blamite.Blam.ThirdGen.Resources.Sounds,ThirdGenSoundPlayback,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Resources\Sounds\ThirdGenSoundPlayback.cs,Load,The following statement contains a magic number: EncodedPermutationCount = ((int)values.GetInteger("encoded permutation count") >> 4) & 63;
Magic Number,Blamite.Blam.ThirdGen.Shaders,ThirdGenShaderStreamer,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Shaders\ThirdGenShaderStreamer.cs,ReadShaderInfo,The following statement contains a magic number: if (debugValues.GetIntegerOrDefault("magic"' 0) >> 16 != 0x102A)  				return null;
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenResourceGestalt,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenResourceGestalt.cs,AlignInfoBlockOffset,The following statement contains a magic number: if ((resource.Flags & 4) != 0) // hax  				return (offset + 0xF) & ~0xF;
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: var ints = new int[((bits.Length + 31) & ~31)/32];
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,SaveBitArray,The following statement contains a magic number: if (!cache.TryGetAddress(ints' out newAddress))  			{  				newAddress = allocator.Allocate(ints.Length*4' stream);  				stream.SeekTo(_metaArea.PointerToOffset(newAddress));  				foreach (int i in ints)  					stream.WriteInt32(i);    				cache.Add(newAddress' ints);  			}
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenZoneSet,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenZoneSet.cs,FreeBitArray,The following statement contains a magic number: if (oldCount > 0 && oldAddress > 0)  				allocator.Free(oldAddress' oldCount*4);
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: if (StringIDCount > 0)  			{  				int sidIndexTableOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string index table offset"));  				int sidDataOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string table offset"));    				var sidTableSize = (int) values.GetInteger("string table size");  				StringIDIndexTable = segmenter.WrapSegment(sidIndexTableOff' StringIDCount*4' 4' SegmentResizeOrigin.End);  				StringIDData = segmenter.WrapSegment(sidDataOff' sidTableSize' 1' SegmentResizeOrigin.End);    				StringIDIndexTableLocation = StringArea.AddSegment(StringIDIndexTable);  				StringIDDataLocation = StringArea.AddSegment(StringIDData);    				// idk what this is' but H3Beta has it  				if (values.HasInteger("string block offset"))  				{  					int sidBlockOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string block offset"));  					StringBlock = segmenter.WrapSegment(sidBlockOff' StringIDCount*0x80' 0x80' SegmentResizeOrigin.End);  					StringBlockLocation = StringArea.AddSegment(StringBlock);  				}  			}
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: if (StringIDCount > 0)  			{  				int sidIndexTableOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string index table offset"));  				int sidDataOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string table offset"));    				var sidTableSize = (int) values.GetInteger("string table size");  				StringIDIndexTable = segmenter.WrapSegment(sidIndexTableOff' StringIDCount*4' 4' SegmentResizeOrigin.End);  				StringIDData = segmenter.WrapSegment(sidDataOff' sidTableSize' 1' SegmentResizeOrigin.End);    				StringIDIndexTableLocation = StringArea.AddSegment(StringIDIndexTable);  				StringIDDataLocation = StringArea.AddSegment(StringIDData);    				// idk what this is' but H3Beta has it  				if (values.HasInteger("string block offset"))  				{  					int sidBlockOff = DebugPointerConverter.PointerToOffset(values.GetInteger("string block offset"));  					StringBlock = segmenter.WrapSegment(sidBlockOff' StringIDCount*0x80' 0x80' SegmentResizeOrigin.End);  					StringBlockLocation = StringArea.AddSegment(StringBlock);  				}  			}
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: if (FileNameCount > 0)  			{  				int nameIndexTableOff = DebugPointerConverter.PointerToOffset(values.GetInteger("file index table offset"));  				int nameDataOff = DebugPointerConverter.PointerToOffset(values.GetInteger("file table offset"));    				var fileTableSize = (int) values.GetInteger("file table size");  				FileNameIndexTable = segmenter.WrapSegment(nameIndexTableOff' FileNameCount*4' 4' SegmentResizeOrigin.End);  				FileNameData = segmenter.WrapSegment(nameDataOff' fileTableSize' 1' SegmentResizeOrigin.End);    				FileNameIndexTableLocation = StringArea.AddSegment(FileNameIndexTable);  				FileNameDataLocation = StringArea.AddSegment(FileNameData);  			}
Magic Number,Blamite.Blam.ThirdGen.Structures,ThirdGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\Structures\ThirdGenHeader.cs,CalculateStringGroup,The following statement contains a magic number: if (FileNameCount > 0)  			{  				int nameIndexTableOff = DebugPointerConverter.PointerToOffset(values.GetInteger("file index table offset"));  				int nameDataOff = DebugPointerConverter.PointerToOffset(values.GetInteger("file table offset"));    				var fileTableSize = (int) values.GetInteger("file table size");  				FileNameIndexTable = segmenter.WrapSegment(nameIndexTableOff' FileNameCount*4' 4' SegmentResizeOrigin.End);  				FileNameData = segmenter.WrapSegment(nameDataOff' fileTableSize' 1' SegmentResizeOrigin.End);    				FileNameIndexTableLocation = StringArea.AddSegment(FileNameIndexTable);  				FileNameDataLocation = StringArea.AddSegment(FileNameData);  			}
Magic Number,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Allocate,The following statement contains a magic number: return Allocate(size' 4' stream);
Magic Number,Blamite.Blam.Util,MetaAllocator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\MetaAllocator.cs,Reallocate,The following statement contains a magic number: return Reallocate(address' oldSize' newSize' 4' stream);
Magic Number,Blamite.Blam.Util,AESKey,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\AESKey.cs,AESKey,The following statement contains a magic number: _key = new byte[16];
Magic Number,Blamite.Blam.Util,AESKey,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Util\AESKey.cs,AESKey,The following statement contains a magic number: _iv = new byte[16];
Magic Number,Blamite.Serialization.MapInfo,EngineDatabase,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\MapInfo\EngineDatabase.cs,RegisterEngine,The following statement contains a magic number: _engines[((uint)engine.LevlSize << 32) | (uint)engine.Version] = engine;
Magic Number,Blamite.Serialization.MapInfo,EngineDatabase,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\MapInfo\EngineDatabase.cs,FindEngine,The following statement contains a magic number: _engines.TryGetValue(((uint)size << 32) | (uint)version' out result);
Magic Number,Blamite.Serialization.Settings,SettingsGroup,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\SettingsGroup.cs,ParseLong,The following statement contains a magic number: if (str.StartsWith("-0x"))  				return -long.Parse(str.Substring(3)' NumberStyles.HexNumber);
Magic Number,Blamite.Serialization.Settings,SettingsGroup,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\SettingsGroup.cs,ParseLong,The following statement contains a magic number: if (str.StartsWith("0x"))  				return long.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Serialization.Settings,XMLStringIDSetLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLStringIDSetLoader.cs,ProcessIDLayoutInfo,The following statement contains a magic number: int indexBits = XMLUtil.GetNumericAttribute(element' "indexBits"' 16);
Magic Number,Blamite.Serialization.Settings,XMLStringIDSetLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\Settings\XMLStringIDSetLoader.cs,ProcessIDLayoutInfo,The following statement contains a magic number: int setBits = XMLUtil.GetNumericAttribute(element' "setBits"' 8);
Magic Number,Blamite.Serialization,LocaleSymbolCollection,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\LocaleSymbolCollection.cs,ReplaceTags,The following statement contains a magic number: while (tagStartPos >= 0)  			{  				int tagEndPos = locale.IndexOf("/>"' tagStartPos + 1);  				if (tagEndPos >= 0)  				{  					// Found a valid tag' get its name  					string tagName = locale.Substring(tagStartPos + 1' tagEndPos - (tagStartPos + 1));  					tagName = tagName.Trim();    					// Replace it if there's a match  					char replacement;  					if (_stringReplacements.TryGetValue(tagName' out replacement))  						locale = locale.Substring(0' tagStartPos) + replacement + locale.Substring(tagEndPos + 2);  				}  				tagStartPos = locale.IndexOf('<'' tagStartPos + 1);  			}
Magic Number,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following statement contains a magic number: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Magic Number,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,EnterPlugin,The following statement contains a magic number: var block = new DataBlock(_tag.MetaLocation.AsPointer()' 1' 4' data);
Magic Number,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,VisitUnicList,The following statement contains a magic number: for (var i = 0; i < languages; i++)  			{  				var strings = LoadStringList(i' _tag);  				if (strings == null)  					continue;  				var fixupStrings = strings.Strings.Select(CreateFixupString).ToArray();  				var fixup = new DataBlockUnicListFixup(i' (int)(offset + i * 4)' fixupStrings);  				_blockStack.Peek()[0].UnicListFixups.Add(fixup); // These will never be in tag blocks and I don't want to deal with it  			}
Magic Number,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,ReadShader,The following statement contains a magic number: _reader.Skip(-4);
Magic Number,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,GlobalShaderFixup,The following statement contains a magic number: if (shaderAddr == 0)  			{  				if (index != -1)  				{  					//make the index -1 in the datablock  					for (var i = 0; i < 4; i++)  						block.Data[offset + i] = 0xFF;    					//Grab the shader from gpix  					_reader.SeekTo(_cacheFile.Tags.FindTagByClass("gpix").MetaLocation.AsOffset() + 0x14);  					var gpixBase = _reader.ReadUInt32() - _cacheFile.MetaArea.PointerMask;  					_reader.SeekTo(gpixBase + (0x58 * index) + 0x54);    					//Make a shader fixup using the gpix shader  					var data = _cacheFile.ShaderStreamer.ExportShader(_reader' ShaderType.Pixel);  					var fixup = new DataBlockShaderFixup((int)offset + 4' data);  					block.ShaderFixups.Add(fixup);  				}  			}  			else  				return;
Magic Number,Blamite.Injection,DataBlockBuilder,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\DataBlockBuilder.cs,GlobalShaderFixup,The following statement contains a magic number: if (shaderAddr == 0)  			{  				if (index != -1)  				{  					//make the index -1 in the datablock  					for (var i = 0; i < 4; i++)  						block.Data[offset + i] = 0xFF;    					//Grab the shader from gpix  					_reader.SeekTo(_cacheFile.Tags.FindTagByClass("gpix").MetaLocation.AsOffset() + 0x14);  					var gpixBase = _reader.ReadUInt32() - _cacheFile.MetaArea.PointerMask;  					_reader.SeekTo(gpixBase + (0x58 * index) + 0x54);    					//Make a shader fixup using the gpix shader  					var data = _cacheFile.ShaderStreamer.ExportShader(_reader' ShaderType.Pixel);  					var fixup = new DataBlockShaderFixup((int)offset + 4' data);  					block.ShaderFixups.Add(fixup);  				}  			}  			else  				return;
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: if (version > 6)  				throw new InvalidOperationException("Unrecognized \"data\" block version");
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: int align = (version >= 3) ? reader.ReadInt32() : 4;
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: int align = (version >= 3) ? reader.ReadInt32() : 4;
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: if (version >= 2)  			{  				// StringID fixups  				int numSIDFixups = reader.ReadInt32();  				for (int i = 0; i < numSIDFixups; i++)  				{  					string str = reader.ReadAscii();  					int writeOffset = reader.ReadInt32();  					block.StringIDFixups.Add(new DataBlockStringIDFixup(str' writeOffset));  				}  			}
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: if (version >= 4)  			{  				// Shader fixups  				int numShaderFixups = reader.ReadInt32();  				for (int i = 0; i < numShaderFixups; i++)  				{  					int writeOffset = reader.ReadInt32();  					int shaderDataSize = reader.ReadInt32();  					byte[] shaderData = reader.ReadBlock(shaderDataSize);  					block.ShaderFixups.Add(new DataBlockShaderFixup(writeOffset' shaderData));  				}  			}
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: if (version >= 5)  			{  				// Unicode string list fixups  				int numUnicListFixups = reader.ReadInt32();  				for (int i = 0; i < numUnicListFixups; i++)  				{  					// Version 5 is buggy and doesn't include a language index :x  					int languageIndex = i;  					if (version >= 6)  						languageIndex = reader.ReadInt32();    					int writeOffset = reader.ReadInt32();  					int numStrings = reader.ReadInt32();  					UnicListFixupString[] strings = new UnicListFixupString[numStrings];  					for (int j = 0; j < numStrings; j++)  					{  						string stringId = reader.ReadAscii();  						string str = reader.ReadUTF8();  						strings[j] = new UnicListFixupString(stringId' str);  					}  					block.UnicListFixups.Add(new DataBlockUnicListFixup(languageIndex' writeOffset' strings));  				}  			}
Magic Number,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadDataBlock,The following statement contains a magic number: if (version >= 5)  			{  				// Unicode string list fixups  				int numUnicListFixups = reader.ReadInt32();  				for (int i = 0; i < numUnicListFixups; i++)  				{  					// Version 5 is buggy and doesn't include a language index :x  					int languageIndex = i;  					if (version >= 6)  						languageIndex = reader.ReadInt32();    					int writeOffset = reader.ReadInt32();  					int numStrings = reader.ReadInt32();  					UnicListFixupString[] strings = new UnicListFixupString[numStrings];  					for (int j = 0; j < numStrings; j++)  					{  						string stringId = reader.ReadAscii();  						string str = reader.ReadUTF8();  						strings[j] = new UnicListFixupString(stringId' str);  					}  					block.UnicListFixups.Add(new DataBlockUnicListFixup(languageIndex' writeOffset' strings));  				}  			}
Magic Number,Blamite.Injection,TagContainerWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerWriter.cs,WriteDataBlocks,The following statement contains a magic number: foreach (DataBlock dataBlock in tags.DataBlocks)  			{  				container.StartBlock("data"' 6);    				// Main data  				writer.WriteUInt32(dataBlock.OriginalAddress);  				writer.WriteInt32(dataBlock.EntryCount);  				writer.WriteInt32(dataBlock.Alignment);  				WriteByteArray(dataBlock.Data' writer);    				// Address fixups  				writer.WriteInt32(dataBlock.AddressFixups.Count);  				foreach (DataBlockAddressFixup blockRef in dataBlock.AddressFixups)  				{  					writer.WriteUInt32(blockRef.OriginalAddress);  					writer.WriteInt32(blockRef.WriteOffset);  				}    				// Tagref fixups  				writer.WriteInt32(dataBlock.TagFixups.Count);  				foreach (DataBlockTagFixup tagRef in dataBlock.TagFixups)  				{  					writer.WriteUInt32(tagRef.OriginalIndex.Value);  					writer.WriteInt32(tagRef.WriteOffset);  				}    				// Resource reference fixups  				writer.WriteInt32(dataBlock.ResourceFixups.Count);  				foreach (DataBlockResourceFixup resourceRef in dataBlock.ResourceFixups)  				{  					writer.WriteUInt32(resourceRef.OriginalIndex.Value);  					writer.WriteInt32(resourceRef.WriteOffset);  				}    				// StringID fixups  				writer.WriteInt32(dataBlock.StringIDFixups.Count);  				foreach (DataBlockStringIDFixup sid in dataBlock.StringIDFixups)  				{  					writer.WriteAscii(sid.OriginalString);  					writer.WriteInt32(sid.WriteOffset);  				}    				// Shader fixups  				writer.WriteInt32(dataBlock.ShaderFixups.Count);  				foreach (DataBlockShaderFixup shaderRef in dataBlock.ShaderFixups)  				{  					writer.WriteInt32(shaderRef.WriteOffset);  					if (shaderRef.Data != null)  					{  						writer.WriteInt32(shaderRef.Data.Length);  						writer.WriteBlock(shaderRef.Data);  					}  					else  					{  						writer.WriteInt32(0);  					}  				}    				// Unicode string list fixups  				writer.WriteInt32(dataBlock.UnicListFixups.Count);  				foreach (DataBlockUnicListFixup unicList in dataBlock.UnicListFixups)  				{  					writer.WriteInt32(unicList.LanguageIndex);  					writer.WriteInt32(unicList.WriteOffset);  					writer.WriteInt32(unicList.Strings.Length);  					foreach (UnicListFixupString str in unicList.Strings)  					{  						writer.WriteAscii(str.StringID);  						writer.WriteUTF8(str.String);  					}  				}    				container.EndBlock();  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: _stream.Read(_buffer' 0' 2);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: if (_bigEndian)  				return (ushort) ((_buffer[0] << 8) | _buffer[1]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort) ((_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: _stream.Read(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian)  				return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian)  				return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian)  				return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian)  				return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian)  				return (uint) ((_buffer[0] << 24) | (_buffer[1] << 16) | (_buffer[2] << 8) | _buffer[3]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((_buffer[3] << 24) | (_buffer[2] << 16) | (_buffer[1] << 8) | _buffer[0]);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt64,The following statement contains a magic number: if (_bigEndian)  				return (one << 32) | two;
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUInt64,The following statement contains a magic number: return (two << 32) | one;
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: _stream.Read(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Flip the bytes  				// Is there a faster way to do this?  				byte temp = _buffer[0];  				_buffer[0] = _buffer[3];  				_buffer[3] = temp;  				temp = _buffer[1];  				_buffer[1] = _buffer[2];  				_buffer[2] = temp;  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Flip the bytes  				// Is there a faster way to do this?  				byte temp = _buffer[0];  				_buffer[0] = _buffer[3];  				_buffer[3] = temp;  				temp = _buffer[1];  				_buffer[1] = _buffer[2];  				_buffer[2] = temp;  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Flip the bytes  				// Is there a faster way to do this?  				byte temp = _buffer[0];  				_buffer[0] = _buffer[3];  				_buffer[3] = temp;  				temp = _buffer[1];  				_buffer[1] = _buffer[2];  				_buffer[2] = temp;  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Flip the bytes  				// Is there a faster way to do this?  				byte temp = _buffer[0];  				_buffer[0] = _buffer[3];  				_buffer[3] = temp;  				temp = _buffer[1];  				_buffer[1] = _buffer[2];  				_buffer[2] = temp;  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUTF16,The following statement contains a magic number: while (_currentString.Length*2 < size)  			{  				ch = ReadInt16();  				if (ch == 0)  					break;  				_currentString.Append((char) ch);  			}
Magic Number,Blamite.IO,EndianReader,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianReader.cs,ReadUTF16,The following statement contains a magic number: Skip(size - _currentString.Length*2);
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt16,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 8);  				_buffer[1] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) (value >> 8);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt16,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 8);  				_buffer[1] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) (value >> 8);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt16,The following statement contains a magic number: _stream.Write(_buffer' 0' 2);
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 24);  				_buffer[1] = (byte) ((value >> 16) & 0xFF);  				_buffer[2] = (byte) ((value >> 8) & 0xFF);  				_buffer[3] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) (value >> 24);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt32,The following statement contains a magic number: _stream.Write(_buffer' 0' 4);
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: if (_bigEndian)  			{  				_buffer[0] = (byte) (value >> 56);  				_buffer[1] = (byte) ((value >> 48) & 0xFF);  				_buffer[2] = (byte) ((value >> 40) & 0xFF);  				_buffer[3] = (byte) ((value >> 32) & 0xFF);  				_buffer[4] = (byte) ((value >> 24) & 0xFF);  				_buffer[5] = (byte) ((value >> 16) & 0xFF);  				_buffer[6] = (byte) ((value >> 8) & 0xFF);  				_buffer[7] = (byte) (value & 0xFF);  			}  			else  			{  				_buffer[0] = (byte) (value & 0xFF);  				_buffer[1] = (byte) ((value >> 8) & 0xFF);  				_buffer[2] = (byte) ((value >> 16) & 0xFF);  				_buffer[3] = (byte) ((value >> 24) & 0xFF);  				_buffer[4] = (byte) ((value >> 32) & 0xFF);  				_buffer[5] = (byte) ((value >> 40) & 0xFF);  				_buffer[6] = (byte) ((value >> 48) & 0xFF);  				_buffer[7] = (byte) (value >> 56);  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteUInt64,The following statement contains a magic number: _stream.Write(_buffer' 0' 8);
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Is there a faster way to do this?  				byte temp = bytes[0];  				bytes[0] = bytes[3];  				bytes[3] = temp;  				temp = bytes[1];  				bytes[1] = bytes[2];  				bytes[2] = temp;  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Is there a faster way to do this?  				byte temp = bytes[0];  				bytes[0] = bytes[3];  				bytes[3] = temp;  				temp = bytes[1];  				bytes[1] = bytes[2];  				bytes[2] = temp;  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Is there a faster way to do this?  				byte temp = bytes[0];  				bytes[0] = bytes[3];  				bytes[3] = temp;  				temp = bytes[1];  				bytes[1] = bytes[2];  				bytes[2] = temp;  			}
Magic Number,Blamite.IO,EndianWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\EndianWriter.cs,WriteFloat,The following statement contains a magic number: if (BitConverter.IsLittleEndian == _bigEndian)  			{  				// Is there a faster way to do this?  				byte temp = bytes[0];  				bytes[0] = bytes[3];  				bytes[3] = temp;  				temp = bytes[1];  				bytes[1] = bytes[2];  				bytes[2] = temp;  			}
Magic Number,Blamite.IO,ContainerWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,StartBlock,The following statement contains a magic number: if (id.Length > 4)  				throw new ArgumentException("Container block IDs can be no more than 4 bytes long");
Magic Number,Blamite.IO,ContainerWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,StartBlock,The following statement contains a magic number: id = id.PadRight(4);
Magic Number,Blamite.IO,ContainerWriter,C:\repos\XboxChaos_Assembly\src\Blamite\IO\ContainerWriter.cs,EndBlock,The following statement contains a magic number: var blockSize = (int) (currentPos - blockSizePos + 4);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment((int) values.GetInteger("string index table offset")' StringIDCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: StringIDIndexTable = segmenter.WrapSegment((int) values.GetInteger("string index table offset")' StringIDCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment((int) values.GetInteger("file index table offset")' FileNameCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Blam.SecondGen.Structures,SecondGenHeader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\SecondGen\Structures\SecondGenHeader.cs,Load,The following statement contains a magic number: FileNameIndexTable = segmenter.WrapSegment((int) values.GetInteger("file index table offset")' FileNameCount*4' 4'  				SegmentResizeOrigin.End);
Magic Number,Blamite.Patching,AssemblyPatchLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadPatchInfo,The following statement contains a magic number: if (version >= 2)  				output.OutputName = reader.ReadAscii();  			else  				output.OutputName = "";
Magic Number,Blamite.Patching,AssemblyPatchLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadDataChanges,The following statement contains a magic number: for (int j = 0; j < numFourByteChanges; j++)  			{  				uint offset = reader.ReadUInt32();  				byte[] data = reader.ReadBlock(4);  				result.Add(new DataChange(offset' data));  			}
Magic Number,Blamite.Patching,AssemblyPatchWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WritePatchInfo,The following statement contains a magic number: container.StartBlock("titl"' 2);
Magic Number,Blamite.Patching,AssemblyPatchWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteDataChanges,The following statement contains a magic number: List<DataChange> fourByteChanges = changes.Where(c => c.Data.Length == 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteDataChanges,The following statement contains a magic number: List<DataChange> otherChanges = changes.Where(c => c.Data.Length != 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteMetaChanges,The following statement contains a magic number: List<DataChange> fourByteChanges = patch.MetaChanges.Where(c => c.Data.Length == 4).ToList();
Magic Number,Blamite.Patching,AssemblyPatchWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchWriter.cs,WriteMetaChanges,The following statement contains a magic number: List<DataChange> otherChanges = patch.MetaChanges.Where(c => c.Data.Length != 4).ToList();
Magic Number,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitVector3,The following statement contains a magic number: WriteBasicValue("float"' name + " Y"' offset + 4' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitVector3,The following statement contains a magic number: WriteBasicValue("float"' name + " Z"' offset + 8' visible);
Magic Number,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: for (var i = 0; i < languages; i++)  			{  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Index"' (uint)(offset + i * 4)' visible);  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Count"' (uint)(offset + i * 4 + 2)' visible);  			}
Magic Number,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: for (var i = 0; i < languages; i++)  			{  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Index"' (uint)(offset + i * 4)' visible);  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Count"' (uint)(offset + i * 4 + 2)' visible);  			}
Magic Number,Blamite.Plugins,AscensionPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AscensionPluginWriter.cs,VisitUnicList,The following statement contains a magic number: for (var i = 0; i < languages; i++)  			{  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Index"' (uint)(offset + i * 4)' visible);  				WriteBasicValue("uint16"' "Language " + i + " " + name + " Count"' (uint)(offset + i * 4 + 2)' visible);  			}
Magic Number,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadDataRef,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ReadReflexive,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseInt,The following statement contains a magic number: if (str.StartsWith("0x"))  				return int.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseInt,The following statement contains a magic number: if (str.StartsWith("-0x"))  				return -int.Parse(str.Substring(3)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,AssemblyPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginLoader.cs,ParseUInt,The following statement contains a magic number: return str.StartsWith("0x") ? uint.Parse(str.Substring(2)' NumberStyles.HexNumber) : uint.Parse(str);
Magic Number,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitDataReference,The following statement contains a magic number: if (align != 4)  				_output.WriteAttributeString("align"' ToHexString(align));
Magic Number,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The following statement contains a magic number: switch (format.Length)  			{  				case 1:  					element = "color8";  					break;  				case 2:  					element = "color16";  					break;  				case 3:  					element = "color24";  					break;  				default:  					element = "color32";  					break;  			}
Magic Number,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,VisitColorInt,The following statement contains a magic number: switch (format.Length)  			{  				case 1:  					element = "color8";  					break;  				case 2:  					element = "color16";  					break;  				case 3:  					element = "color24";  					break;  				default:  					element = "color32";  					break;  			}
Magic Number,Blamite.Plugins,AssemblyPluginWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\AssemblyPluginWriter.cs,EnterReflexive,The following statement contains a magic number: if (align != 4)  				_output.WriteAttributeString("align"' ToHexString(align));
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,HandleValueElement,The following statement contains a magic number: switch (elementName.ToLower())  			{  				case "uint8":  				case "byte":  					visitor.VisitUInt8(name' offset' visible' pluginLine);  					break;  				case "sbyte":  				case "int8":  					visitor.VisitInt8(name' offset' visible' pluginLine);  					break;  				case "ushort":  				case "uint16":  					visitor.VisitUInt16(name' offset' visible' pluginLine);  					break;  				case "short":  				case "int16":  					visitor.VisitInt16(name' offset' visible' pluginLine);  					break;  				case "dword":  				case "uint":  				case "uint32":  				case "long":  				case "true":  					visitor.VisitUInt32(name' offset' visible' pluginLine);  					break;  				case "int":  				case "int32":  					visitor.VisitInt32(name' offset' visible' pluginLine);  					break;  				case "undefined":  				case "unknown":  					visitor.VisitUndefined(name' offset' visible' pluginLine);  					break;  				case "float":  				case "float32":  				case "degree":  					visitor.VisitFloat32(name' offset' visible' pluginLine);  					break;  				case "vector3":  					visitor.VisitVector3(name' offset' visible' pluginLine);  					break;  				case "stringid":  					visitor.VisitStringID(name' offset' visible' pluginLine);  					break;  				case "tag":  				case "tagid":  				case "tagref":  				case "ident":  					ReadTagRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "string":  				case "ascii":  					ReadAscii(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "string32":  					visitor.VisitAscii(name' offset' visible' 32' pluginLine);  					break;  				case "string64":  					visitor.VisitAscii(name' offset' visible' 64' pluginLine);  					break;  				case "string256":  					visitor.VisitAscii(name' offset' visible' 256' pluginLine);  					break;    				case "unicode":  				case "utf16":  					ReadUtf16(reader' name' offset' visible' visitor' pluginLine);  					break;  				case "unicode32":  					visitor.VisitUtf16(name' offset' visible' 32' pluginLine);  					break;  				case "unicode64":  					visitor.VisitUtf16(name' offset' visible' 64' pluginLine);  					break;  				case "unicode256":  					visitor.VisitUtf16(name' offset' visible' 256' pluginLine);  					break;    				case "bitfield8":  				case "bitmask8":  					if (visitor.EnterBitfield8(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask16":  				case "bitfield16":  					if (visitor.EnterBitfield16(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;  				case "bitmask32":  				case "bitfield32":  					if (visitor.EnterBitfield32(name' offset' visible' pluginLine))  						ReadBits(reader' visitor);  					break;    				case "enum8":  					if (visitor.EnterEnum8(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum16":  					if (visitor.EnterEnum16(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;  				case "enum32":  					if (visitor.EnterEnum32(name' offset' visible' pluginLine))  						ReadOptions(reader' visitor);  					break;    				case "tagdata":  				case "dataref":  					ReadDataRef(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "struct":  				case "reflexive":  				case "reflexives":  					ReadReflexive(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "bytearray":  				case "raw":  					ReadRaw(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "shader":  					ReadShader(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "uniclist":  					ReadUnicList(reader' name' offset' visible' visitor' pluginLine);  					break;    				case "color8":  				case "color16":  				case "color24":  				case "color32":  					visitor.VisitColorInt(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "colorf":  					visitor.VisitColorF(name' offset' visible' ReadColorFormat(reader)' pluginLine);  					break;    				case "id":  					// Class ID' part of a tag reference  					break;    				case "unused":  				case "unusued":  				case "ununused":  					// Do nothing' I really don't understand the point of this  					break;    				default:  					throw new ArgumentException("Unknown element \"" + elementName + "\"." + PositionInfo(reader));  			}
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadDataRef,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ReadReflexive,The following statement contains a magic number: int align = 4;
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ParseInt,The following statement contains a magic number: if (str.StartsWith("0x"))  				return int.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins,UniversalPluginLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\UniversalPluginLoader.cs,ParseUInt,The following statement contains a magic number: if (str.StartsWith("0x"))  				return uint.Parse(str.Substring(2)' NumberStyles.HexNumber);
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.Plugins.Generation,MetaAnalyzer,C:\repos\XboxChaos_Assembly\src\Blamite\Plugins\Generation\MetaAnalyzer.cs,AnalyzeArea,The following statement contains a magic number: for (int offset = 0; offset < size; offset += 4)  			{  				uint value = reader.ReadUInt32();    				if (IsPadding(value))  				{  					if (paddingLength == 0 && pendingGuess != null)  					{  						resultMap.AddGuess(pendingGuess);    						// Add the address to the memory map  						uint address = pendingGuess.Pointer;  						_memMap.AddAddress(address' (int) reader.Position);  					}    					// More padding! :D  					paddingLength++;  					pendingGuess = null;  				}  				else  				{  					pendingGuess = null;  					if (offset <= size - 8  					    && prePadding > 0  					    && prePadding < 0x80000000  					    && (value & 3) == 0  					    && IsValidAddress(value)  					    && value + prePadding > value  					    && IsValidAddress(value + prePadding - 1)  					    && !_memMap.BlockCrossesBoundary(value' (int) prePadding))  					{  						// Either a reflexive or a data reference  						// Check the padding to determine which (see the comments at the beginning of this method)  						if (paddingLength == 2 && offset >= 12 && (prePadding & 3) == 0)  						{  							// Found a data reference  							uint dataSize = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 12' MetaValueType.DataReference' address' dataSize);  							// Guess with Pointer = address' Data1 = data size  						}  						else if (paddingLength == 0 && offset >= 4)  						{  							// Found a reflexive!  							uint entryCount = prePadding;  							uint address = value;  							pendingGuess = new MetaValueGuess(offset - 4' MetaValueType.Reflexive' address' entryCount);  							// Guess with Pointer = address' Data1 = entry count  						}  					}  					if (paddingLength == 2 && offset >= 12 &&  					    (_classIds.Contains((int) prePadding) || (prePadding == 0xFFFFFFFF && value == 0xFFFFFFFF)))  					{  						// Found a tag reference  						uint classId = prePadding;  						uint datumIndex = value;  						var guess = new MetaValueGuess(offset - 12' MetaValueType.TagReference' datumIndex' classId);  						// Guess with Pointer = datum index' Data1 = class id  						resultMap.AddGuess(guess);  					}    					// This obviously isn't a padding value because IsPadding returned false'  					// so update padding run information accordingly  					prePadding = value;  					paddingLength = 0;  				}  			}
Magic Number,Blamite.RTE.H2Vista,H2VistaMapPointerReader,C:\repos\XboxChaos_Assembly\src\Blamite\RTE\H2Vista\H2VistaMapPointerReader.cs,ReadMapPointers,The following statement contains a magic number: reader.SeekTo(_mapHeaderAddress - 4);
Magic Number,Blamite.Util,CharConstant,C:\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: int index = 4;
Magic Number,Blamite.Util,CharConstant,C:\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: var chars = new char[4];
Magic Number,Blamite.Util,CharConstant,C:\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: while (constant > 0)  			{  				index--;  				chars[index] = (char) (constant & 0xFF);  				constant >>= 8;  			}
Magic Number,Blamite.Util,CharConstant,C:\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,ToString,The following statement contains a magic number: if (index == 4)  				return "";
Magic Number,Blamite.Util,CharConstant,C:\repos\XboxChaos_Assembly\src\Blamite\Util\CharConstant.cs,FromString,The following statement contains a magic number: foreach (byte b in bytes)  			{  				result <<= 8;  				result |= b;  			}
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexString,The following statement contains a magic number: var builder = new StringBuilder(array.Length*2);
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexString,The following statement contains a magic number: foreach (byte b in array)  			{  				builder.Append(chars[b >> 4]);  				builder.Append(chars[b & 0xF]);  			}
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexLines,The following statement contains a magic number: var builder = new StringBuilder(array.Length*2);
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,BytesToHexLines,The following statement contains a magic number: for (int i = 0; i < array.Length; i++)  			{  				if (i > 0 && i < array.Length - 1 && i%newlineInterval == 0)  					builder.AppendLine();    				builder.Append(chars[array[i] >> 4]);  				builder.Append(chars[array[i] & 0xF]);  			}
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: if (hex.Length%2 != 0)  				throw new FormatException("Hex string must be of even length");
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: var result = new byte[hex.Length/2];
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length; i++)  			{  				int value;  				char ch = hex[i];  				if (ch >= '0' && ch <= '9')  					value = ch - '0';  				else if (ch >= 'A' && ch <= 'F')  					value = 0xA + ch - 'A';  				else if (ch >= 'a' && ch <= 'f')  					value = 0xA + ch - 'a';  				else  					throw new FormatException("Not a valid hex string");    				result[i/2] |= (byte) (value << (4*(1 - i%2)));  			}
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length; i++)  			{  				int value;  				char ch = hex[i];  				if (ch >= '0' && ch <= '9')  					value = ch - '0';  				else if (ch >= 'A' && ch <= 'F')  					value = 0xA + ch - 'A';  				else if (ch >= 'a' && ch <= 'f')  					value = 0xA + ch - 'a';  				else  					throw new FormatException("Not a valid hex string");    				result[i/2] |= (byte) (value << (4*(1 - i%2)));  			}
Magic Number,Blamite.Util,FunctionHelpers,C:\repos\XboxChaos_Assembly\src\Blamite\Util\FunctionHelpers.cs,HexStringToBytes,The following statement contains a magic number: for (int i = 0; i < hex.Length; i++)  			{  				int value;  				char ch = hex[i];  				if (ch >= '0' && ch <= '9')  					value = ch - '0';  				else if (ch >= 'A' && ch <= 'F')  					value = 0xA + ch - 'A';  				else if (ch >= 'a' && ch <= 'f')  					value = 0xA + ch - 'a';  				else  					throw new FormatException("Not a valid hex string");    				result[i/2] |= (byte) (value << (4*(1 - i%2)));  			}
Magic Number,Blamite.Util,ListSearching,C:\repos\XboxChaos_Assembly\src\Blamite\Util\ListSearching.cs,BinarySearch,The following statement contains a magic number: while (lower <= upper)  			{  				int middle = (lower + upper)/2;  				TKey testValue = selector(values[middle]);    				int comparison = comparer.Compare(value' testValue);  				if (comparison == 0)  					return middle;  				if (comparison < 0)  					upper = middle - 1;  				else  					lower = middle + 1;  			}
Magic Number,Blamite.Util,XMLUtil,C:\repos\XboxChaos_Assembly\src\Blamite\Util\XMLUtil.cs,ParseNumber,The following statement contains a magic number: if (numberStr.StartsWith("0x"))  				return int.TryParse(numberStr.Substring(2)' NumberStyles.HexNumber' null' out result);
Magic Number,System,Half,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\Half.cs,GetTypeCode,The following statement contains a magic number: return (TypeCode) 255;
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,ConvertMantissa,The following statement contains a magic number: var m = (uint) (i << 13);
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: var mantissaTable = new uint[2048];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1; i < 1024; i++)  			{  				mantissaTable[i] = ConvertMantissa(i);  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)  			{  				mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)  			{  				mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)  			{  				mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)  			{  				mantissaTable[i] = (uint) (0x38000000 + ((i - 1024) << 13));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: var exponentTable = new uint[64];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 1; i < 31; i++)  			{  				exponentTable[i] = (uint) (i << 23);  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 1; i < 31; i++)  			{  				exponentTable[i] = (uint) (i << 23);  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[31] = 0x47800000;
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[32] = 0x80000000;
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)  			{  				exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)  			{  				exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)  			{  				exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)  			{  				exponentTable[i] = (uint) (0x80000000 + ((i - 32) << 23));  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[63] = 0xc7800000;
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: var offsetTable = new ushort[64];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 1; i < 32; i++)  			{  				offsetTable[i] = 1024;  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 1; i < 32; i++)  			{  				offsetTable[i] = 1024;  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[32] = 0;
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)  			{  				offsetTable[i] = 1024;  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)  			{  				offsetTable[i] = 1024;  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)  			{  				offsetTable[i] = 1024;  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: var baseTable = new ushort[512];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					baseTable[i | 0x000] = 0x0000;  					baseTable[i | 0x100] = 0x8000;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					baseTable[i | 0x000] = (ushort) (0x0400 >> (18 + e));  					baseTable[i | 0x100] = (ushort) ((0x0400 >> (18 + e)) | 0x8000);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					baseTable[i | 0x000] = (ushort) ((15 - e) << 10);  					baseTable[i | 0x100] = (ushort) (((15 - e) << 10) | 0x8000);  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					baseTable[i | 0x000] = 0x7c00;  					baseTable[i | 0x100] = 0xfc00;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: var shiftTable = new sbyte[512];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  			{  				var e = (sbyte) (127 - i);  				if (e > 24)  				{  					// Very small numbers map to zero  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else if (e > 14)  				{  					// Small numbers map to denorms  					shiftTable[i | 0x000] = (sbyte) (e - 1);  					shiftTable[i | 0x100] = (sbyte) (e - 1);  				}  				else if (e >= -15)  				{  					// Normal numbers just lose precision  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  				else if (e > -128)  				{  					// Large numbers map to Infinity  					shiftTable[i | 0x000] = 24;  					shiftTable[i | 0x100] = 24;  				}  				else  				{  					// Infinity and NaN's stay Infinity and NaN's  					shiftTable[i | 0x000] = 13;  					shiftTable[i | 0x100] = 13;  				}  			}
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,SingleToHalf,The following statement contains a magic number: var result = (ushort) (baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,HalfHelper,C:\repos\XboxChaos_Assembly\src\Blamite\Util\Half\HalfHelper.cs,SingleToHalf,The following statement contains a magic number: var result = (ushort) (baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Missing Default,Blamite.Blam.Resources.Models,BoundingBoxCalculator,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\BoundingBoxCalculator.cs,ProcessVertex,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					CalculatedBox.MinX = Math.Min(CalculatedBox.MinX' x);  					CalculatedBox.MinY = Math.Min(CalculatedBox.MinY' y);  					CalculatedBox.MinZ = Math.Min(CalculatedBox.MinZ' z);  					CalculatedBox.MaxX = Math.Max(CalculatedBox.MaxX' x);  					CalculatedBox.MaxY = Math.Max(CalculatedBox.MaxY' y);  					CalculatedBox.MaxZ = Math.Max(CalculatedBox.MaxZ' z);  					break;    				case VertexElementUsage.TexCoords:  					CalculatedBox.MinU = Math.Min(CalculatedBox.MinU' x);  					CalculatedBox.MinV = Math.Min(CalculatedBox.MinV' y);  					CalculatedBox.MaxU = Math.Max(CalculatedBox.MaxU' x);  					CalculatedBox.MaxV = Math.Max(CalculatedBox.MaxV' y);  					break;  			}
Missing Default,Blamite.Blam.Resources.Models,VertexBufferWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferWriter.cs,TransformElement,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					x = (x - _bbox.MinX)/(_bbox.MaxX - _bbox.MinX);  					y = (y - _bbox.MinY)/(_bbox.MaxY - _bbox.MinY);  					z = (z - _bbox.MinZ)/(_bbox.MaxZ - _bbox.MinZ);  					break;    				case VertexElementUsage.TexCoords:  					x = (x - _bbox.MinU)/(_bbox.MaxU - _bbox.MinU);  					y = (y - _bbox.MinV)/(_bbox.MaxV - _bbox.MinV);  					break;  			}
Missing Default,Blamite.Blam.Resources.Models,VertexBufferReader,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Resources\Models\VertexBufferReader.cs,TransformElement,The following switch statement is missing a default case: switch (usage)  			{  				case VertexElementUsage.Position:  					x = x*(boundingBox.MaxX - boundingBox.MinX) + boundingBox.MinX;  					y = y*(boundingBox.MaxY - boundingBox.MinY) + boundingBox.MinY;  					z = z*(boundingBox.MaxZ - boundingBox.MinZ) + boundingBox.MinZ;  					break;    				case VertexElementUsage.TexCoords:  					x = x*(boundingBox.MaxU - boundingBox.MinU) + boundingBox.MinU;  					y = y*(boundingBox.MaxV - boundingBox.MinV) + boundingBox.MinV;  					break;  			}
Missing Default,Blamite.Blam.Scripting.Analysis,Guesser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptScanner.cs,Scan,The following switch statement is missing a default case: switch (currentStart)                              {                                  case 11:                                      if (utfX == 0 && uppr == 0) return -1; /* raw ascii */                                      else if (uppr * 10 > utfX) return 0;   /* default code page */                                      else return 65001;                     /* UTF-8 encoding */                                      break;                              }
Missing Default,Blamite.Blam.Scripting.Analysis,LispScriptParser,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\Scripting\Analysis\LispScriptParser.cs,DoAction,The following switch statement is missing a default case: switch (action)      {        case 3: // declarations -> declarations' declaration  #line 37 "Blam\Scripting\Analysis\LispScriptParser.y"  { Nodes.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 6: // globaldecl -> '('' GLOBAL' NAME' NAME' expression' ')'  #line 45 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new GlobalDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-4].StringValue' ValueStack[ValueStack.Depth-2].Node); }          break;        case 8: // scriptname -> FLOAT  #line 51 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.StringValue = ValueStack[ValueStack.Depth-1].FloatValue.ToString(); }          break;        case 9: // scriptdecl -> '('' SCRIPT' NAME' NAME' scriptname' expressions' ')'  #line 55 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 56 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-3].StringValue' ValueStack[ValueStack.Depth-5].StringValue' ValueStack[ValueStack.Depth-4].StringValue);  #line 57 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 58 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 59 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 10: // scriptdecl -> '('' SCRIPT' NAME' NAME' '('' scriptname' '('' parameters' ')''                  //               ')'' expressions' ')'  #line 61 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 62 "Blam\Scripting\Analysis\LispScriptParser.y"                     var def = new ScriptDefinitionNode(ValueStack[ValueStack.Depth-7].StringValue' ValueStack[ValueStack.Depth-10].StringValue' ValueStack[ValueStack.Depth-9].StringValue);  #line 63 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Parameters.AddRange(ValueStack[ValueStack.Depth-5].ParamList);  #line 64 "Blam\Scripting\Analysis\LispScriptParser.y"                     def.Nodes.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 65 "Blam\Scripting\Analysis\LispScriptParser.y"                     CurrentSemanticValue.Node = def;  #line 66 "Blam\Scripting\Analysis\LispScriptParser.y"                 }          break;        case 11: // parameters -> parameter  #line 70 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = new List<ScriptDefinitionParam>(); CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 12: // parameters -> parameters' '''' parameter  #line 72 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.ParamList = ValueStack[ValueStack.Depth-3].ParamList; CurrentSemanticValue.ParamList.Add(ValueStack[ValueStack.Depth-1].Parameter); }          break;        case 13: // parameter -> NAME' NAME  #line 76 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Parameter = new ScriptDefinitionParam(ValueStack[ValueStack.Depth-1].StringValue' ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 14: // expressions -> expression  #line 80 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = new List<IScriptNode>(); CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 15: // expressions -> expressions' expression  #line 82 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.NodeList = ValueStack[ValueStack.Depth-2].NodeList; CurrentSemanticValue.NodeList.Add(ValueStack[ValueStack.Depth-1].Node); }          break;        case 19: // constant -> FLOAT  #line 91 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].FloatValue); }          break;        case 20: // constant -> STRING  #line 93 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;        case 21: // constant -> BOOLEAN  #line 95 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(ValueStack[ValueStack.Depth-1].BooleanValue); }          break;        case 22: // constant -> NONE  #line 97 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new ConstantNode(); }          break;        case 23: // functioncall -> '('' scriptname' ')'  #line 101 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new FunctionCallNode(ValueStack[ValueStack.Depth-2].StringValue); }          break;        case 24: // functioncall -> '('' scriptname' expressions' ')'  #line 103 "Blam\Scripting\Analysis\LispScriptParser.y"  {  #line 104 "Blam\Scripting\Analysis\LispScriptParser.y"                       var call = new FunctionCallNode(ValueStack[ValueStack.Depth-3].StringValue);  #line 105 "Blam\Scripting\Analysis\LispScriptParser.y"                       call.Arguments.AddRange(ValueStack[ValueStack.Depth-2].NodeList);  #line 106 "Blam\Scripting\Analysis\LispScriptParser.y"                       CurrentSemanticValue.Node = call;  #line 107 "Blam\Scripting\Analysis\LispScriptParser.y"                   }          break;        case 25: // variable -> NAME  #line 111 "Blam\Scripting\Analysis\LispScriptParser.y"  { CurrentSemanticValue.Node = new VariableReferenceNode(ValueStack[ValueStack.Depth-1].StringValue); }          break;      }
Missing Default,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,LoadInsertionPoints,The following switch statement is missing a default case: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_mapInformation.MapCheckpoints[i].ZoneIndex = _stream.ReadByte();  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_mapInformation.MapCheckpoints[i].ZoneName = _stream.ReadAscii();  						break;  				}
Missing Default,Blamite.Blam.ThirdGen.BLF,MapInfo,C:\repos\XboxChaos_Assembly\src\Blamite\Blam\ThirdGen\BLF\MapInfo.cs,UpdateInsertionPoints,The following switch statement is missing a default case: switch (Engine.InsertionZoneType)  				{  					case ZoneType.Index:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 3);  						_stream.WriteByte(_mapInformation.MapCheckpoints[i].ZoneIndex);  						break;  					case ZoneType.Name:  						_stream.SeekTo(baseOffset + (i * Engine.InsertionSize) + 4);  						_stream.WriteAscii(_mapInformation.MapCheckpoints[i].ZoneName);  						break;  				}
Missing Default,Blamite.Serialization,StructureReader,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureReader.cs,VisitBasicField,The following switch statement is missing a default case: switch (type)  			{  				case StructureValueType.Byte:  					_collection.SetInteger(name' _reader.ReadByte());  					_offset++;  					break;  				case StructureValueType.SByte:  					_collection.SetInteger(name' (uint) _reader.ReadSByte());  					_offset++;  					break;  				case StructureValueType.UInt16:  					_collection.SetInteger(name' _reader.ReadUInt16());  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_collection.SetInteger(name' (uint) _reader.ReadInt16());  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_collection.SetInteger(name' _reader.ReadUInt32());  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_collection.SetInteger(name' (uint) _reader.ReadInt32());  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_collection.SetString(name' _reader.ReadAscii());  					_offset = _reader.Position;  					break;  				case StructureValueType.Float32:  					_collection.SetFloat(name' _reader.ReadFloat());  					_offset += 4;  					break;  			}
Missing Default,Blamite.Serialization,StructureWriter,C:\repos\XboxChaos_Assembly\src\Blamite\Serialization\StructureWriter.cs,VisitBasicField,The following switch statement is missing a default case: switch (type)  			{  				case StructureValueType.Byte:  					_writer.WriteByte((byte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.SByte:  					_writer.WriteSByte((sbyte) _collection.GetInteger(name));  					_offset++;  					break;  				case StructureValueType.UInt16:  					_writer.WriteUInt16((ushort) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.Int16:  					_writer.WriteInt16((short) _collection.GetInteger(name));  					_offset += 2;  					break;  				case StructureValueType.UInt32:  					_writer.WriteUInt32(_collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Int32:  					_writer.WriteInt32((int) _collection.GetInteger(name));  					_offset += 4;  					break;  				case StructureValueType.Asciiz:  					_writer.WriteAscii(_collection.GetString(name));  					_offset = _writer.Position;  					break;  				case StructureValueType.Float32:  					_writer.WriteFloat(_collection.GetFloat(name));  					_offset += 4;  					break;  			}
Missing Default,Blamite.Injection,TagContainerReader,C:\repos\XboxChaos_Assembly\src\Blamite\Injection\TagContainerReader.cs,ReadBlocks,The following switch statement is missing a default case: switch (containerFile.BlockName)  				{  					case "data":  						// Data block  						tags.AddDataBlock(ReadDataBlock(reader' containerFile.BlockVersion));  						break;    					case "tag!":  						// Extracted tag  						tags.AddTag(ReadTag(reader' containerFile.BlockVersion));  						break;    					case "ersp":  						// Extracted Raw Resource Page  						tags.AddExtractedResourcePage(ReadExtractedResourcePage(reader' containerFile.BlockVersion));  						break;    					case "rspg":  						// Resource page  						tags.AddResourcePage(ReadResourcePage(reader' containerFile.BlockVersion));  						break;    					case "rsrc":  						// Resource info  						tags.AddResource(ReadResource(reader' containerFile.BlockVersion));  						break;  				}
Missing Default,Blamite.Patching,AssemblyPatchLoader,C:\repos\XboxChaos_Assembly\src\Blamite\Patching\AssemblyPatchLoader.cs,ReadBlocks,The following switch statement is missing a default case: switch (container.BlockName)  				{  					case "titl":  						ReadPatchInfo(reader' container.BlockVersion' result);  						break;    					case "segm":  						ReadSegmentChanges(reader' result);  						break;    					case "blfc":  						ReadBlfInfo(reader' result);  						break;    						#region Deprecated    					case "meta":  						ReadMetaChanges(reader' result);  						break;    					case "locl":  						ReadLocaleChanges(reader' result);  						break;    						#endregion Deprecated  				}
Missing Default,Blamite.Native,ProcessMemoryStream,C:\repos\XboxChaos_Assembly\src\Blamite\Native\ProcessMemoryStream.cs,Seek,The following switch statement is missing a default case: switch (origin)  			{  				case SeekOrigin.Begin:  					Position = offset;  					break;    				case SeekOrigin.Current:  					Position += offset;  					break;    				case SeekOrigin.End:  					Position = uint.MaxValue - offset;  					break;  			}
Missing Default,Blamite.Util,TypeUtil,C:\repos\XboxChaos_Assembly\src\Blamite\Util\TypeUtil.cs,IsInteger,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.Byte:  				case TypeCode.Int16:  				case TypeCode.Int32:  				case TypeCode.Int64:  				case TypeCode.SByte:  				case TypeCode.UInt16:  				case TypeCode.UInt32:  				case TypeCode.UInt64:  					return true;  			}
