Implementation smell,Namespace,Class,File,Method,Description
Long Method,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The method has 143 lines of code.
Complex Method,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,Cyclomatic complexity of the method is 25
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try {  	using (var tw = new StreamWriter (outPath)) {  		tw.WriteLine ("Type Name' Name' Description' Category");  		var nodeDirInfo = new DirectoryInfo (nodesDir);  		var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  		foreach (var nodeLib in nodeLibs) {  			var module = ModuleDefinition.ReadModule (nodeLib.FullName);  			var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  			var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  			if (!typeDefinitions.Any ())  				continue;  			foreach (var nn in typeDefinitions) {  				if (nn.IsAbstract)  					continue;  				if (!nn.HasCustomAttributes)  					continue;  				var name = "";  				var descrip = "";  				var cat = "";  				bool isCompilerGenerated = false;  				foreach (var ca in nn.CustomAttributes) {  					if (ca.AttributeType.Name == "NodeNameAttribute") {  						name = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  						descrip = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  						cat = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  						isCompilerGenerated = true;  					}  				}  				if (isCompilerGenerated)  					continue;  				string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  				//find the port data  				var constructors = nn.Methods.Where (x => x.IsConstructor);  				foreach (var constructor in constructors) {  					if (!constructor.HasBody)  						continue;  					int instructionCount = 0;  					foreach (var instruction in constructor.Body.Instructions) {  						if (instruction.OpCode == OpCodes.Newobj) {  							var methodRef = (MethodReference)instruction.Operand;  							if (methodRef.DeclaringType.Name == "PortData") {  								var nickname = "";  								var description = "";  								if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  									description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  								if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  									nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  								line += string.Format ("'{0}:{1}"' nickname' description);  							}  						}  						instructionCount++;  					}  				}  				tw.WriteLine (line);  			}  			#region using reflection  			//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  			//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  			//foreach (var n in nodes)  			//{  			//    if (n.IsAbstract)  			//        continue;  			//    var attribDatas = n.GetCustomAttributesData();  			//    if (attribDatas.Count == 0)  			//        continue;  			//    string name = "";  			//    string descrip = "";  			//    string cat = "";  			//    bool isCompilerGenerated = false;  			//    foreach (CustomAttributeData attribData in attribDatas)  			//    {  			//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  			//        {  			//            name = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  			//        {  			//            descrip = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  			//        {  			//            cat = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  			//        {  			//            isCompilerGenerated = true;  			//        }  			//    }  			//    if (isCompilerGenerated)  			//        continue;  			//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  			//    tw.WriteLine(line);  			//}   			#endregion  		}  	}  } catch (ReflectionTypeLoadException ex) {  	var sb = new StringBuilder ();  	foreach (Exception exSub in ex.LoaderExceptions) {  		sb.AppendLine (exSub.Message);  		if (exSub is FileNotFoundException) {  			var exFileNotFound = exSub as FileNotFoundException;  			if (!string.IsNullOrEmpty (exFileNotFound.FusionLog)) {  				sb.AppendLine ("Fusion Log:");  				sb.AppendLine (exFileNotFound.FusionLog);  			}  		}  		sb.AppendLine ();  	}  	var errorMessage = sb.ToString ();  	Console.WriteLine (errorMessage);  	Console.ReadKey ();  	return;  } catch (Exception ex) {  	Console.WriteLine (ex.Message);  	Console.WriteLine (ex.StackTrace);  	Console.ReadKey ();  	return;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try {  	using (var tw = new StreamWriter (outPath)) {  		tw.WriteLine ("Type Name' Name' Description' Category");  		var nodeDirInfo = new DirectoryInfo (nodesDir);  		var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  		foreach (var nodeLib in nodeLibs) {  			var module = ModuleDefinition.ReadModule (nodeLib.FullName);  			var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  			var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  			if (!typeDefinitions.Any ())  				continue;  			foreach (var nn in typeDefinitions) {  				if (nn.IsAbstract)  					continue;  				if (!nn.HasCustomAttributes)  					continue;  				var name = "";  				var descrip = "";  				var cat = "";  				bool isCompilerGenerated = false;  				foreach (var ca in nn.CustomAttributes) {  					if (ca.AttributeType.Name == "NodeNameAttribute") {  						name = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  						descrip = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  						cat = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  						isCompilerGenerated = true;  					}  				}  				if (isCompilerGenerated)  					continue;  				string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  				//find the port data  				var constructors = nn.Methods.Where (x => x.IsConstructor);  				foreach (var constructor in constructors) {  					if (!constructor.HasBody)  						continue;  					int instructionCount = 0;  					foreach (var instruction in constructor.Body.Instructions) {  						if (instruction.OpCode == OpCodes.Newobj) {  							var methodRef = (MethodReference)instruction.Operand;  							if (methodRef.DeclaringType.Name == "PortData") {  								var nickname = "";  								var description = "";  								if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  									description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  								if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  									nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  								line += string.Format ("'{0}:{1}"' nickname' description);  							}  						}  						instructionCount++;  					}  				}  				tw.WriteLine (line);  			}  			#region using reflection  			//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  			//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  			//foreach (var n in nodes)  			//{  			//    if (n.IsAbstract)  			//        continue;  			//    var attribDatas = n.GetCustomAttributesData();  			//    if (attribDatas.Count == 0)  			//        continue;  			//    string name = "";  			//    string descrip = "";  			//    string cat = "";  			//    bool isCompilerGenerated = false;  			//    foreach (CustomAttributeData attribData in attribDatas)  			//    {  			//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  			//        {  			//            name = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  			//        {  			//            descrip = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  			//        {  			//            cat = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  			//        {  			//            isCompilerGenerated = true;  			//        }  			//    }  			//    if (isCompilerGenerated)  			//        continue;  			//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  			//    tw.WriteLine(line);  			//}   			#endregion  		}  	}  } catch (ReflectionTypeLoadException ex) {  	var sb = new StringBuilder ();  	foreach (Exception exSub in ex.LoaderExceptions) {  		sb.AppendLine (exSub.Message);  		if (exSub is FileNotFoundException) {  			var exFileNotFound = exSub as FileNotFoundException;  			if (!string.IsNullOrEmpty (exFileNotFound.FusionLog)) {  				sb.AppendLine ("Fusion Log:");  				sb.AppendLine (exFileNotFound.FusionLog);  			}  		}  		sb.AppendLine ();  	}  	var errorMessage = sb.ToString ();  	Console.WriteLine (errorMessage);  	Console.ReadKey ();  	return;  } catch (Exception ex) {  	Console.WriteLine (ex.Message);  	Console.WriteLine (ex.StackTrace);  	Console.ReadKey ();  	return;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try {  	using (var tw = new StreamWriter (outPath)) {  		tw.WriteLine ("Type Name' Name' Description' Category");  		var nodeDirInfo = new DirectoryInfo (nodesDir);  		var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  		foreach (var nodeLib in nodeLibs) {  			var module = ModuleDefinition.ReadModule (nodeLib.FullName);  			var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  			var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  			if (!typeDefinitions.Any ())  				continue;  			foreach (var nn in typeDefinitions) {  				if (nn.IsAbstract)  					continue;  				if (!nn.HasCustomAttributes)  					continue;  				var name = "";  				var descrip = "";  				var cat = "";  				bool isCompilerGenerated = false;  				foreach (var ca in nn.CustomAttributes) {  					if (ca.AttributeType.Name == "NodeNameAttribute") {  						name = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  						descrip = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  						cat = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  						isCompilerGenerated = true;  					}  				}  				if (isCompilerGenerated)  					continue;  				string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  				//find the port data  				var constructors = nn.Methods.Where (x => x.IsConstructor);  				foreach (var constructor in constructors) {  					if (!constructor.HasBody)  						continue;  					int instructionCount = 0;  					foreach (var instruction in constructor.Body.Instructions) {  						if (instruction.OpCode == OpCodes.Newobj) {  							var methodRef = (MethodReference)instruction.Operand;  							if (methodRef.DeclaringType.Name == "PortData") {  								var nickname = "";  								var description = "";  								if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  									description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  								if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  									nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  								line += string.Format ("'{0}:{1}"' nickname' description);  							}  						}  						instructionCount++;  					}  				}  				tw.WriteLine (line);  			}  			#region using reflection  			//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  			//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  			//foreach (var n in nodes)  			//{  			//    if (n.IsAbstract)  			//        continue;  			//    var attribDatas = n.GetCustomAttributesData();  			//    if (attribDatas.Count == 0)  			//        continue;  			//    string name = "";  			//    string descrip = "";  			//    string cat = "";  			//    bool isCompilerGenerated = false;  			//    foreach (CustomAttributeData attribData in attribDatas)  			//    {  			//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  			//        {  			//            name = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  			//        {  			//            descrip = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  			//        {  			//            cat = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  			//        {  			//            isCompilerGenerated = true;  			//        }  			//    }  			//    if (isCompilerGenerated)  			//        continue;  			//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  			//    tw.WriteLine(line);  			//}   			#endregion  		}  	}  } catch (ReflectionTypeLoadException ex) {  	var sb = new StringBuilder ();  	foreach (Exception exSub in ex.LoaderExceptions) {  		sb.AppendLine (exSub.Message);  		if (exSub is FileNotFoundException) {  			var exFileNotFound = exSub as FileNotFoundException;  			if (!string.IsNullOrEmpty (exFileNotFound.FusionLog)) {  				sb.AppendLine ("Fusion Log:");  				sb.AppendLine (exFileNotFound.FusionLog);  			}  		}  		sb.AppendLine ();  	}  	var errorMessage = sb.ToString ();  	Console.WriteLine (errorMessage);  	Console.ReadKey ();  	return;  } catch (Exception ex) {  	Console.WriteLine (ex.Message);  	Console.WriteLine (ex.StackTrace);  	Console.ReadKey ();  	return;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try {  	using (var tw = new StreamWriter (outPath)) {  		tw.WriteLine ("Type Name' Name' Description' Category");  		var nodeDirInfo = new DirectoryInfo (nodesDir);  		var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  		foreach (var nodeLib in nodeLibs) {  			var module = ModuleDefinition.ReadModule (nodeLib.FullName);  			var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  			var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  			if (!typeDefinitions.Any ())  				continue;  			foreach (var nn in typeDefinitions) {  				if (nn.IsAbstract)  					continue;  				if (!nn.HasCustomAttributes)  					continue;  				var name = "";  				var descrip = "";  				var cat = "";  				bool isCompilerGenerated = false;  				foreach (var ca in nn.CustomAttributes) {  					if (ca.AttributeType.Name == "NodeNameAttribute") {  						name = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  						descrip = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  						cat = ca.ConstructorArguments [0].Value.ToString ();  					} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  						isCompilerGenerated = true;  					}  				}  				if (isCompilerGenerated)  					continue;  				string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  				//find the port data  				var constructors = nn.Methods.Where (x => x.IsConstructor);  				foreach (var constructor in constructors) {  					if (!constructor.HasBody)  						continue;  					int instructionCount = 0;  					foreach (var instruction in constructor.Body.Instructions) {  						if (instruction.OpCode == OpCodes.Newobj) {  							var methodRef = (MethodReference)instruction.Operand;  							if (methodRef.DeclaringType.Name == "PortData") {  								var nickname = "";  								var description = "";  								if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  									description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  								if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  									nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  								line += string.Format ("'{0}:{1}"' nickname' description);  							}  						}  						instructionCount++;  					}  				}  				tw.WriteLine (line);  			}  			#region using reflection  			//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  			//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  			//foreach (var n in nodes)  			//{  			//    if (n.IsAbstract)  			//        continue;  			//    var attribDatas = n.GetCustomAttributesData();  			//    if (attribDatas.Count == 0)  			//        continue;  			//    string name = "";  			//    string descrip = "";  			//    string cat = "";  			//    bool isCompilerGenerated = false;  			//    foreach (CustomAttributeData attribData in attribDatas)  			//    {  			//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  			//        {  			//            name = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  			//        {  			//            descrip = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  			//        {  			//            cat = attribData.ConstructorArguments[0].Value.ToString();  			//        }  			//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  			//        {  			//            isCompilerGenerated = true;  			//        }  			//    }  			//    if (isCompilerGenerated)  			//        continue;  			//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  			//    tw.WriteLine(line);  			//}   			#endregion  		}  	}  } catch (ReflectionTypeLoadException ex) {  	var sb = new StringBuilder ();  	foreach (Exception exSub in ex.LoaderExceptions) {  		sb.AppendLine (exSub.Message);  		if (exSub is FileNotFoundException) {  			var exFileNotFound = exSub as FileNotFoundException;  			if (!string.IsNullOrEmpty (exFileNotFound.FusionLog)) {  				sb.AppendLine ("Fusion Log:");  				sb.AppendLine (exFileNotFound.FusionLog);  			}  		}  		sb.AppendLine ();  	}  	var errorMessage = sb.ToString ();  	Console.WriteLine (errorMessage);  	Console.ReadKey ();  	return;  } catch (Exception ex) {  	Console.WriteLine (ex.Message);  	Console.WriteLine (ex.StackTrace);  	Console.ReadKey ();  	return;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: using (var tw = new StreamWriter (outPath)) {  	tw.WriteLine ("Type Name' Name' Description' Category");  	var nodeDirInfo = new DirectoryInfo (nodesDir);  	var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  	foreach (var nodeLib in nodeLibs) {  		var module = ModuleDefinition.ReadModule (nodeLib.FullName);  		var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  		var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  		if (!typeDefinitions.Any ())  			continue;  		foreach (var nn in typeDefinitions) {  			if (nn.IsAbstract)  				continue;  			if (!nn.HasCustomAttributes)  				continue;  			var name = "";  			var descrip = "";  			var cat = "";  			bool isCompilerGenerated = false;  			foreach (var ca in nn.CustomAttributes) {  				if (ca.AttributeType.Name == "NodeNameAttribute") {  					name = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  					descrip = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  					cat = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  					isCompilerGenerated = true;  				}  			}  			if (isCompilerGenerated)  				continue;  			string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  			//find the port data  			var constructors = nn.Methods.Where (x => x.IsConstructor);  			foreach (var constructor in constructors) {  				if (!constructor.HasBody)  					continue;  				int instructionCount = 0;  				foreach (var instruction in constructor.Body.Instructions) {  					if (instruction.OpCode == OpCodes.Newobj) {  						var methodRef = (MethodReference)instruction.Operand;  						if (methodRef.DeclaringType.Name == "PortData") {  							var nickname = "";  							var description = "";  							if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  								description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  							if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  								nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  							line += string.Format ("'{0}:{1}"' nickname' description);  						}  					}  					instructionCount++;  				}  			}  			tw.WriteLine (line);  		}  		#region using reflection  		//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  		//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  		//foreach (var n in nodes)  		//{  		//    if (n.IsAbstract)  		//        continue;  		//    var attribDatas = n.GetCustomAttributesData();  		//    if (attribDatas.Count == 0)  		//        continue;  		//    string name = "";  		//    string descrip = "";  		//    string cat = "";  		//    bool isCompilerGenerated = false;  		//    foreach (CustomAttributeData attribData in attribDatas)  		//    {  		//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  		//        {  		//            name = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  		//        {  		//            descrip = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  		//        {  		//            cat = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  		//        {  		//            isCompilerGenerated = true;  		//        }  		//    }  		//    if (isCompilerGenerated)  		//        continue;  		//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  		//    tw.WriteLine(line);  		//}   		#endregion  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: using (var tw = new StreamWriter (outPath)) {  	tw.WriteLine ("Type Name' Name' Description' Category");  	var nodeDirInfo = new DirectoryInfo (nodesDir);  	var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  	foreach (var nodeLib in nodeLibs) {  		var module = ModuleDefinition.ReadModule (nodeLib.FullName);  		var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  		var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  		if (!typeDefinitions.Any ())  			continue;  		foreach (var nn in typeDefinitions) {  			if (nn.IsAbstract)  				continue;  			if (!nn.HasCustomAttributes)  				continue;  			var name = "";  			var descrip = "";  			var cat = "";  			bool isCompilerGenerated = false;  			foreach (var ca in nn.CustomAttributes) {  				if (ca.AttributeType.Name == "NodeNameAttribute") {  					name = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  					descrip = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  					cat = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  					isCompilerGenerated = true;  				}  			}  			if (isCompilerGenerated)  				continue;  			string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  			//find the port data  			var constructors = nn.Methods.Where (x => x.IsConstructor);  			foreach (var constructor in constructors) {  				if (!constructor.HasBody)  					continue;  				int instructionCount = 0;  				foreach (var instruction in constructor.Body.Instructions) {  					if (instruction.OpCode == OpCodes.Newobj) {  						var methodRef = (MethodReference)instruction.Operand;  						if (methodRef.DeclaringType.Name == "PortData") {  							var nickname = "";  							var description = "";  							if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  								description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  							if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  								nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  							line += string.Format ("'{0}:{1}"' nickname' description);  						}  					}  					instructionCount++;  				}  			}  			tw.WriteLine (line);  		}  		#region using reflection  		//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  		//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  		//foreach (var n in nodes)  		//{  		//    if (n.IsAbstract)  		//        continue;  		//    var attribDatas = n.GetCustomAttributesData();  		//    if (attribDatas.Count == 0)  		//        continue;  		//    string name = "";  		//    string descrip = "";  		//    string cat = "";  		//    bool isCompilerGenerated = false;  		//    foreach (CustomAttributeData attribData in attribDatas)  		//    {  		//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  		//        {  		//            name = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  		//        {  		//            descrip = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  		//        {  		//            cat = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  		//        {  		//            isCompilerGenerated = true;  		//        }  		//    }  		//    if (isCompilerGenerated)  		//        continue;  		//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  		//    tw.WriteLine(line);  		//}   		#endregion  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: using (var tw = new StreamWriter (outPath)) {  	tw.WriteLine ("Type Name' Name' Description' Category");  	var nodeDirInfo = new DirectoryInfo (nodesDir);  	var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  	foreach (var nodeLib in nodeLibs) {  		var module = ModuleDefinition.ReadModule (nodeLib.FullName);  		var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  		var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  		if (!typeDefinitions.Any ())  			continue;  		foreach (var nn in typeDefinitions) {  			if (nn.IsAbstract)  				continue;  			if (!nn.HasCustomAttributes)  				continue;  			var name = "";  			var descrip = "";  			var cat = "";  			bool isCompilerGenerated = false;  			foreach (var ca in nn.CustomAttributes) {  				if (ca.AttributeType.Name == "NodeNameAttribute") {  					name = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  					descrip = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  					cat = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  					isCompilerGenerated = true;  				}  			}  			if (isCompilerGenerated)  				continue;  			string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  			//find the port data  			var constructors = nn.Methods.Where (x => x.IsConstructor);  			foreach (var constructor in constructors) {  				if (!constructor.HasBody)  					continue;  				int instructionCount = 0;  				foreach (var instruction in constructor.Body.Instructions) {  					if (instruction.OpCode == OpCodes.Newobj) {  						var methodRef = (MethodReference)instruction.Operand;  						if (methodRef.DeclaringType.Name == "PortData") {  							var nickname = "";  							var description = "";  							if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  								description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  							if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  								nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  							line += string.Format ("'{0}:{1}"' nickname' description);  						}  					}  					instructionCount++;  				}  			}  			tw.WriteLine (line);  		}  		#region using reflection  		//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  		//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  		//foreach (var n in nodes)  		//{  		//    if (n.IsAbstract)  		//        continue;  		//    var attribDatas = n.GetCustomAttributesData();  		//    if (attribDatas.Count == 0)  		//        continue;  		//    string name = "";  		//    string descrip = "";  		//    string cat = "";  		//    bool isCompilerGenerated = false;  		//    foreach (CustomAttributeData attribData in attribDatas)  		//    {  		//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  		//        {  		//            name = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  		//        {  		//            descrip = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  		//        {  		//            cat = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  		//        {  		//            isCompilerGenerated = true;  		//        }  		//    }  		//    if (isCompilerGenerated)  		//        continue;  		//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  		//    tw.WriteLine(line);  		//}   		#endregion  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: using (var tw = new StreamWriter (outPath)) {  	tw.WriteLine ("Type Name' Name' Description' Category");  	var nodeDirInfo = new DirectoryInfo (nodesDir);  	var nodeLibs = nodeDirInfo.GetFiles ("*.dll");  	foreach (var nodeLib in nodeLibs) {  		var module = ModuleDefinition.ReadModule (nodeLib.FullName);  		var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  		var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  		if (!typeDefinitions.Any ())  			continue;  		foreach (var nn in typeDefinitions) {  			if (nn.IsAbstract)  				continue;  			if (!nn.HasCustomAttributes)  				continue;  			var name = "";  			var descrip = "";  			var cat = "";  			bool isCompilerGenerated = false;  			foreach (var ca in nn.CustomAttributes) {  				if (ca.AttributeType.Name == "NodeNameAttribute") {  					name = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  					descrip = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  					cat = ca.ConstructorArguments [0].Value.ToString ();  				} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  					isCompilerGenerated = true;  				}  			}  			if (isCompilerGenerated)  				continue;  			string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  			//find the port data  			var constructors = nn.Methods.Where (x => x.IsConstructor);  			foreach (var constructor in constructors) {  				if (!constructor.HasBody)  					continue;  				int instructionCount = 0;  				foreach (var instruction in constructor.Body.Instructions) {  					if (instruction.OpCode == OpCodes.Newobj) {  						var methodRef = (MethodReference)instruction.Operand;  						if (methodRef.DeclaringType.Name == "PortData") {  							var nickname = "";  							var description = "";  							if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  								description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  							if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  								nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  							line += string.Format ("'{0}:{1}"' nickname' description);  						}  					}  					instructionCount++;  				}  			}  			tw.WriteLine (line);  		}  		#region using reflection  		//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  		//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  		//foreach (var n in nodes)  		//{  		//    if (n.IsAbstract)  		//        continue;  		//    var attribDatas = n.GetCustomAttributesData();  		//    if (attribDatas.Count == 0)  		//        continue;  		//    string name = "";  		//    string descrip = "";  		//    string cat = "";  		//    bool isCompilerGenerated = false;  		//    foreach (CustomAttributeData attribData in attribDatas)  		//    {  		//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  		//        {  		//            name = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  		//        {  		//            descrip = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  		//        {  		//            cat = attribData.ConstructorArguments[0].Value.ToString();  		//        }  		//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  		//        {  		//            isCompilerGenerated = true;  		//        }  		//    }  		//    if (isCompilerGenerated)  		//        continue;  		//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  		//    tw.WriteLine(line);  		//}   		#endregion  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nodeLib in nodeLibs) {  	var module = ModuleDefinition.ReadModule (nodeLib.FullName);  	var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  	var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  	if (!typeDefinitions.Any ())  		continue;  	foreach (var nn in typeDefinitions) {  		if (nn.IsAbstract)  			continue;  		if (!nn.HasCustomAttributes)  			continue;  		var name = "";  		var descrip = "";  		var cat = "";  		bool isCompilerGenerated = false;  		foreach (var ca in nn.CustomAttributes) {  			if (ca.AttributeType.Name == "NodeNameAttribute") {  				name = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  				descrip = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  				cat = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  				isCompilerGenerated = true;  			}  		}  		if (isCompilerGenerated)  			continue;  		string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  		//find the port data  		var constructors = nn.Methods.Where (x => x.IsConstructor);  		foreach (var constructor in constructors) {  			if (!constructor.HasBody)  				continue;  			int instructionCount = 0;  			foreach (var instruction in constructor.Body.Instructions) {  				if (instruction.OpCode == OpCodes.Newobj) {  					var methodRef = (MethodReference)instruction.Operand;  					if (methodRef.DeclaringType.Name == "PortData") {  						var nickname = "";  						var description = "";  						if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  							description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  						if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  							nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  						line += string.Format ("'{0}:{1}"' nickname' description);  					}  				}  				instructionCount++;  			}  		}  		tw.WriteLine (line);  	}  	#region using reflection  	//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  	//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  	//foreach (var n in nodes)  	//{  	//    if (n.IsAbstract)  	//        continue;  	//    var attribDatas = n.GetCustomAttributesData();  	//    if (attribDatas.Count == 0)  	//        continue;  	//    string name = "";  	//    string descrip = "";  	//    string cat = "";  	//    bool isCompilerGenerated = false;  	//    foreach (CustomAttributeData attribData in attribDatas)  	//    {  	//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  	//        {  	//            name = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  	//        {  	//            descrip = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  	//        {  	//            cat = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  	//        {  	//            isCompilerGenerated = true;  	//        }  	//    }  	//    if (isCompilerGenerated)  	//        continue;  	//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  	//    tw.WriteLine(line);  	//}   	#endregion  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nodeLib in nodeLibs) {  	var module = ModuleDefinition.ReadModule (nodeLib.FullName);  	var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  	var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  	if (!typeDefinitions.Any ())  		continue;  	foreach (var nn in typeDefinitions) {  		if (nn.IsAbstract)  			continue;  		if (!nn.HasCustomAttributes)  			continue;  		var name = "";  		var descrip = "";  		var cat = "";  		bool isCompilerGenerated = false;  		foreach (var ca in nn.CustomAttributes) {  			if (ca.AttributeType.Name == "NodeNameAttribute") {  				name = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  				descrip = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  				cat = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  				isCompilerGenerated = true;  			}  		}  		if (isCompilerGenerated)  			continue;  		string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  		//find the port data  		var constructors = nn.Methods.Where (x => x.IsConstructor);  		foreach (var constructor in constructors) {  			if (!constructor.HasBody)  				continue;  			int instructionCount = 0;  			foreach (var instruction in constructor.Body.Instructions) {  				if (instruction.OpCode == OpCodes.Newobj) {  					var methodRef = (MethodReference)instruction.Operand;  					if (methodRef.DeclaringType.Name == "PortData") {  						var nickname = "";  						var description = "";  						if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  							description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  						if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  							nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  						line += string.Format ("'{0}:{1}"' nickname' description);  					}  				}  				instructionCount++;  			}  		}  		tw.WriteLine (line);  	}  	#region using reflection  	//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  	//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  	//foreach (var n in nodes)  	//{  	//    if (n.IsAbstract)  	//        continue;  	//    var attribDatas = n.GetCustomAttributesData();  	//    if (attribDatas.Count == 0)  	//        continue;  	//    string name = "";  	//    string descrip = "";  	//    string cat = "";  	//    bool isCompilerGenerated = false;  	//    foreach (CustomAttributeData attribData in attribDatas)  	//    {  	//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  	//        {  	//            name = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  	//        {  	//            descrip = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  	//        {  	//            cat = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  	//        {  	//            isCompilerGenerated = true;  	//        }  	//    }  	//    if (isCompilerGenerated)  	//        continue;  	//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  	//    tw.WriteLine(line);  	//}   	#endregion  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nodeLib in nodeLibs) {  	var module = ModuleDefinition.ReadModule (nodeLib.FullName);  	var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  	var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  	if (!typeDefinitions.Any ())  		continue;  	foreach (var nn in typeDefinitions) {  		if (nn.IsAbstract)  			continue;  		if (!nn.HasCustomAttributes)  			continue;  		var name = "";  		var descrip = "";  		var cat = "";  		bool isCompilerGenerated = false;  		foreach (var ca in nn.CustomAttributes) {  			if (ca.AttributeType.Name == "NodeNameAttribute") {  				name = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  				descrip = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  				cat = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  				isCompilerGenerated = true;  			}  		}  		if (isCompilerGenerated)  			continue;  		string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  		//find the port data  		var constructors = nn.Methods.Where (x => x.IsConstructor);  		foreach (var constructor in constructors) {  			if (!constructor.HasBody)  				continue;  			int instructionCount = 0;  			foreach (var instruction in constructor.Body.Instructions) {  				if (instruction.OpCode == OpCodes.Newobj) {  					var methodRef = (MethodReference)instruction.Operand;  					if (methodRef.DeclaringType.Name == "PortData") {  						var nickname = "";  						var description = "";  						if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  							description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  						if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  							nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  						line += string.Format ("'{0}:{1}"' nickname' description);  					}  				}  				instructionCount++;  			}  		}  		tw.WriteLine (line);  	}  	#region using reflection  	//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  	//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  	//foreach (var n in nodes)  	//{  	//    if (n.IsAbstract)  	//        continue;  	//    var attribDatas = n.GetCustomAttributesData();  	//    if (attribDatas.Count == 0)  	//        continue;  	//    string name = "";  	//    string descrip = "";  	//    string cat = "";  	//    bool isCompilerGenerated = false;  	//    foreach (CustomAttributeData attribData in attribDatas)  	//    {  	//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  	//        {  	//            name = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  	//        {  	//            descrip = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  	//        {  	//            cat = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  	//        {  	//            isCompilerGenerated = true;  	//        }  	//    }  	//    if (isCompilerGenerated)  	//        continue;  	//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  	//    tw.WriteLine(line);  	//}   	#endregion  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nodeLib in nodeLibs) {  	var module = ModuleDefinition.ReadModule (nodeLib.FullName);  	var cecilNodes = module.Types.Where (x => x.Namespace == "Dynamo.Nodes");  	var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray ();  	if (!typeDefinitions.Any ())  		continue;  	foreach (var nn in typeDefinitions) {  		if (nn.IsAbstract)  			continue;  		if (!nn.HasCustomAttributes)  			continue;  		var name = "";  		var descrip = "";  		var cat = "";  		bool isCompilerGenerated = false;  		foreach (var ca in nn.CustomAttributes) {  			if (ca.AttributeType.Name == "NodeNameAttribute") {  				name = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  				descrip = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  				cat = ca.ConstructorArguments [0].Value.ToString ();  			} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  				isCompilerGenerated = true;  			}  		}  		if (isCompilerGenerated)  			continue;  		string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  		//find the port data  		var constructors = nn.Methods.Where (x => x.IsConstructor);  		foreach (var constructor in constructors) {  			if (!constructor.HasBody)  				continue;  			int instructionCount = 0;  			foreach (var instruction in constructor.Body.Instructions) {  				if (instruction.OpCode == OpCodes.Newobj) {  					var methodRef = (MethodReference)instruction.Operand;  					if (methodRef.DeclaringType.Name == "PortData") {  						var nickname = "";  						var description = "";  						if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  							description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  						if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  							nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  						line += string.Format ("'{0}:{1}"' nickname' description);  					}  				}  				instructionCount++;  			}  		}  		tw.WriteLine (line);  	}  	#region using reflection  	//var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);  	//var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");  	//foreach (var n in nodes)  	//{  	//    if (n.IsAbstract)  	//        continue;  	//    var attribDatas = n.GetCustomAttributesData();  	//    if (attribDatas.Count == 0)  	//        continue;  	//    string name = "";  	//    string descrip = "";  	//    string cat = "";  	//    bool isCompilerGenerated = false;  	//    foreach (CustomAttributeData attribData in attribDatas)  	//    {  	//        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")  	//        {  	//            name = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")  	//        {  	//            descrip = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")  	//        {  	//            cat = attribData.ConstructorArguments[0].Value.ToString();  	//        }  	//        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")  	//        {  	//            isCompilerGenerated = true;  	//        }  	//    }  	//    if (isCompilerGenerated)  	//        continue;  	//    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);  	//    tw.WriteLine(line);  	//}   	#endregion  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nn in typeDefinitions) {  	if (nn.IsAbstract)  		continue;  	if (!nn.HasCustomAttributes)  		continue;  	var name = "";  	var descrip = "";  	var cat = "";  	bool isCompilerGenerated = false;  	foreach (var ca in nn.CustomAttributes) {  		if (ca.AttributeType.Name == "NodeNameAttribute") {  			name = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  			descrip = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  			cat = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  			isCompilerGenerated = true;  		}  	}  	if (isCompilerGenerated)  		continue;  	string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  	//find the port data  	var constructors = nn.Methods.Where (x => x.IsConstructor);  	foreach (var constructor in constructors) {  		if (!constructor.HasBody)  			continue;  		int instructionCount = 0;  		foreach (var instruction in constructor.Body.Instructions) {  			if (instruction.OpCode == OpCodes.Newobj) {  				var methodRef = (MethodReference)instruction.Operand;  				if (methodRef.DeclaringType.Name == "PortData") {  					var nickname = "";  					var description = "";  					if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  						description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  					if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  						nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  					line += string.Format ("'{0}:{1}"' nickname' description);  				}  			}  			instructionCount++;  		}  	}  	tw.WriteLine (line);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nn in typeDefinitions) {  	if (nn.IsAbstract)  		continue;  	if (!nn.HasCustomAttributes)  		continue;  	var name = "";  	var descrip = "";  	var cat = "";  	bool isCompilerGenerated = false;  	foreach (var ca in nn.CustomAttributes) {  		if (ca.AttributeType.Name == "NodeNameAttribute") {  			name = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  			descrip = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  			cat = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  			isCompilerGenerated = true;  		}  	}  	if (isCompilerGenerated)  		continue;  	string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  	//find the port data  	var constructors = nn.Methods.Where (x => x.IsConstructor);  	foreach (var constructor in constructors) {  		if (!constructor.HasBody)  			continue;  		int instructionCount = 0;  		foreach (var instruction in constructor.Body.Instructions) {  			if (instruction.OpCode == OpCodes.Newobj) {  				var methodRef = (MethodReference)instruction.Operand;  				if (methodRef.DeclaringType.Name == "PortData") {  					var nickname = "";  					var description = "";  					if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  						description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  					if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  						nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  					line += string.Format ("'{0}:{1}"' nickname' description);  				}  			}  			instructionCount++;  		}  	}  	tw.WriteLine (line);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nn in typeDefinitions) {  	if (nn.IsAbstract)  		continue;  	if (!nn.HasCustomAttributes)  		continue;  	var name = "";  	var descrip = "";  	var cat = "";  	bool isCompilerGenerated = false;  	foreach (var ca in nn.CustomAttributes) {  		if (ca.AttributeType.Name == "NodeNameAttribute") {  			name = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  			descrip = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  			cat = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  			isCompilerGenerated = true;  		}  	}  	if (isCompilerGenerated)  		continue;  	string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  	//find the port data  	var constructors = nn.Methods.Where (x => x.IsConstructor);  	foreach (var constructor in constructors) {  		if (!constructor.HasBody)  			continue;  		int instructionCount = 0;  		foreach (var instruction in constructor.Body.Instructions) {  			if (instruction.OpCode == OpCodes.Newobj) {  				var methodRef = (MethodReference)instruction.Operand;  				if (methodRef.DeclaringType.Name == "PortData") {  					var nickname = "";  					var description = "";  					if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  						description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  					if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  						nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  					line += string.Format ("'{0}:{1}"' nickname' description);  				}  			}  			instructionCount++;  		}  	}  	tw.WriteLine (line);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var nn in typeDefinitions) {  	if (nn.IsAbstract)  		continue;  	if (!nn.HasCustomAttributes)  		continue;  	var name = "";  	var descrip = "";  	var cat = "";  	bool isCompilerGenerated = false;  	foreach (var ca in nn.CustomAttributes) {  		if (ca.AttributeType.Name == "NodeNameAttribute") {  			name = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeDescriptionAttribute") {  			descrip = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "NodeCategoryAttribute") {  			cat = ca.ConstructorArguments [0].Value.ToString ();  		} else if (ca.AttributeType.Name == "CompilerGeneratedAttribute") {  			isCompilerGenerated = true;  		}  	}  	if (isCompilerGenerated)  		continue;  	string line = string.Format ("{0}'{1}'{2}'{3}"' nn.ToString ()' name' descrip.Replace ("'"' " ")' cat);  	//find the port data  	var constructors = nn.Methods.Where (x => x.IsConstructor);  	foreach (var constructor in constructors) {  		if (!constructor.HasBody)  			continue;  		int instructionCount = 0;  		foreach (var instruction in constructor.Body.Instructions) {  			if (instruction.OpCode == OpCodes.Newobj) {  				var methodRef = (MethodReference)instruction.Operand;  				if (methodRef.DeclaringType.Name == "PortData") {  					var nickname = "";  					var description = "";  					if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  						description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  					if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  						nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  					line += string.Format ("'{0}:{1}"' nickname' description);  				}  			}  			instructionCount++;  		}  	}  	tw.WriteLine (line);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var constructor in constructors) {  	if (!constructor.HasBody)  		continue;  	int instructionCount = 0;  	foreach (var instruction in constructor.Body.Instructions) {  		if (instruction.OpCode == OpCodes.Newobj) {  			var methodRef = (MethodReference)instruction.Operand;  			if (methodRef.DeclaringType.Name == "PortData") {  				var nickname = "";  				var description = "";  				if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  					description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  				if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  					nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  				line += string.Format ("'{0}:{1}"' nickname' description);  			}  		}  		instructionCount++;  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var constructor in constructors) {  	if (!constructor.HasBody)  		continue;  	int instructionCount = 0;  	foreach (var instruction in constructor.Body.Instructions) {  		if (instruction.OpCode == OpCodes.Newobj) {  			var methodRef = (MethodReference)instruction.Operand;  			if (methodRef.DeclaringType.Name == "PortData") {  				var nickname = "";  				var description = "";  				if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  					description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  				if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  					nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  				line += string.Format ("'{0}:{1}"' nickname' description);  			}  		}  		instructionCount++;  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var constructor in constructors) {  	if (!constructor.HasBody)  		continue;  	int instructionCount = 0;  	foreach (var instruction in constructor.Body.Instructions) {  		if (instruction.OpCode == OpCodes.Newobj) {  			var methodRef = (MethodReference)instruction.Operand;  			if (methodRef.DeclaringType.Name == "PortData") {  				var nickname = "";  				var description = "";  				if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  					description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  				if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  					nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  				line += string.Format ("'{0}:{1}"' nickname' description);  			}  		}  		instructionCount++;  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var constructor in constructors) {  	if (!constructor.HasBody)  		continue;  	int instructionCount = 0;  	foreach (var instruction in constructor.Body.Instructions) {  		if (instruction.OpCode == OpCodes.Newobj) {  			var methodRef = (MethodReference)instruction.Operand;  			if (methodRef.DeclaringType.Name == "PortData") {  				var nickname = "";  				var description = "";  				if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  					description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  				if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  					nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  				line += string.Format ("'{0}:{1}"' nickname' description);  			}  		}  		instructionCount++;  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var instruction in constructor.Body.Instructions) {  	if (instruction.OpCode == OpCodes.Newobj) {  		var methodRef = (MethodReference)instruction.Operand;  		if (methodRef.DeclaringType.Name == "PortData") {  			var nickname = "";  			var description = "";  			if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  				description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  			if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  				nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  			line += string.Format ("'{0}:{1}"' nickname' description);  		}  	}  	instructionCount++;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var instruction in constructor.Body.Instructions) {  	if (instruction.OpCode == OpCodes.Newobj) {  		var methodRef = (MethodReference)instruction.Operand;  		if (methodRef.DeclaringType.Name == "PortData") {  			var nickname = "";  			var description = "";  			if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  				description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  			if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  				nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  			line += string.Format ("'{0}:{1}"' nickname' description);  		}  	}  	instructionCount++;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var instruction in constructor.Body.Instructions) {  	if (instruction.OpCode == OpCodes.Newobj) {  		var methodRef = (MethodReference)instruction.Operand;  		if (methodRef.DeclaringType.Name == "PortData") {  			var nickname = "";  			var description = "";  			if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  				description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  			if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  				nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  			line += string.Format ("'{0}:{1}"' nickname' description);  		}  	}  	instructionCount++;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: foreach (var instruction in constructor.Body.Instructions) {  	if (instruction.OpCode == OpCodes.Newobj) {  		var methodRef = (MethodReference)instruction.Operand;  		if (methodRef.DeclaringType.Name == "PortData") {  			var nickname = "";  			var description = "";  			if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  				description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  			if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  				nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  			line += string.Format ("'{0}:{1}"' nickname' description);  		}  	}  	instructionCount++;  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (instruction.OpCode == OpCodes.Newobj) {  	var methodRef = (MethodReference)instruction.Operand;  	if (methodRef.DeclaringType.Name == "PortData") {  		var nickname = "";  		var description = "";  		if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  			description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  		if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  			nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  		line += string.Format ("'{0}:{1}"' nickname' description);  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (instruction.OpCode == OpCodes.Newobj) {  	var methodRef = (MethodReference)instruction.Operand;  	if (methodRef.DeclaringType.Name == "PortData") {  		var nickname = "";  		var description = "";  		if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  			description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  		if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  			nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  		line += string.Format ("'{0}:{1}"' nickname' description);  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (instruction.OpCode == OpCodes.Newobj) {  	var methodRef = (MethodReference)instruction.Operand;  	if (methodRef.DeclaringType.Name == "PortData") {  		var nickname = "";  		var description = "";  		if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  			description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  		if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  			nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  		line += string.Format ("'{0}:{1}"' nickname' description);  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (instruction.OpCode == OpCodes.Newobj) {  	var methodRef = (MethodReference)instruction.Operand;  	if (methodRef.DeclaringType.Name == "PortData") {  		var nickname = "";  		var description = "";  		if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  			description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  		if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  			nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  		line += string.Format ("'{0}:{1}"' nickname' description);  	}  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (methodRef.DeclaringType.Name == "PortData") {  	var nickname = "";  	var description = "";  	if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  		description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  	if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  		nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  	line += string.Format ("'{0}:{1}"' nickname' description);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (methodRef.DeclaringType.Name == "PortData") {  	var nickname = "";  	var description = "";  	if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  		description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  	if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  		nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  	line += string.Format ("'{0}:{1}"' nickname' description);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (methodRef.DeclaringType.Name == "PortData") {  	var nickname = "";  	var description = "";  	if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  		description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  	if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  		nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  	line += string.Format ("'{0}:{1}"' nickname' description);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (methodRef.DeclaringType.Name == "PortData") {  	var nickname = "";  	var description = "";  	if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  		description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  	if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  		nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  	line += string.Format ("'{0}:{1}"' nickname' description);  }  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  	description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (constructor.Body.Instructions [instructionCount - 4].Operand != null)  	description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: description = constructor.Body.Instructions [instructionCount - 4].Operand.ToString ();  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  	nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: if (constructor.Body.Instructions [instructionCount - 5].Operand != null)  	nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  
Magic Number,NodeDumper,Program,F:\newReposMay17\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: nickname = constructor.Body.Instructions [instructionCount - 5].Operand.ToString ();  
