Implementation smell,Namespace,Class,File,Method,Description
Long Method,NodeDumper,Program,C:\repos\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The method has 169 lines of code.
Magic Number,NodeDumper,Program,C:\repos\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try              {                  using (var tw = new StreamWriter(outPath))                  {                      tw.WriteLine("Type Name' Name' Description' Category");                        var nodeDirInfo = new DirectoryInfo(nodesDir);                      var nodeLibs = nodeDirInfo.GetFiles("*.dll");                        foreach (var nodeLib in nodeLibs)                      {                          var module = ModuleDefinition.ReadModule(nodeLib.FullName);                          var cecilNodes = module.Types.Where(x => x.Namespace == "Dynamo.Nodes");                          var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray();                          if (!typeDefinitions.Any())                              continue;                            foreach (var nn in typeDefinitions)                          {                              if(nn.IsAbstract)                                  continue;                                if (!nn.HasCustomAttributes)                                  continue;                                var name = "";                              var descrip = "";                              var cat = "";                                bool isCompilerGenerated = false;                                foreach (var ca in nn.CustomAttributes)                              {                                  if (ca.AttributeType.Name == "NodeNameAttribute")                                  {                                      name = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeDescriptionAttribute")                                  {                                      descrip = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeCategoryAttribute")                                  {                                      cat = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "CompilerGeneratedAttribute")                                  {                                      isCompilerGenerated = true;                                  }                              }                                if (isCompilerGenerated)                                  continue;                                string line = string.Format("{0}'{1}'{2}'{3}"' nn.ToString()' name' descrip.Replace("'"' " ")' cat);                                //find the port data                              var constructors = nn.Methods.Where(x => x.IsConstructor);                              foreach (var constructor in constructors)                              {                                  if (!constructor.HasBody)                                      continue;                                    int instructionCount = 0;                                  foreach (var instruction in constructor.Body.Instructions)                                  {                                      if (instruction.OpCode == OpCodes.Newobj)                                      {                                          var methodRef = (MethodReference)instruction.Operand;                                          if (methodRef.DeclaringType.Name == "PortData")                                          {                                              var nickname = "";                                              var description = "";                                              if (constructor.Body.Instructions[instructionCount - 4].Operand != null)                                                  description = constructor.Body.Instructions[instructionCount - 4].Operand.ToString();                                              if (constructor.Body.Instructions[instructionCount - 5].Operand != null)                                                  nickname = constructor.Body.Instructions[instructionCount - 5].Operand.ToString();                                              line += string.Format("'{0}:{1}"' nickname' description);                                          }                                      }                                      instructionCount++;                                  }                              }                                tw.WriteLine(line);                          }                            #region using reflection                          //var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);                          //var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");                                                    //foreach (var n in nodes)                          //{                          //    if (n.IsAbstract)                          //        continue;                            //    var attribDatas = n.GetCustomAttributesData();                          //    if (attribDatas.Count == 0)                          //        continue;                            //    string name = "";                          //    string descrip = "";                          //    string cat = "";                            //    bool isCompilerGenerated = false;                            //    foreach (CustomAttributeData attribData in attribDatas)                          //    {                          //        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")                          //        {                          //            name = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")                          //        {                          //            descrip = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")                          //        {                          //            cat = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")                          //        {                          //            isCompilerGenerated = true;                          //        }                          //    }                            //    if (isCompilerGenerated)                          //        continue;                            //    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);                            //    tw.WriteLine(line);                          //}                           #endregion                      }                  }              }              catch (ReflectionTypeLoadException ex)              {                  var sb = new StringBuilder();                  foreach (Exception exSub in ex.LoaderExceptions)                  {                      sb.AppendLine(exSub.Message);                      if (exSub is FileNotFoundException)                      {                          var exFileNotFound = exSub as FileNotFoundException;                          if (!string.IsNullOrEmpty(exFileNotFound.FusionLog))                          {                              sb.AppendLine("Fusion Log:");                              sb.AppendLine(exFileNotFound.FusionLog);                          }                      }                      sb.AppendLine();                  }                  var errorMessage = sb.ToString();                  Console.WriteLine(errorMessage);                  Console.ReadKey();                  return;              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);                  Console.WriteLine(ex.StackTrace);                  Console.ReadKey();                  return;              }
Magic Number,NodeDumper,Program,C:\repos\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try              {                  using (var tw = new StreamWriter(outPath))                  {                      tw.WriteLine("Type Name' Name' Description' Category");                        var nodeDirInfo = new DirectoryInfo(nodesDir);                      var nodeLibs = nodeDirInfo.GetFiles("*.dll");                        foreach (var nodeLib in nodeLibs)                      {                          var module = ModuleDefinition.ReadModule(nodeLib.FullName);                          var cecilNodes = module.Types.Where(x => x.Namespace == "Dynamo.Nodes");                          var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray();                          if (!typeDefinitions.Any())                              continue;                            foreach (var nn in typeDefinitions)                          {                              if(nn.IsAbstract)                                  continue;                                if (!nn.HasCustomAttributes)                                  continue;                                var name = "";                              var descrip = "";                              var cat = "";                                bool isCompilerGenerated = false;                                foreach (var ca in nn.CustomAttributes)                              {                                  if (ca.AttributeType.Name == "NodeNameAttribute")                                  {                                      name = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeDescriptionAttribute")                                  {                                      descrip = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeCategoryAttribute")                                  {                                      cat = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "CompilerGeneratedAttribute")                                  {                                      isCompilerGenerated = true;                                  }                              }                                if (isCompilerGenerated)                                  continue;                                string line = string.Format("{0}'{1}'{2}'{3}"' nn.ToString()' name' descrip.Replace("'"' " ")' cat);                                //find the port data                              var constructors = nn.Methods.Where(x => x.IsConstructor);                              foreach (var constructor in constructors)                              {                                  if (!constructor.HasBody)                                      continue;                                    int instructionCount = 0;                                  foreach (var instruction in constructor.Body.Instructions)                                  {                                      if (instruction.OpCode == OpCodes.Newobj)                                      {                                          var methodRef = (MethodReference)instruction.Operand;                                          if (methodRef.DeclaringType.Name == "PortData")                                          {                                              var nickname = "";                                              var description = "";                                              if (constructor.Body.Instructions[instructionCount - 4].Operand != null)                                                  description = constructor.Body.Instructions[instructionCount - 4].Operand.ToString();                                              if (constructor.Body.Instructions[instructionCount - 5].Operand != null)                                                  nickname = constructor.Body.Instructions[instructionCount - 5].Operand.ToString();                                              line += string.Format("'{0}:{1}"' nickname' description);                                          }                                      }                                      instructionCount++;                                  }                              }                                tw.WriteLine(line);                          }                            #region using reflection                          //var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);                          //var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");                                                    //foreach (var n in nodes)                          //{                          //    if (n.IsAbstract)                          //        continue;                            //    var attribDatas = n.GetCustomAttributesData();                          //    if (attribDatas.Count == 0)                          //        continue;                            //    string name = "";                          //    string descrip = "";                          //    string cat = "";                            //    bool isCompilerGenerated = false;                            //    foreach (CustomAttributeData attribData in attribDatas)                          //    {                          //        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")                          //        {                          //            name = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")                          //        {                          //            descrip = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")                          //        {                          //            cat = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")                          //        {                          //            isCompilerGenerated = true;                          //        }                          //    }                            //    if (isCompilerGenerated)                          //        continue;                            //    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);                            //    tw.WriteLine(line);                          //}                           #endregion                      }                  }              }              catch (ReflectionTypeLoadException ex)              {                  var sb = new StringBuilder();                  foreach (Exception exSub in ex.LoaderExceptions)                  {                      sb.AppendLine(exSub.Message);                      if (exSub is FileNotFoundException)                      {                          var exFileNotFound = exSub as FileNotFoundException;                          if (!string.IsNullOrEmpty(exFileNotFound.FusionLog))                          {                              sb.AppendLine("Fusion Log:");                              sb.AppendLine(exFileNotFound.FusionLog);                          }                      }                      sb.AppendLine();                  }                  var errorMessage = sb.ToString();                  Console.WriteLine(errorMessage);                  Console.ReadKey();                  return;              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);                  Console.WriteLine(ex.StackTrace);                  Console.ReadKey();                  return;              }
Magic Number,NodeDumper,Program,C:\repos\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try              {                  using (var tw = new StreamWriter(outPath))                  {                      tw.WriteLine("Type Name' Name' Description' Category");                        var nodeDirInfo = new DirectoryInfo(nodesDir);                      var nodeLibs = nodeDirInfo.GetFiles("*.dll");                        foreach (var nodeLib in nodeLibs)                      {                          var module = ModuleDefinition.ReadModule(nodeLib.FullName);                          var cecilNodes = module.Types.Where(x => x.Namespace == "Dynamo.Nodes");                          var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray();                          if (!typeDefinitions.Any())                              continue;                            foreach (var nn in typeDefinitions)                          {                              if(nn.IsAbstract)                                  continue;                                if (!nn.HasCustomAttributes)                                  continue;                                var name = "";                              var descrip = "";                              var cat = "";                                bool isCompilerGenerated = false;                                foreach (var ca in nn.CustomAttributes)                              {                                  if (ca.AttributeType.Name == "NodeNameAttribute")                                  {                                      name = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeDescriptionAttribute")                                  {                                      descrip = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeCategoryAttribute")                                  {                                      cat = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "CompilerGeneratedAttribute")                                  {                                      isCompilerGenerated = true;                                  }                              }                                if (isCompilerGenerated)                                  continue;                                string line = string.Format("{0}'{1}'{2}'{3}"' nn.ToString()' name' descrip.Replace("'"' " ")' cat);                                //find the port data                              var constructors = nn.Methods.Where(x => x.IsConstructor);                              foreach (var constructor in constructors)                              {                                  if (!constructor.HasBody)                                      continue;                                    int instructionCount = 0;                                  foreach (var instruction in constructor.Body.Instructions)                                  {                                      if (instruction.OpCode == OpCodes.Newobj)                                      {                                          var methodRef = (MethodReference)instruction.Operand;                                          if (methodRef.DeclaringType.Name == "PortData")                                          {                                              var nickname = "";                                              var description = "";                                              if (constructor.Body.Instructions[instructionCount - 4].Operand != null)                                                  description = constructor.Body.Instructions[instructionCount - 4].Operand.ToString();                                              if (constructor.Body.Instructions[instructionCount - 5].Operand != null)                                                  nickname = constructor.Body.Instructions[instructionCount - 5].Operand.ToString();                                              line += string.Format("'{0}:{1}"' nickname' description);                                          }                                      }                                      instructionCount++;                                  }                              }                                tw.WriteLine(line);                          }                            #region using reflection                          //var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);                          //var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");                                                    //foreach (var n in nodes)                          //{                          //    if (n.IsAbstract)                          //        continue;                            //    var attribDatas = n.GetCustomAttributesData();                          //    if (attribDatas.Count == 0)                          //        continue;                            //    string name = "";                          //    string descrip = "";                          //    string cat = "";                            //    bool isCompilerGenerated = false;                            //    foreach (CustomAttributeData attribData in attribDatas)                          //    {                          //        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")                          //        {                          //            name = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")                          //        {                          //            descrip = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")                          //        {                          //            cat = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")                          //        {                          //            isCompilerGenerated = true;                          //        }                          //    }                            //    if (isCompilerGenerated)                          //        continue;                            //    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);                            //    tw.WriteLine(line);                          //}                           #endregion                      }                  }              }              catch (ReflectionTypeLoadException ex)              {                  var sb = new StringBuilder();                  foreach (Exception exSub in ex.LoaderExceptions)                  {                      sb.AppendLine(exSub.Message);                      if (exSub is FileNotFoundException)                      {                          var exFileNotFound = exSub as FileNotFoundException;                          if (!string.IsNullOrEmpty(exFileNotFound.FusionLog))                          {                              sb.AppendLine("Fusion Log:");                              sb.AppendLine(exFileNotFound.FusionLog);                          }                      }                      sb.AppendLine();                  }                  var errorMessage = sb.ToString();                  Console.WriteLine(errorMessage);                  Console.ReadKey();                  return;              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);                  Console.WriteLine(ex.StackTrace);                  Console.ReadKey();                  return;              }
Magic Number,NodeDumper,Program,C:\repos\DynamoDS_Dynamo\tools\NodeDumper\NodeDumper\Program.cs,Main,The following statement contains a magic number: try              {                  using (var tw = new StreamWriter(outPath))                  {                      tw.WriteLine("Type Name' Name' Description' Category");                        var nodeDirInfo = new DirectoryInfo(nodesDir);                      var nodeLibs = nodeDirInfo.GetFiles("*.dll");                        foreach (var nodeLib in nodeLibs)                      {                          var module = ModuleDefinition.ReadModule(nodeLib.FullName);                          var cecilNodes = module.Types.Where(x => x.Namespace == "Dynamo.Nodes");                          var typeDefinitions = cecilNodes as TypeDefinition[] ?? cecilNodes.ToArray();                          if (!typeDefinitions.Any())                              continue;                            foreach (var nn in typeDefinitions)                          {                              if(nn.IsAbstract)                                  continue;                                if (!nn.HasCustomAttributes)                                  continue;                                var name = "";                              var descrip = "";                              var cat = "";                                bool isCompilerGenerated = false;                                foreach (var ca in nn.CustomAttributes)                              {                                  if (ca.AttributeType.Name == "NodeNameAttribute")                                  {                                      name = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeDescriptionAttribute")                                  {                                      descrip = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "NodeCategoryAttribute")                                  {                                      cat = ca.ConstructorArguments[0].Value.ToString();                                  }                                  else if (ca.AttributeType.Name == "CompilerGeneratedAttribute")                                  {                                      isCompilerGenerated = true;                                  }                              }                                if (isCompilerGenerated)                                  continue;                                string line = string.Format("{0}'{1}'{2}'{3}"' nn.ToString()' name' descrip.Replace("'"' " ")' cat);                                //find the port data                              var constructors = nn.Methods.Where(x => x.IsConstructor);                              foreach (var constructor in constructors)                              {                                  if (!constructor.HasBody)                                      continue;                                    int instructionCount = 0;                                  foreach (var instruction in constructor.Body.Instructions)                                  {                                      if (instruction.OpCode == OpCodes.Newobj)                                      {                                          var methodRef = (MethodReference)instruction.Operand;                                          if (methodRef.DeclaringType.Name == "PortData")                                          {                                              var nickname = "";                                              var description = "";                                              if (constructor.Body.Instructions[instructionCount - 4].Operand != null)                                                  description = constructor.Body.Instructions[instructionCount - 4].Operand.ToString();                                              if (constructor.Body.Instructions[instructionCount - 5].Operand != null)                                                  nickname = constructor.Body.Instructions[instructionCount - 5].Operand.ToString();                                              line += string.Format("'{0}:{1}"' nickname' description);                                          }                                      }                                      instructionCount++;                                  }                              }                                tw.WriteLine(line);                          }                            #region using reflection                          //var nodeAss = Assembly.ReflectionOnlyLoadFrom(nodeLib.FullName);                          //var nodes = nodeAss.GetTypes().Where(x => x.Namespace == "Dynamo.Nodes");                                                    //foreach (var n in nodes)                          //{                          //    if (n.IsAbstract)                          //        continue;                            //    var attribDatas = n.GetCustomAttributesData();                          //    if (attribDatas.Count == 0)                          //        continue;                            //    string name = "";                          //    string descrip = "";                          //    string cat = "";                            //    bool isCompilerGenerated = false;                            //    foreach (CustomAttributeData attribData in attribDatas)                          //    {                          //        if (attribData.Constructor.ReflectedType.Name == "NodeNameAttribute")                          //        {                          //            name = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeDescriptionAttribute")                          //        {                          //            descrip = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "NodeCategoryAttribute")                          //        {                          //            cat = attribData.ConstructorArguments[0].Value.ToString();                          //        }                          //        else if (attribData.Constructor.ReflectedType.Name == "CompilerGeneratedAttribute")                          //        {                          //            isCompilerGenerated = true;                          //        }                          //    }                            //    if (isCompilerGenerated)                          //        continue;                            //    string line = string.Format("{0}'{1}'{2}'{3}"' n.ToString()' name' descrip.Replace("'"' " ")' cat);                            //    tw.WriteLine(line);                          //}                           #endregion                      }                  }              }              catch (ReflectionTypeLoadException ex)              {                  var sb = new StringBuilder();                  foreach (Exception exSub in ex.LoaderExceptions)                  {                      sb.AppendLine(exSub.Message);                      if (exSub is FileNotFoundException)                      {                          var exFileNotFound = exSub as FileNotFoundException;                          if (!string.IsNullOrEmpty(exFileNotFound.FusionLog))                          {                              sb.AppendLine("Fusion Log:");                              sb.AppendLine(exFileNotFound.FusionLog);                          }                      }                      sb.AppendLine();                  }                  var errorMessage = sb.ToString();                  Console.WriteLine(errorMessage);                  Console.ReadKey();                  return;              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);                  Console.WriteLine(ex.StackTrace);                  Console.ReadKey();                  return;              }
