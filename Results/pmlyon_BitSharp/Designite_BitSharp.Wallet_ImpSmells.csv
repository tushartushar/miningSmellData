Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,ScanBlock,The method has 5 parameters. Parameters: coreStorage' chainState' scanBlock' forward' cancelToken
Long Statement,BitSharp.Wallet.Base58,Base58Encoding,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Base58\Base58Encoding.cs,VerifyAndRemoveCheckSum,The length of the statement  "            //Contract.Ensures(Contract.Result<byte[]>() == null || Contract.Result<byte[]>().Length + CheckSumSizeInBytes == data.Length); " is 127.
Long Statement,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,WorkAction,The length of the statement  "                    catch (MissingDataException) {/*TODO no wallet state is saved' so missing data will be thrown when started up again due to pruning*/} " is 133.
Long Statement,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,WorkAction,The length of the statement  "                    catch (AggregateException) {/*TODO no wallet state is saved' so missing data will be thrown when started up again due to pruning*/} " is 131.
Long Statement,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,ScanForEntry,The length of the statement  "                logger.Debug($"{walletEntryType + ":"'-10}   {txOutput.Value / (decimal)(100.MILLION())'20:#'##0.000_000_00} BTC' Entries: {this.entriesCount:#'##0}"); " is 151.
Empty Catch Block,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,WorkAction,The method has an empty catch block.
Empty Catch Block,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,WorkAction,The method has an empty catch block.
Magic Number,BitSharp.Wallet.Address,First10000Address,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Address\First10000Address.cs,GetOutputScriptHashes,The following statement contains a magic number: using (var stream = this.GetType().Assembly.GetManifestResourceStream("BitSharp.Wallet.Address.First10000.txt"))              using (var reader = new StreamReader(stream' Encoding.UTF8))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      if (line == "")                          continue;                        var bytes = line.HexToByteArray();                      if (bytes.Length == 65)                          yield return PublicKeyToOutputScriptHash(bytes);                      else if (bytes.Length == 20)                          yield return PublicKeyHashToOutputScriptHash(bytes);                      else                          throw new InvalidOperationException();                  }              }
Magic Number,BitSharp.Wallet.Address,First10000Address,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Address\First10000Address.cs,GetOutputScriptHashes,The following statement contains a magic number: using (var stream = this.GetType().Assembly.GetManifestResourceStream("BitSharp.Wallet.Address.First10000.txt"))              using (var reader = new StreamReader(stream' Encoding.UTF8))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      if (line == "")                          continue;                        var bytes = line.HexToByteArray();                      if (bytes.Length == 65)                          yield return PublicKeyToOutputScriptHash(bytes);                      else if (bytes.Length == 20)                          yield return PublicKeyHashToOutputScriptHash(bytes);                      else                          throw new InvalidOperationException();                  }              }
Magic Number,BitSharp.Wallet.Address,First10000Address,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Address\First10000Address.cs,PublicKeyToOutputScriptHash,The following statement contains a magic number: if (publicKey.Length != 65)                  throw new ArgumentException("publicKey");
Magic Number,BitSharp.Wallet.Address,First10000Address,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Address\First10000Address.cs,PublicKeyHashToOutputScriptHash,The following statement contains a magic number: if (publicKeyHash.Length != 20)                  throw new ArgumentException("publicKeyHash");
Magic Number,BitSharp.Wallet.Base58,Base58Encoding,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Base58\Base58Encoding.cs,Encode,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  intData = intData * 256 + data[i];              }
Magic Number,BitSharp.Wallet.Base58,Base58Encoding,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Base58\Base58Encoding.cs,Encode,The following statement contains a magic number: while (intData > 0)              {                  int remainder = (int)(intData % 58);                  intData /= 58;                  result = Digits[remainder] + result;              }
Magic Number,BitSharp.Wallet.Base58,Base58Encoding,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Base58\Base58Encoding.cs,Encode,The following statement contains a magic number: while (intData > 0)              {                  int remainder = (int)(intData % 58);                  intData /= 58;                  result = Digits[remainder] + result;              }
Magic Number,BitSharp.Wallet.Base58,Base58Encoding,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\Base58\Base58Encoding.cs,Decode,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)              {                  int digit = Digits.IndexOf(s[i]); //Slow                  if (digit < 0)                      throw new FormatException($"Invalid Base58 character `{s[i]}` at position {i}");                  intData = intData * 58 + digit;              }
Magic Number,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,ScanForEntry,The following statement contains a magic number: if (matchingAddresses.Count > 0)              {                  var entry = new WalletEntry                  (                      addresses: matchingAddresses.ToImmutable()'                      type: walletEntryType'                      chainPosition: chainPosition'                      value: txOutput.Value                  );                    lock (this.entries)                  {                      if (keepEntries)                          this.entries.Add(entry);                        this.entriesCount++;                  }                  this.bitBalance += entry.BitValue * walletEntryType.Direction();                    logger.Debug($"{walletEntryType + ":"'-10}   {txOutput.Value / (decimal)(100.MILLION())'20:#'##0.000_000_00} BTC' Entries: {this.entriesCount:#'##0}");                    this.OnEntryAdded?.Invoke(entry);              }
Magic Number,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,ScanForEntry,The following statement contains a magic number: if (matchingAddresses.Count > 0)              {                  var entry = new WalletEntry                  (                      addresses: matchingAddresses.ToImmutable()'                      type: walletEntryType'                      chainPosition: chainPosition'                      value: txOutput.Value                  );                    lock (this.entries)                  {                      if (keepEntries)                          this.entries.Add(entry);                        this.entriesCount++;                  }                  this.bitBalance += entry.BitValue * walletEntryType.Direction();                    logger.Debug($"{walletEntryType + ":"'-10}   {txOutput.Value / (decimal)(100.MILLION())'20:#'##0.000_000_00} BTC' Entries: {this.entriesCount:#'##0}");                    this.OnEntryAdded?.Invoke(entry);              }
Magic Number,BitSharp.Wallet,WalletMonitor,C:\repos\pmlyon_BitSharp\BitSharp.Wallet\WalletMonitor.cs,ScanForEntry,The following statement contains a magic number: if (matchingAddresses.Count > 0)              {                  var entry = new WalletEntry                  (                      addresses: matchingAddresses.ToImmutable()'                      type: walletEntryType'                      chainPosition: chainPosition'                      value: txOutput.Value                  );                    lock (this.entries)                  {                      if (keepEntries)                          this.entries.Add(entry);                        this.entriesCount++;                  }                  this.bitBalance += entry.BitValue * walletEntryType.Direction();                    logger.Debug($"{walletEntryType + ":"'-10}   {txOutput.Value / (decimal)(100.MILLION())'20:#'##0.000_000_00} BTC' Entries: {this.entriesCount:#'##0}");                    this.OnEntryAdded?.Invoke(entry);              }
