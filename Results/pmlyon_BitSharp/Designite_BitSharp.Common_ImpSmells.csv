Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,Time,The method has 5 parameters. Parameters: timerName' filterTime' action' memberName' lineNumber
Long Parameter List,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,Time,The method has 5 parameters. Parameters: timerName' filterTime' func' memberName' lineNumber
Long Parameter List,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,Time,The method has 5 parameters. Parameters: action' timerName' filterTime' memberName' lineNumber
Long Parameter List,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,Time,The method has 5 parameters. Parameters: func' timerName' filterTime' memberName' lineNumber
Long Parameter List,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,WriteLine,The method has 5 parameters. Parameters: stopwatch' timerName' filterTime' memberName' lineNumber
Long Parameter List,BitSharp.Common,Throttler,C:\repos\pmlyon_BitSharp\BitSharp.Common\Throttler.cs,IfElapsed,The method has 5 parameters. Parameters: interval' action' memberName' filePath' lineNumber
Long Parameter List,BitSharp.Common,WorkerMethod,C:\repos\pmlyon_BitSharp\BitSharp.Common\WorkerMethod.cs,WorkerMethod,The method has 5 parameters. Parameters: name' workAction' initialNotify' minIdleTime' maxIdleTime
Long Statement,BitSharp.Common,ConsoleLoggingModule,C:\repos\pmlyon_BitSharp\BitSharp.Common\ConsoleLoggingModule.cs,Configure,The length of the statement  "            var layout = "${date:format=hh\\:mm\\:ss tt} ${pad:padding=6:inner=${level:uppercase=true}} ${message} ${exception:separator=\r\n:format=message'type'method'stackTrace:maxInnerExceptionLevel=10:innerExceptionSeparator=\r\n:innerFormat=message'type'method'stackTrace}"; " is 268.
Long Statement,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,WriteLine,The length of the statement  "                    LogIf(stopwatch.ElapsedMilliseconds > filterTime' $"\t[TIMING] {timerName}:{memberName}:{lineNumber} took {stopwatch.Elapsed.TotalSeconds:N6} s"); " is 146.
Long Statement,BitSharp.Common,MethodTimer,C:\repos\pmlyon_BitSharp\BitSharp.Common\MethodTimer.cs,WriteLine,The length of the statement  "                    LogIf(stopwatch.ElapsedMilliseconds > filterTime' $"\t[TIMING] {memberName}:{lineNumber} took {stopwatch.Elapsed.TotalSeconds:N6} s"); " is 134.
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 56;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 48;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 40;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 32;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 24;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 16;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,ToInt64BE,The following statement contains a magic number: value |= (long)buffer[offset++] << 8;
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt16,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt32BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 56);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,Bits,C:\repos\pmlyon_BitSharp\BitSharp.Common\Bits.cs,EncodeInt64BE,The following statement contains a magic number: unchecked              {                  buffer[offset++] = (byte)(value >> 56);                  buffer[offset++] = (byte)(value >> 48);                  buffer[offset++] = (byte)(value >> 40);                  buffer[offset++] = (byte)(value >> 32);                  buffer[offset++] = (byte)(value >> 24);                  buffer[offset++] = (byte)(value >> 16);                  buffer[offset++] = (byte)(value >> 8);                  buffer[offset++] = (byte)(value);              }
Magic Number,BitSharp.Common,DisposableCache<T>,C:\repos\pmlyon_BitSharp\BitSharp.Common\DisposableCache.cs,TakeItem,The following statement contains a magic number: while (true)              {                  // try to take a cache instance                  DisposeHandle<T> handle;                  if (this.TryTakeItem(out handle))                      return handle;                    Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      logger.Warn($"Disposable cache ran out of items: {GetType().Name}"));                    if (timeout < TimeSpan.Zero || timeout == TimeSpan.MaxValue)                  {                      this.itemFreedEvent.WaitOne();                  }                  else                  {                      // determine the amount of timeout remaining                      var remaining = timeout - stopwatch.Elapsed;                        // if timeout is remaining' wait up to that amount of time for a new instance to become available                      if (remaining.Ticks > 0)                          this.itemFreedEvent.WaitOne(remaining);                      // otherwise' throw a timeout exception                      else                          throw new TimeoutException();                  }              }
Magic Number,BitSharp.Common,AverageMeasure,C:\repos\pmlyon_BitSharp\BitSharp.Common\AverageMeasure.cs,AverageMeasure,The following statement contains a magic number: this.SampleCutoff = sampleCutoff ?? TimeSpan.FromSeconds(30);
Magic Number,BitSharp.Common,ImmutableBitArray,C:\repos\pmlyon_BitSharp\BitSharp.Common\ImmutableBitArray.cs,ToByteArray,The following statement contains a magic number: var byteLength = (this.bitArray.Length + 7) / 8;
Magic Number,BitSharp.Common,ImmutableBitArray,C:\repos\pmlyon_BitSharp\BitSharp.Common\ImmutableBitArray.cs,ToByteArray,The following statement contains a magic number: var byteLength = (this.bitArray.Length + 7) / 8;
Magic Number,BitSharp.Common,DurationMeasure,C:\repos\pmlyon_BitSharp\BitSharp.Common\DurationMeasure.cs,DurationMeasure,The following statement contains a magic number: this.SampleCutoff = sampleCutoff ?? TimeSpan.FromSeconds(30);
Magic Number,BitSharp.Common,RateMeasure,C:\repos\pmlyon_BitSharp\BitSharp.Common\RateMeasure.cs,RateMeasure,The following statement contains a magic number: this.SampleCutoff = sampleCutoff ?? TimeSpan.FromSeconds(30);
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length > 32 && !(value.Length == 33 && value[32] == 0))                  throw new ArgumentOutOfRangeException(nameof(value));
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length > 32 && !(value.Length == 33 && value[32] == 0))                  throw new ArgumentOutOfRangeException(nameof(value));
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length > 32 && !(value.Length == 33 && value[32] == 0))                  throw new ArgumentOutOfRangeException(nameof(value));
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length < 32)                  Array.Resize(ref value' 32);
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length < 32)                  Array.Resize(ref value' 32);
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,UInt256,The following statement contains a magic number: if (value.Length < offset + 32)                  throw new ArgumentOutOfRangeException(nameof(offset));
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,InnerInit,The following statement contains a magic number: offset += 32;
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,InnerInit,The following statement contains a magic number: for (var i = 0; i < width; i++)              {                  offset -= 8;                  parts[i] = Bits.ToUInt64(buffer' offset);              }
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,InnerInit,The following statement contains a magic number: hashCode = Bits.ToInt32(new xxHash(32).ComputeHash(hashBytes));
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,ToByteArray,The following statement contains a magic number: var buffer = new byte[32];
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,ToByteArray,The following statement contains a magic number: for (var i = width - 1; i >= 0; i--)              {                  Bits.EncodeUInt64(parts[i]' buffer' offset);                  offset += 8;              }
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,ToByteArrayBE,The following statement contains a magic number: var buffer = new byte[32];
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,ToByteArrayBE,The following statement contains a magic number: for (var i = 0; i < width; i++)              {                  Bits.EncodeUInt64BE(parts[i]' buffer' offset);                  offset += 8;              }
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,FromByteArrayBE,The following statement contains a magic number: unchecked              {                  if (buffer.Length < offset + 32)                      throw new ArgumentException();                    var parts = new ulong[width];                  for (var i = 0; i < width; i++)                  {                      parts[i] = Bits.ToUInt64BE(buffer' offset);                      offset += 8;                  }                    return new UInt256(parts);              }
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,FromByteArrayBE,The following statement contains a magic number: unchecked              {                  if (buffer.Length < offset + 32)                      throw new ArgumentException();                    var parts = new ulong[width];                  for (var i = 0; i < width; i++)                  {                      parts[i] = Bits.ToUInt64BE(buffer' offset);                      offset += 8;                  }                    return new UInt256(parts);              }
Magic Number,BitSharp.Common,UInt256,C:\repos\pmlyon_BitSharp\BitSharp.Common\UInt256.cs,ToBigInteger,The following statement contains a magic number: var buffer = new byte[33];
Magic Number,BitSharp.Common,Worker,C:\repos\pmlyon_BitSharp\BitSharp.Common\Worker.cs,Worker,The following statement contains a magic number: workerThreads = Math.Max(Environment.ProcessorCount * 30' workerThreads);
Magic Number,BitSharp.Common,Worker,C:\repos\pmlyon_BitSharp\BitSharp.Common\Worker.cs,Worker,The following statement contains a magic number: completionPortThreads = Math.Max(Environment.ProcessorCount * 4' completionPortThreads);
Magic Number,BitSharp.Common,Worker,C:\repos\pmlyon_BitSharp\BitSharp.Common\Worker.cs,WorkerLoop,The following statement contains a magic number: try              {                  // stats                  var totalTime = Stopwatch.StartNew();                  var workerTime = new Stopwatch();                  var lastReportTime = DateTimeOffset.Now;                    // continue running as long as the worker is alive                  while (this.isAlive)                  {                      // notify worker is idle                      this.idleEvent.Set();                        // wait for execution to start                      await Task.Delay(TimeSpan.FromMilliseconds(-1)' startToken.CancelToken()).ContinueWith(_ => { });                        // cooperative loop                      if (!this.isStarted)                          continue;                        // delay for the requested wait time' unless forced                      var forced = false;                      await Task.Delay(this.MinIdleTime' forceNotifyToken.CancelToken()).ContinueWith(_ => { forced = _.IsCanceled; });                      forceNotifyToken.Reset();                        // wait for work notification' subtract time already spent waiting                      TimeSpan notifyDelay;                      if (forced)                          notifyDelay = TimeSpan.Zero;                      else if (this.MaxIdleTime == TimeSpan.MaxValue)                          notifyDelay = TimeSpan.FromMilliseconds(-1);                      else                          notifyDelay = this.MaxIdleTime - this.MinIdleTime;                        await Task.Delay(notifyDelay' notifyToken.CancelToken()).ContinueWith(_ => { });                      notifyToken.Reset();                        // cooperative loop                      if (!this.isStarted)                          continue;                        // notify that work is starting                      this.idleEvent.Reset();                        // notify work started                      this.OnWorkStarted?.Invoke();                        // perform the work                      workerTime.Start();                      try                      {                          await WorkAction();                      }                      catch (Exception ex)                      {                          // ignore a cancellation exception                          // workers can throw this to stop the current work action                          bool cancelled;                          if (ex is OperationCanceledException)                              cancelled = true;                          else if (ex is AggregateException                                  && ((AggregateException)ex).InnerExceptions.All(x => x is OperationCanceledException))                              cancelled = true;                          else                              cancelled = false;                            // worker leaked an exception                          if (!cancelled)                          {                              logger.Error(ex' $"Unhandled worker exception in {this.Name}: ");                                // notify work error                              this.OnWorkError?.Invoke(ex);                                // throttle on leaked exception                              Thread.Sleep(TimeSpan.FromSeconds(1));                          }                      }                      finally                      {                          workerTime.Stop();                      }                        // notify work stopped                      this.OnWorkFinished?.Invoke();                        // log worker stats                      if (DateTimeOffset.Now - lastReportTime > TimeSpan.FromSeconds(30))                      {                          lastReportTime = DateTimeOffset.Now;                          var percentWorkerTime = workerTime.Elapsed.TotalSeconds / totalTime.Elapsed.TotalSeconds;                          logger.Debug($"{this.Name'55} work time: {percentWorkerTime'10:##0.00%}");                      }                  }              }              catch (Exception ex)              {                  logger.Fatal(ex' $"Unhandled worker exception in {this.Name}: ");                  throw;              }
Magic Number,BitSharp.Common,Worker,C:\repos\pmlyon_BitSharp\BitSharp.Common\Worker.cs,WorkerLoop,The following statement contains a magic number: try              {                  // stats                  var totalTime = Stopwatch.StartNew();                  var workerTime = new Stopwatch();                  var lastReportTime = DateTimeOffset.Now;                    // continue running as long as the worker is alive                  while (this.isAlive)                  {                      // notify worker is idle                      this.idleEvent.Set();                        // wait for execution to start                      await Task.Delay(TimeSpan.FromMilliseconds(-1)' startToken.CancelToken()).ContinueWith(_ => { });                        // cooperative loop                      if (!this.isStarted)                          continue;                        // delay for the requested wait time' unless forced                      var forced = false;                      await Task.Delay(this.MinIdleTime' forceNotifyToken.CancelToken()).ContinueWith(_ => { forced = _.IsCanceled; });                      forceNotifyToken.Reset();                        // wait for work notification' subtract time already spent waiting                      TimeSpan notifyDelay;                      if (forced)                          notifyDelay = TimeSpan.Zero;                      else if (this.MaxIdleTime == TimeSpan.MaxValue)                          notifyDelay = TimeSpan.FromMilliseconds(-1);                      else                          notifyDelay = this.MaxIdleTime - this.MinIdleTime;                        await Task.Delay(notifyDelay' notifyToken.CancelToken()).ContinueWith(_ => { });                      notifyToken.Reset();                        // cooperative loop                      if (!this.isStarted)                          continue;                        // notify that work is starting                      this.idleEvent.Reset();                        // notify work started                      this.OnWorkStarted?.Invoke();                        // perform the work                      workerTime.Start();                      try                      {                          await WorkAction();                      }                      catch (Exception ex)                      {                          // ignore a cancellation exception                          // workers can throw this to stop the current work action                          bool cancelled;                          if (ex is OperationCanceledException)                              cancelled = true;                          else if (ex is AggregateException                                  && ((AggregateException)ex).InnerExceptions.All(x => x is OperationCanceledException))                              cancelled = true;                          else                              cancelled = false;                            // worker leaked an exception                          if (!cancelled)                          {                              logger.Error(ex' $"Unhandled worker exception in {this.Name}: ");                                // notify work error                              this.OnWorkError?.Invoke(ex);                                // throttle on leaked exception                              Thread.Sleep(TimeSpan.FromSeconds(1));                          }                      }                      finally                      {                          workerTime.Stop();                      }                        // notify work stopped                      this.OnWorkFinished?.Invoke();                        // log worker stats                      if (DateTimeOffset.Now - lastReportTime > TimeSpan.FromSeconds(30))                      {                          lastReportTime = DateTimeOffset.Now;                          var percentWorkerTime = workerTime.Elapsed.TotalSeconds / totalTime.Elapsed.TotalSeconds;                          logger.Debug($"{this.Name'55} work time: {percentWorkerTime'10:##0.00%}");                      }                  }              }              catch (Exception ex)              {                  logger.Fatal(ex' $"Unhandled worker exception in {this.Name}: ");                  throw;              }
Magic Number,BitSharp.Common,Worker,C:\repos\pmlyon_BitSharp\BitSharp.Common\Worker.cs,WorkerLoop,The following statement contains a magic number: try              {                  // stats                  var totalTime = Stopwatch.StartNew();                  var workerTime = new Stopwatch();                  var lastReportTime = DateTimeOffset.Now;                    // continue running as long as the worker is alive                  while (this.isAlive)                  {                      // notify worker is idle                      this.idleEvent.Set();                        // wait for execution to start                      await Task.Delay(TimeSpan.FromMilliseconds(-1)' startToken.CancelToken()).ContinueWith(_ => { });                        // cooperative loop                      if (!this.isStarted)                          continue;                        // delay for the requested wait time' unless forced                      var forced = false;                      await Task.Delay(this.MinIdleTime' forceNotifyToken.CancelToken()).ContinueWith(_ => { forced = _.IsCanceled; });                      forceNotifyToken.Reset();                        // wait for work notification' subtract time already spent waiting                      TimeSpan notifyDelay;                      if (forced)                          notifyDelay = TimeSpan.Zero;                      else if (this.MaxIdleTime == TimeSpan.MaxValue)                          notifyDelay = TimeSpan.FromMilliseconds(-1);                      else                          notifyDelay = this.MaxIdleTime - this.MinIdleTime;                        await Task.Delay(notifyDelay' notifyToken.CancelToken()).ContinueWith(_ => { });                      notifyToken.Reset();                        // cooperative loop                      if (!this.isStarted)                          continue;                        // notify that work is starting                      this.idleEvent.Reset();                        // notify work started                      this.OnWorkStarted?.Invoke();                        // perform the work                      workerTime.Start();                      try                      {                          await WorkAction();                      }                      catch (Exception ex)                      {                          // ignore a cancellation exception                          // workers can throw this to stop the current work action                          bool cancelled;                          if (ex is OperationCanceledException)                              cancelled = true;                          else if (ex is AggregateException                                  && ((AggregateException)ex).InnerExceptions.All(x => x is OperationCanceledException))                              cancelled = true;                          else                              cancelled = false;                            // worker leaked an exception                          if (!cancelled)                          {                              logger.Error(ex' $"Unhandled worker exception in {this.Name}: ");                                // notify work error                              this.OnWorkError?.Invoke(ex);                                // throttle on leaked exception                              Thread.Sleep(TimeSpan.FromSeconds(1));                          }                      }                      finally                      {                          workerTime.Stop();                      }                        // notify work stopped                      this.OnWorkFinished?.Invoke();                        // log worker stats                      if (DateTimeOffset.Now - lastReportTime > TimeSpan.FromSeconds(30))                      {                          lastReportTime = DateTimeOffset.Now;                          var percentWorkerTime = workerTime.Elapsed.TotalSeconds / totalTime.Elapsed.TotalSeconds;                          logger.Debug($"{this.Name'55} work time: {percentWorkerTime'10:##0.00%}");                      }                  }              }              catch (Exception ex)              {                  logger.Fatal(ex' $"Unhandled worker exception in {this.Name}: ");                  throw;              }
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,THOUSAND,The following statement contains a magic number: return value * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return (long)value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return (long)value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return (long)value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,THOUSAND,The following statement contains a magic number: return value * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,THOUSAND,The following statement contains a magic number: return value * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MILLION,The following statement contains a magic number: return value * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,BILLION,The following statement contains a magic number: return value * 1000 * 1000 * 1000;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,KIBIBYTE,The following statement contains a magic number: return value * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MEBIBYTE,The following statement contains a magic number: return value * 1024 * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,MEBIBYTE,The following statement contains a magic number: return value * 1024 * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,GIBIBYTE,The following statement contains a magic number: return value * 1024 * 1024 * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,GIBIBYTE,The following statement contains a magic number: return value * 1024 * 1024 * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,GIBIBYTE,The following statement contains a magic number: return value * 1024 * 1024 * 1024;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,HexToByteArray,The following statement contains a magic number: if (value.Length % 2 != 0)                  throw new ArgumentOutOfRangeException();
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,HexToByteArray,The following statement contains a magic number: var bytes = new byte[value.Length / 2];
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,HexToByteArray,The following statement contains a magic number: for (var i = 0; i < bytes.Length; i++)              {                  bytes[i] = Byte.Parse(value.Substring(i * 2' 2)' NumberStyles.HexNumber);              }
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,HexToByteArray,The following statement contains a magic number: for (var i = 0; i < bytes.Length; i++)              {                  bytes[i] = Byte.Parse(value.Substring(i * 2' 2)' NumberStyles.HexNumber);              }
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,NextUInt64,The following statement contains a magic number: return (random.NextUInt32() << 32) + random.NextUInt32();
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,NextUInt256,The following statement contains a magic number: return new UInt256(                  (new BigInteger(random.NextUInt32()) << 96) +                  (new BigInteger(random.NextUInt32()) << 64) +                  (new BigInteger(random.NextUInt32()) << 32) +                  new BigInteger(random.NextUInt32()));
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,NextUInt256,The following statement contains a magic number: return new UInt256(                  (new BigInteger(random.NextUInt32()) << 96) +                  (new BigInteger(random.NextUInt32()) << 64) +                  (new BigInteger(random.NextUInt32()) << 32) +                  new BigInteger(random.NextUInt32()));
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,NextUInt256,The following statement contains a magic number: return new UInt256(                  (new BigInteger(random.NextUInt32()) << 96) +                  (new BigInteger(random.NextUInt32()) << 64) +                  (new BigInteger(random.NextUInt32()) << 32) +                  new BigInteger(random.NextUInt32()));
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,NextBool,The following statement contains a magic number: return random.Next(2) == 0;
Magic Number,BitSharp.Common.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Common\ExtensionMethods.cs,WrapAsync,The following statement contains a magic number: return new AsyncTargetWrapper              {                  WrappedTarget = target'                  QueueLimit = 5.THOUSAND()'                  OverflowAction = AsyncTargetWrapperOverflowAction.Block              };
