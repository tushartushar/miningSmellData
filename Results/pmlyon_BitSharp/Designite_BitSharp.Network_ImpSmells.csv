Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,WireDecodeMessage,The method has 116 lines of code.
Long Method,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,SendBlockRequests,The method has 116 lines of code.
Complex Method,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetBlocks,Cyclomatic complexity of the method is 8
Complex Method,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,Cyclomatic complexity of the method is 11
Complex Method,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetBlocks,Cyclomatic complexity of the method is 8
Complex Method,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,Cyclomatic complexity of the method is 11
Complex Method,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,SendBlockRequests,Cyclomatic complexity of the method is 16
Complex Method,BitSharp.Network.Workers,PeerWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\PeerWorker.cs,WorkAction,Cyclomatic complexity of the method is 11
Long Parameter List,BitSharp.Network.Domain,Message,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\Message.cs,Message,The method has 5 parameters. Parameters: Magic' Command' PayloadSize' PayloadChecksum' Payload
Long Parameter List,BitSharp.Network.Domain,VersionPayload,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\VersionPayload.cs,VersionPayload,The method has 9 parameters. Parameters: ProtocolVersion' ServicesBitfield' Time' RemoteAddress' LocalAddress' Nonce' UserAgent' StartBlockHeight' Relay
Long Parameter List,BitSharp.Network.Domain,VersionPayload,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\VersionPayload.cs,With,The method has 9 parameters. Parameters: ProtocolVersion' ServicesBitfield' Time' RemoteAddress' LocalAddress' Nonce' UserAgent' StartBlockHeight' Relay
Long Identifier,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,,The length of the parameter duplicateBlockDownloadCountMeasure is 34.
Long Statement,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,HandlePeerHandshakeCompleted,The length of the statement  "            var remoteAddressWithTime = new NetworkAddressWithTime(DateTimeOffset.Now' peer.RemoteEndPoint.ToNetworkAddress(/*TODO*/services: 0)); " is 134.
Long Statement,BitSharp.Network,NetworkEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Network\NetworkEncoder.cs,EncodeAddressPayload,The length of the statement  "            writer.WriteList(addressPayload.NetworkAddresses' networkAddress => EncodeNetworkAddressWithTime(writer' networkAddress)); " is 122.
Long Statement,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,HandleMessage,The length of the statement  "                logger.Trace($"{socket.RemoteEndPoint'25} Received message {message.Command'12} in {stopwatch.ElapsedMilliseconds'6} ms"); " is 122.
Long Statement,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,WireDecodeMessage,The length of the statement  "            //    var exMessage = $"Wrong number of bytes read for {message.Command}' parser error: read {payloadStream.Position} bytes from a {payloadStream.Length} byte payload"; " is 168.
Long Statement,BitSharp.Network,RemoteSender,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteSender.cs,SendGetHeaders,The length of the statement  "            var getBlocksMessage = Messaging.ConstructMessage("getheaders"' NetworkEncoder.EncodeGetBlocksPayload(getHeadersPayload)); " is 122.
Long Statement,BitSharp.Network,RemoteSender,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteSender.cs,SendGetBlocks,The length of the statement  "            var getBlocksMessage = Messaging.ConstructMessage("getblocks"' NetworkEncoder.EncodeGetBlocksPayload(getBlocksPayload)); " is 120.
Long Statement,BitSharp.Network,RemoteSender,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteSender.cs,SendVersion,The length of the statement  "            var versionMessage = Messaging.ConstructMessage("version"' NetworkEncoder.EncodeVersionPayload(versionPayload' withRelay: false)); " is 130.
Long Statement,BitSharp.Network,RemoteSender,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteSender.cs,SendMessageAsync,The length of the statement  "                            logger.Trace($"Sent {message.Command} in {stopwatch.ElapsedMilliseconds} ms\nPayload: {message.Payload.ToArray().ToHexDataString()}"); " is 134.
Long Statement,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,HandlePeerHandshakeCompleted,The length of the statement  "            var remoteAddressWithTime = new NetworkAddressWithTime(DateTimeOffset.Now' peer.RemoteEndPoint.ToNetworkAddress(/*TODO*/services: 0)); " is 134.
Long Statement,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,HandleBlockMissed,The length of the statement  "            //TODO block should be tracked as soon as the block message is received so it isn't re-requested while it is still downloading " is 126.
Long Statement,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetBlockPath,The length of the statement  "            var blockFolder = string.Join(Path.DirectorySeparatorChar.ToString()' Enumerable.Range(0' blockHashString.Length / chunkSize).Select(i => blockHashString.Substring(i * chunkSize' chunkSize)).ToArray()); " is 202.
Long Statement,BitSharp.Network.Workers,ListenWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\ListenWorker.cs,SubStart,The length of the statement  "                        this.listenSocket.Bind(new IPEndPoint(localhost.AddressList.Where(x => x.AddressFamily == externalIPAddress.AddressFamily).First()' Messaging.Port)); " is 149.
Long Statement,BitSharp.Network.Workers,ListenWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\ListenWorker.cs,WorkAction,The length of the statement  "                var newSocket = await Task.Factory.FromAsync<Socket>(this.listenSocket.BeginAccept(null' null)' this.listenSocket.EndAccept); " is 125.
Long Statement,BitSharp.Network.Workers,PeerWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\PeerWorker.cs,ConnectAndHandshake,The length of the statement  "            var versionPayload = NetworkEncoder.DecodeVersionPayload(versionMessage.Payload.ToArray()' versionMessage.Payload.Length); " is 122.
Complex Conditional,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnInventoryVectors,The conditional expression  "invVector.Type == InventoryVector.TYPE_MESSAGE_BLOCK                          && !requestedComparisonBlocks.Contains(invVector.Hash)                          && !comparisonUnchainedBlocks.ContainsKey(invVector.Hash)                          && !this.coreStorage.ContainsBlockTxes(invVector.Hash)"  is complex.
Complex Conditional,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnInventoryVectors,The conditional expression  "invVector.Type == InventoryVector.TYPE_MESSAGE_BLOCK                          && !requestedComparisonBlocks.Contains(invVector.Hash)                          && !comparisonUnchainedBlocks.ContainsKey(invVector.Hash)                          && !this.coreStorage.ContainsBlockTxes(invVector.Hash)"  is complex.
Complex Conditional,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetRequestBlocksForPeer,The conditional expression  "!this.flushBlocks.Contains(requestBlock.Hash)                      && !peerBlockRequests.ContainsKey(requestBlock.Hash)                      && !this.allBlockRequests.ContainsKey(requestBlock.Hash)                      && !this.coreStorage.ContainsBlockTxes(requestBlock.Hash)"  is complex.
Magic Number,BitSharp.Network.Domain,NetworkAddressKey,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\NetworkAddressKey.cs,NetworkAddressKey,The following statement contains a magic number: var hashBytes = new byte[2 + IPv6Address.Length];
Magic Number,BitSharp.Network.Domain,NetworkAddressKey,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\NetworkAddressKey.cs,NetworkAddressKey,The following statement contains a magic number: IPv6Address.CopyTo(hashBytes' 2);
Magic Number,BitSharp.Network.Domain,NetworkAddressKey,C:\repos\pmlyon_BitSharp\BitSharp.Network\Domain\NetworkAddressKey.cs,NetworkAddressKey,The following statement contains a magic number: hashCode = Bits.ToInt32(new xxHash(32).ComputeHash(hashBytes));
Magic Number,BitSharp.Network.ExtensionMethods,ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Network\ExtensionMethods.cs,ToIPEndPoint,The following statement contains a magic number: if (address.IsIPv4MappedToIPv6)                  address = new IPAddress(networkAddress.IPv6Address.Skip(12).ToArray());
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.headersRequestWorker = new HeadersRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(5))'                  this' this.coreDaemon);
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.headersRequestWorker = new HeadersRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(5))'                  this' this.coreDaemon);
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.blockRequestWorker = new BlockRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(30))'                  this' this.coreDaemon);
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.blockRequestWorker = new BlockRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(30))'                  this' this.coreDaemon);
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.statsWorker = new WorkerMethod("LocalClient.StatsWorker"' StatsWorker' true' TimeSpan.FromSeconds(5)' TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.statsWorker = new WorkerMethod("LocalClient.StatsWorker"' StatsWorker' true' TimeSpan.FromSeconds(5)' TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,DiscouragePeer,The following statement contains a magic number: if (this.networkPeerStorage.TryGetValue(peerEndPoint.ToNetworkAddressKey()' out address))              {                  var newTime = address.Time - TimeSpan.FromDays(7);                  this.networkPeerStorage[address.NetworkAddress.GetKey()] = address.With(Time: newTime);              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddKnownPeers,The following statement contains a magic number: foreach (var knownAddress in this.networkPeerStorage)              {                  this.peerWorker.AddCandidatePeer(                      new CandidatePeer                      (                          ipEndPoint: knownAddress.Value.NetworkAddress.ToIPEndPoint()'                          time: knownAddress.Value.Time + TimeSpan.FromDays(random.NextDouble(-2' +2))'                          isSeed: false                      ));                  count++;              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddKnownPeers,The following statement contains a magic number: foreach (var knownAddress in this.networkPeerStorage)              {                  this.peerWorker.AddCandidatePeer(                      new CandidatePeer                      (                          ipEndPoint: knownAddress.Value.NetworkAddress.ToIPEndPoint()'                          time: knownAddress.Value.Time + TimeSpan.FromDays(random.NextDouble(-2' +2))'                          isSeed: false                      ));                  count++;              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnInventoryVectors,The following statement contains a magic number: if (this.Type != ChainType.Regtest)              {                  var responseInvVectors = ImmutableArray.CreateBuilder<InventoryVector>();                    using (var chainState = coreDaemon.GetChainState())                  using (var unconfirmedTxes = coreDaemon.GetUnconfirmedTxes())                  {                      foreach (var invVector in invVectors)                      {                          // check if this is a transaction we don't have yet                          if (invVector.Type == InventoryVector.TYPE_MESSAGE_TRANSACTION                              && !unconfirmedTxes.ContainsTransaction(invVector.Hash)                              && !chainState.ContainsUnspentTx(invVector.Hash))                          {                              //logger.Info($"Requesting transaction {invVector.Hash}");                              responseInvVectors.Add(invVector);                          }                          // check if this is a block we don't have yet                          else if (invVector.Type == InventoryVector.TYPE_MESSAGE_TRANSACTION                              && !coreStorage.ContainsChainedHeader(invVector.Hash))                          {                              // ask for headers on a new block                              headersRequestWorker.SendGetHeaders(peer);                          }                      }                  }                    // request missing transactions                  if (responseInvVectors.Count > 0)                      peer.Sender.SendGetData(responseInvVectors.ToImmutable()).Wait();              }              else              {                  // don't process new inv request until previous inv request has finished                  while (this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }                  this.coreDaemon.ForceUpdateAndWait();                    var responseInvVectors = ImmutableArray.CreateBuilder<InventoryVector>();                    foreach (var invVector in invVectors)                  {                      if (invVector.Type == InventoryVector.TYPE_MESSAGE_BLOCK                          && !requestedComparisonBlocks.Contains(invVector.Hash)                          && !comparisonUnchainedBlocks.ContainsKey(invVector.Hash)                          && !this.coreStorage.ContainsBlockTxes(invVector.Hash))                      {                          logger.Info($"processing block inv: {invVector.Hash}");                          responseInvVectors.Add(invVector);                          requestedComparisonBlocks.Add(invVector.Hash);                      }                      else                      {                          logger.Info($"ignoring block inv: {invVector.Hash}' exists: {coreStorage.ContainsBlockTxes(invVector.Hash)}");                      }                  }                    if (responseInvVectors.Count > 0)                      connectedPeersLocal.Single().Sender.SendGetData(responseInvVectors.ToImmutable()).Wait();              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetBlocks,The following statement contains a magic number: var limit = 500;
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't send headers until all blocks requested from the comparison tool have been downloaded and processed                  while (this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }                  this.coreDaemon.ForceUpdateAndWait();              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,The following statement contains a magic number: var limit = 500;
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnPing,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't pong back until:                  // - all blocks requested from the comparison tool have been downloaded and processed                  // - current header inventory has been sent to the comparison tool                  while (comparisonHeadersSentEvent.WaitOne(1000)                      && this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnPing,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't pong back until:                  // - all blocks requested from the comparison tool have been downloaded and processed                  // - current header inventory has been sent to the comparison tool                  while (comparisonHeadersSentEvent.WaitOne(1000)                      && this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }              }
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network,Messaging,C:\repos\pmlyon_BitSharp\BitSharp.Network\Messaging.cs,BytesToIPAddress,The following statement contains a magic number: if (ipAddress.IsIPv4MappedToIPv6)                  ipAddress = new IPAddress(bytes.Skip(12).ToArray());
Magic Number,BitSharp.Network,NetworkEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Network\NetworkEncoder.cs,DecodeMessage,The following statement contains a magic number: var command = reader.ReadFixedString(12);
Magic Number,BitSharp.Network,NetworkEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Network\NetworkEncoder.cs,EncodeMessage,The following statement contains a magic number: writer.WriteFixedString(12' message.Command);
Magic Number,BitSharp.Network,NetworkEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Network\NetworkEncoder.cs,DecodeNetworkAddress,The following statement contains a magic number: return new NetworkAddress              (                  Services: reader.ReadUInt64()'                  IPv6Address: reader.ReadExactly(16).ToImmutableArray()'                  Port: reader.ReadUInt16BE()              );
Magic Number,BitSharp.Network,NetworkEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Network\NetworkEncoder.cs,EncodeNetworkAddress,The following statement contains a magic number: writer.WriteBytes(16' networkAddress.IPv6Address.ToArray());
Magic Number,BitSharp.Network,Peer,C:\repos\pmlyon_BitSharp\BitSharp.Network\Peer.cs,Peer,The following statement contains a magic number: this.blockMissCountMeasure = new CountMeasure(TimeSpan.FromMinutes(10));
Magic Number,BitSharp.Network,Peer,C:\repos\pmlyon_BitSharp\BitSharp.Network\Peer.cs,Peer,The following statement contains a magic number: this.blockMissCountMeasure = new CountMeasure(TimeSpan.FromMinutes(10));
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,Listen,The following statement contains a magic number: Task.Factory.StartNew(async () =>              {                  try                  {                      while (true)                      {                          var messageStart = await ReceiveExactly(4);                          await HandleMessage(messageStart);                      }                  }                  catch (Exception ex)                  {                      if (!(ex is ObjectDisposedException))                          logger.Error(ex' "Peer failed handling message.");                        Fail(ex);                  }              }' TaskCreationOptions.LongRunning);
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,HandleMessage,The following statement contains a magic number: if (logger.IsTraceEnabled)                  logger.Trace($"{socket.RemoteEndPoint'25} Received message {message.Command'12} in {stopwatch.ElapsedMilliseconds'6} ms");
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,HandleMessage,The following statement contains a magic number: if (logger.IsTraceEnabled)                  logger.Trace($"{socket.RemoteEndPoint'25} Received message {message.Command'12} in {stopwatch.ElapsedMilliseconds'6} ms");
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,HandleMessage,The following statement contains a magic number: if (logger.IsTraceEnabled)                  logger.Trace($"{socket.RemoteEndPoint'25} Received message {message.Command'12} in {stopwatch.ElapsedMilliseconds'6} ms");
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,WireDecodeMessage,The following statement contains a magic number: var command = DataDecoder.DecodeFixedString(await ReceiveExactly(12));
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,WireDecodeMessage,The following statement contains a magic number: var payloadSize = DataDecoder.DecodeUInt32(await ReceiveExactly(4));
Magic Number,BitSharp.Network,RemoteReceiver,C:\repos\pmlyon_BitSharp\BitSharp.Network\RemoteReceiver.cs,WireDecodeMessage,The following statement contains a magic number: var payloadChecksum = DataDecoder.DecodeUInt32(await ReceiveExactly(4));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.headersRequestWorker = new HeadersRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(5))'                  this' this.coreDaemon);
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.headersRequestWorker = new HeadersRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(5))'                  this' this.coreDaemon);
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.blockRequestWorker = new BlockRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(30))'                  this' this.coreDaemon);
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.blockRequestWorker = new BlockRequestWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(50)' maxIdleTime: TimeSpan.FromSeconds(30))'                  this' this.coreDaemon);
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.statsWorker = new WorkerMethod("LocalClient.StatsWorker"' StatsWorker' true' TimeSpan.FromSeconds(5)' TimeSpan.FromMinutes(5));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: this.statsWorker = new WorkerMethod("LocalClient.StatsWorker"' StatsWorker' true' TimeSpan.FromSeconds(5)' TimeSpan.FromMinutes(5));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following statement contains a magic number: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,DiscouragePeer,The following statement contains a magic number: if (this.networkPeerStorage.TryGetValue(peerEndPoint.ToNetworkAddressKey()' out address))              {                  var newTime = address.Time - TimeSpan.FromDays(7);                  this.networkPeerStorage[address.NetworkAddress.GetKey()] = address.With(Time: newTime);              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddKnownPeers,The following statement contains a magic number: foreach (var knownAddress in this.networkPeerStorage)              {                  this.peerWorker.AddCandidatePeer(                      new CandidatePeer                      (                          ipEndPoint: knownAddress.Value.NetworkAddress.ToIPEndPoint()'                          time: knownAddress.Value.Time + TimeSpan.FromDays(random.NextDouble(-2' +2))'                          isSeed: false                      ));                  count++;              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddKnownPeers,The following statement contains a magic number: foreach (var knownAddress in this.networkPeerStorage)              {                  this.peerWorker.AddCandidatePeer(                      new CandidatePeer                      (                          ipEndPoint: knownAddress.Value.NetworkAddress.ToIPEndPoint()'                          time: knownAddress.Value.Time + TimeSpan.FromDays(random.NextDouble(-2' +2))'                          isSeed: false                      ));                  count++;              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnInventoryVectors,The following statement contains a magic number: if (this.Type != ChainType.Regtest)              {                  var responseInvVectors = ImmutableArray.CreateBuilder<InventoryVector>();                    using (var chainState = coreDaemon.GetChainState())                  using (var unconfirmedTxes = coreDaemon.GetUnconfirmedTxes())                  {                      foreach (var invVector in invVectors)                      {                          // check if this is a transaction we don't have yet                          if (invVector.Type == InventoryVector.TYPE_MESSAGE_TRANSACTION                              && !unconfirmedTxes.ContainsTransaction(invVector.Hash)                              && !chainState.ContainsUnspentTx(invVector.Hash))                          {                              //logger.Info($"Requesting transaction {invVector.Hash}");                              responseInvVectors.Add(invVector);                          }                          // check if this is a block we don't have yet                          else if (invVector.Type == InventoryVector.TYPE_MESSAGE_TRANSACTION                              && !coreStorage.ContainsChainedHeader(invVector.Hash))                          {                              // ask for headers on a new block                              headersRequestWorker.SendGetHeaders(peer);                          }                      }                  }                    // request missing transactions                  if (responseInvVectors.Count > 0)                      peer.Sender.SendGetData(responseInvVectors.ToImmutable()).Wait();              }              else              {                  // don't process new inv request until previous inv request has finished                  while (this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }                  this.coreDaemon.ForceUpdateAndWait();                    var responseInvVectors = ImmutableArray.CreateBuilder<InventoryVector>();                    foreach (var invVector in invVectors)                  {                      if (invVector.Type == InventoryVector.TYPE_MESSAGE_BLOCK                          && !requestedComparisonBlocks.Contains(invVector.Hash)                          && !comparisonUnchainedBlocks.ContainsKey(invVector.Hash)                          && !this.coreStorage.ContainsBlockTxes(invVector.Hash))                      {                          logger.Info($"processing block inv: {invVector.Hash}");                          responseInvVectors.Add(invVector);                          requestedComparisonBlocks.Add(invVector.Hash);                      }                      else                      {                          logger.Info($"ignoring block inv: {invVector.Hash}' exists: {coreStorage.ContainsBlockTxes(invVector.Hash)}");                      }                  }                    if (responseInvVectors.Count > 0)                      connectedPeersLocal.Single().Sender.SendGetData(responseInvVectors.ToImmutable()).Wait();              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetBlocks,The following statement contains a magic number: var limit = 500;
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't send headers until all blocks requested from the comparison tool have been downloaded and processed                  while (this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }                  this.coreDaemon.ForceUpdateAndWait();              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetHeaders,The following statement contains a magic number: var limit = 500;
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnPing,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't pong back until:                  // - all blocks requested from the comparison tool have been downloaded and processed                  // - current header inventory has been sent to the comparison tool                  while (comparisonHeadersSentEvent.WaitOne(1000)                      && this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnPing,The following statement contains a magic number: if (this.Type == ChainType.Regtest)              {                  // don't pong back until:                  // - all blocks requested from the comparison tool have been downloaded and processed                  // - current header inventory has been sent to the comparison tool                  while (comparisonHeadersSentEvent.WaitOne(1000)                      && this.requestedComparisonBlocks.Count > 0 && comparisonBlockAddedEvent.WaitOne(1000))                  { }              }
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,StatsWorker,The following statement contains a magic number: logger.Info(string.Join("' "'                  $"UNCONNECTED: {this.peerWorker.UnconnectedPeersCount'3}"'                  $"PENDING: {this.peerWorker.PendingPeers.Count'3}"'                  $"CONNECTED: {this.peerWorker.ConnectedPeers.Count'3}"'                  $"BAD: {this.peerWorker.BadPeers.Count'3}"'                  $"INCOMING: {this.peerWorker.IncomingCount'3}"'                  $"MESSAGES/SEC: {this.messageRateMeasure.GetAverage()'6:N0}"              ));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,BlockRequestWorker,The following statement contains a magic number: this.blockRequestDurationMeasure = new DurationMeasure(sampleCutoff: TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,BlockRequestWorker,The following statement contains a magic number: this.duplicateBlockDownloadCountMeasure = new CountMeasure(TimeSpan.FromSeconds(30));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,BlockRequestWorker,The following statement contains a magic number: this.diagnosticWorker = new WorkerMethod("BlockRequestWorker.DiagnosticWorker"' DiagnosticWorkerMethod' initialNotify: true' minIdleTime: TimeSpan.FromSeconds(10)' maxIdleTime: TimeSpan.FromSeconds(10));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,BlockRequestWorker,The following statement contains a magic number: this.diagnosticWorker = new WorkerMethod("BlockRequestWorker.DiagnosticWorker"' DiagnosticWorkerMethod' initialNotify: true' minIdleTime: TimeSpan.FromSeconds(10)' maxIdleTime: TimeSpan.FromSeconds(10));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,UpdateLookAhead,The following statement contains a magic number: if (blockProcessingTime == TimeSpan.Zero)              {                  this.targetChainLookAhead = 1;              }              else              {                  // determine target chain look ahead                  this.targetChainLookAhead = 1 + (int)(LookAheadTime.TotalSeconds / blockProcessingTime.TotalSeconds);                    logger.Debug(new string('-'' 80));                  logger.Debug($"Look Ahead: {this.targetChainLookAhead:N0}");                  logger.Debug($"Block Request Count: {this.allBlockRequests.Count:N0}");                  logger.Debug(new string('-'' 80));              }
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,UpdateLookAhead,The following statement contains a magic number: if (blockProcessingTime == TimeSpan.Zero)              {                  this.targetChainLookAhead = 1;              }              else              {                  // determine target chain look ahead                  this.targetChainLookAhead = 1 + (int)(LookAheadTime.TotalSeconds / blockProcessingTime.TotalSeconds);                    logger.Debug(new string('-'' 80));                  logger.Debug($"Look Ahead: {this.targetChainLookAhead:N0}");                  logger.Debug($"Block Request Count: {this.allBlockRequests.Count:N0}");                  logger.Debug(new string('-'' 80));              }
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,SendBlockRequests,The following statement contains a magic number: await Task.WhenAny(                  Task.WhenAll(requestTasks.ToArray())'                  Task.Delay(TimeSpan.FromSeconds(10)).ContinueWith(_ => timedOut = true));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,DiagnosticWorkerMethod,The following statement contains a magic number: logger.Info(new string('-'' 80));
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetBlockPath,The following statement contains a magic number: var blockHashString = blockHash.ToString().Substring(64 - 8' 8);
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetBlockPath,The following statement contains a magic number: var blockHashString = blockHash.ToString().Substring(64 - 8' 8);
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetBlockPath,The following statement contains a magic number: var blockHashString = blockHash.ToString().Substring(64 - 8' 8);
Magic Number,BitSharp.Network.Workers,BlockRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\BlockRequestWorker.cs,GetBlockPath,The following statement contains a magic number: var chunkSize = 2;
Magic Number,BitSharp.Network.Workers,HeadersRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\HeadersRequestWorker.cs,WorkAction,The following statement contains a magic number: foreach (var peer in connectedPeers)              {                  // determine if a new request can be made                  if (this.headersRequestsByPeer.TryAdd(peer' now))                  {                      // send out the request for headers                      requestTasks.Add(peer.Sender.SendGetHeaders(blockLocatorHashes' hashStop: UInt256.Zero));                        // only send out a few header requests at a time                      requestCount++;                      if (requestCount >= 2)                          break;                  }              }
Magic Number,BitSharp.Network.Workers,HeadersRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\HeadersRequestWorker.cs,CalculateBlockLocatorHashes,The following statement contains a magic number: if (blockHashes.Count > 0)              {                  var step = 1;                  var start = 0;                  for (var i = blockHashes.Count - 1; i > 0; i -= step' start++)                  {                      if (start >= 10)                          step *= 2;                        blockLocatorHashes.Add(blockHashes[i].Hash);                  }                  blockLocatorHashes.Add(blockHashes[0].Hash);              }
Magic Number,BitSharp.Network.Workers,HeadersRequestWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\HeadersRequestWorker.cs,CalculateBlockLocatorHashes,The following statement contains a magic number: if (blockHashes.Count > 0)              {                  var step = 1;                  var start = 0;                  for (var i = blockHashes.Count - 1; i > 0; i -= step' start++)                  {                      if (start >= 10)                          step *= 2;                        blockLocatorHashes.Add(blockHashes[i].Hash);                  }                  blockLocatorHashes.Add(blockHashes[0].Hash);              }
Magic Number,BitSharp.Network.Workers,PeerWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\PeerWorker.cs,WorkAction,The following statement contains a magic number: foreach (var peer in this.connectedPeers)              {                  // clear out any disconnected peers                  if (!peer.IsConnected)                      DisconnectPeer(peer' null);                    if (this.connectedPeers.Count < 3)                      break;                    // disconnect seed peers' once enough peers are connected                  if (peer.IsSeed)                      DisconnectPeer(peer' null);                    // disconnect slow peers                  if (peer.BlockMissCount >= 5)                  {                      logger.Info($"Disconnecting slow peer: {peer.RemoteEndPoint}");                      DisconnectPeer(peer' null);                  }              }
Magic Number,BitSharp.Network.Workers,PeerWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\PeerWorker.cs,WorkAction,The following statement contains a magic number: foreach (var peer in this.connectedPeers)              {                  // clear out any disconnected peers                  if (!peer.IsConnected)                      DisconnectPeer(peer' null);                    if (this.connectedPeers.Count < 3)                      break;                    // disconnect seed peers' once enough peers are connected                  if (peer.IsSeed)                      DisconnectPeer(peer' null);                    // disconnect slow peers                  if (peer.BlockMissCount >= 5)                  {                      logger.Info($"Disconnecting slow peer: {peer.RemoteEndPoint}");                      DisconnectPeer(peer' null);                  }              }
Missing Default,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following switch statement is missing a default case: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Missing Default,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddSeedPeers,The following switch statement is missing a default case: switch (this.Type)              {                  case ChainType.MainNet:                      addSeed("seed.bitcoin.sipa.be");                      addSeed("dnsseed.bluematt.me");                      //addSeed("dnsseed.bitcoin.dashjr.org");                      addSeed("seed.bitcoinstats.com");                      //addSeed("seed.bitnodes.io");                      //addSeed("seeds.bitcoin.open-nodes.org");                      addSeed("bitseed.xf2.org");                      break;                    case ChainType.TestNet3:                      addSeed("testnet-seed.alexykot.me");                      addSeed("testnet-seed.bitcoin.petertodd.org");                      addSeed("testnet-seed.bluematt.me");                      break;              }
Missing Default,BitSharp.Network,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetData,The following switch statement is missing a default case: switch (invVector.Type)                  {                      case InventoryVector.TYPE_MESSAGE_BLOCK:                          //Block block;                          //if (this.blockCache.TryGetValue(invVector.Hash' out block))                          //{                          //    peer.Sender.SendBlock(block).Forget();                          //}                          break;                        case InventoryVector.TYPE_MESSAGE_TRANSACTION:                          //TODO                          break;                  }
Missing Default,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,LocalClient,The following switch statement is missing a default case: switch (this.Type)              {                  case ChainType.MainNet:                      Messaging.Port = 8333;                      Messaging.Magic = Messaging.MAGIC_MAIN;                      break;                    case ChainType.TestNet3:                      Messaging.Port = 18333;                      Messaging.Magic = Messaging.MAGIC_TESTNET3;                      break;                    case ChainType.Regtest:                      Messaging.Port = 18444;                      Messaging.Magic = Messaging.MAGIC_COMPARISON_TOOL;                      break;              }
Missing Default,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,AddSeedPeers,The following switch statement is missing a default case: switch (this.Type)              {                  case ChainType.MainNet:                      addSeed("seed.bitcoin.sipa.be");                      addSeed("dnsseed.bluematt.me");                      //addSeed("dnsseed.bitcoin.dashjr.org");                      addSeed("seed.bitcoinstats.com");                      //addSeed("seed.bitnodes.io");                      //addSeed("seeds.bitcoin.open-nodes.org");                      addSeed("bitseed.xf2.org");                      break;                    case ChainType.TestNet3:                      addSeed("testnet-seed.alexykot.me");                      addSeed("testnet-seed.bitcoin.petertodd.org");                      addSeed("testnet-seed.bluematt.me");                      break;              }
Missing Default,ExtensionMethods,LocalClient,C:\repos\pmlyon_BitSharp\BitSharp.Network\LocalClient.cs,OnGetData,The following switch statement is missing a default case: switch (invVector.Type)                  {                      case InventoryVector.TYPE_MESSAGE_BLOCK:                          //Block block;                          //if (this.blockCache.TryGetValue(invVector.Hash' out block))                          //{                          //    peer.Sender.SendBlock(block).Forget();                          //}                          break;                        case InventoryVector.TYPE_MESSAGE_TRANSACTION:                          //TODO                          break;                  }
Missing Default,BitSharp.Network.Workers,ListenWorker,C:\repos\pmlyon_BitSharp\BitSharp.Network\Workers\ListenWorker.cs,SubStart,The following switch statement is missing a default case: switch (this.localClient.Type)                  {                      case ChainType.MainNet:                      case ChainType.TestNet3:                          var externalIPAddress = Messaging.GetExternalIPAddress();                          var localhost = Dns.GetHostEntry(Dns.GetHostName());                            this.listenSocket = new Socket(externalIPAddress.AddressFamily' SocketType.Stream' ProtocolType.Tcp);                          this.listenSocket.Bind(new IPEndPoint(localhost.AddressList.Where(x => x.AddressFamily == externalIPAddress.AddressFamily).First()' Messaging.Port));                          break;                        case ChainType.Regtest:                          this.listenSocket = new Socket(AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);                          this.listenSocket.Bind(new IPEndPoint(IPAddress.Parse("127.0.0.1")' Messaging.Port));                          break;                  }
