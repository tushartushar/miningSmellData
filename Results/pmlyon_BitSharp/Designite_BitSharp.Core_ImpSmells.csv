Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitSharp.Core.Builders,ChainStateBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilder.cs,AddBlockAsync,The method has 143 lines of code.
Long Method,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The method has 126 lines of code.
Long Method,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The method has 182 lines of code.
Complex Method,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,ApplyChangesAsync,Cyclomatic complexity of the method is 17
Complex Method,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,Cyclomatic complexity of the method is 18
Complex Method,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,Cyclomatic complexity of the method is 10
Long Parameter List,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,CalculateBlockHash,The method has 6 parameters. Parameters: Version' PreviousBlock' MerkleRoot' Time' Bits' Nonce
Long Parameter List,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeBlockHeader,The method has 6 parameters. Parameters: Version' PreviousBlock' MerkleRoot' Time' Bits' Nonce
Long Parameter List,BitSharp.Core.Builders,BlockReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\BlockReplayer.cs,ReplayBlock,The method has 5 parameters. Parameters: coreStorage' chainState' blockHash' replayForward' cancelToken
Long Parameter List,BitSharp.Core.Builders,UtxoReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoReplayer.cs,ReplayFromTxIndex,The method has 5 parameters. Parameters: coreStorage' chainState' replayBlock' replayForward' cancelToken
Long Parameter List,BitSharp.Core.Builders,BlockValidator,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\BlockValidator.cs,ValidateBlockAsync,The method has 5 parameters. Parameters: coreStorage' rules' newChain' validatableTxes' cancelToken
Long Parameter List,BitSharp.Core.Builders,UtxoBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoBuilder.cs,Spend,The method has 7 parameters. Parameters: chainStateCursor' txIndex' tx' inputIndex' input' chainedHeader' blockSpentTxes
Long Parameter List,BitSharp.Core.Builders,UtxoBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoBuilder.cs,RollbackUtxo,The method has 5 parameters. Parameters: chainStateCursor' chain' chainedHeader' blockTxes' unmintedTxes
Long Parameter List,BitSharp.Core.Domain,BlockTxNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockTxNode.cs,BlockTxNode,The method has 5 parameters. Parameters: index' depth' hash' pruned' txBytes
Long Parameter List,BitSharp.Core.Domain,BlockTxNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockTxNode.cs,BlockTxNode,The method has 5 parameters. Parameters: index' depth' hash' pruned' encodedTx
Long Parameter List,BitSharp.Core.Domain,PrevTxOutput,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\PrevTxOutput.cs,PrevTxOutput,The method has 5 parameters. Parameters: txOutput' blockHeight' txIndex' txVersion' isCoinbase
Long Parameter List,BitSharp.Core.Domain,PrevTxOutput,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\PrevTxOutput.cs,PrevTxOutput,The method has 6 parameters. Parameters: value' scriptPublicKey' blockHeight' txIndex' txVersion' isCoinbase
Long Parameter List,BitSharp.Core.Domain,BlockchainPath,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockchainPath.cs,BlockchainPath,The method has 5 parameters. Parameters: fromBlock' toBlock' lastCommonBlock' rewindBlocks' advanceBlocks
Long Parameter List,BitSharp.Core.Domain,BlockHeader,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockHeader.cs,BlockHeader,The method has 7 parameters. Parameters: version' previousBlock' merkleRoot' time' bits' nonce' hash
Long Parameter List,BitSharp.Core.Domain,BlockHeader,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockHeader.cs,With,The method has 6 parameters. Parameters: Version' PreviousBlock' MerkleRoot' Time' Bits' Nonce
Long Parameter List,BitSharp.Core.Domain,BlockHeader,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockHeader.cs,Create,The method has 6 parameters. Parameters: version' previousBlock' merkleRoot' time' bits' nonce
Long Parameter List,BitSharp.Core.Domain,Transaction,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\Transaction.cs,Transaction,The method has 5 parameters. Parameters: version' inputs' outputs' lockTime' hash
Long Parameter List,BitSharp.Core.Domain,Transaction,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\Transaction.cs,CreateWith,The method has 5 parameters. Parameters: Version' Inputs' Outputs' LockTime' Hash
Long Parameter List,BitSharp.Core.Domain,UnspentTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\UnspentTx.cs,UnspentTx,The method has 6 parameters. Parameters: txHash' blockIndex' txIndex' txVersion' isCoinbase' outputStates
Long Parameter List,BitSharp.Core.Domain,UnspentTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\UnspentTx.cs,UnspentTx,The method has 7 parameters. Parameters: txHash' blockIndex' txIndex' txVersion' isCoinbase' length' state
Long Parameter List,BitSharp.Core.Rules,ICoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\ICoreRules.cs,ValidationTransactionScript,The method has 5 parameters. Parameters: newChain' tx' txInput' txInputIndex' prevTxOutput
Long Parameter List,BitSharp.Core.Rules,LibbitcoinConsensus,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\LibbitcoinConsensus.cs,verify_script,The method has 6 parameters. Parameters: transaction' transaction_size' prevout_script' prevout_script_size' tx_input_index' flags
Long Parameter List,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,ValidationTransactionScript,The method has 5 parameters. Parameters: newChain' tx' txInput' txInputIndex' prevTxOutput
Long Parameter List,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The method has 5 parameters. Parameters: script' index' op' data' readData
Long Parameter List,BitSharp.Core.Storage.Memory,MemoryChainStateStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryChainStateStorage.cs,MemoryChainStateStorage,The method has 10 parameters. Parameters: chainTip' unspentTxCount' totalTxCount' totalInputCount' totalOutputCount' unspentOutputCount' headers' unspentTransactions' blockSpentTxes' blockUnmintedTxes
Long Parameter List,BitSharp.Core.Storage.Memory,MemoryChainStateStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryChainStateStorage.cs,BeginTransaction,The method has 11 parameters. Parameters: chainTip' unspentTxCount' unspentOutputCount' totalTxCount' totalInputCount' totalOutputCount' headers' unspentTransactions' unspentTxOutputs' blockSpentTxes' blockUnmintedTxes
Long Parameter List,BitSharp.Core.Storage.Memory,MemoryChainStateStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryChainStateStorage.cs,CommitTransaction,The method has 11 parameters. Parameters: chainTip' unspentTxCount' unspentOutputCount' totalTxCount' totalInputCount' totalOutputCount' headers' unspentTransactions' unspentTxOutputs' blockSpentTxes' blockUnmintedTxes
Long Parameter List,BitSharp.Core.Storage.Memory,MemoryStorageManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryStorageManager.cs,MemoryStorageManager,The method has 9 parameters. Parameters: chainTip' unspentTxCount' unspentOutputCount' totalTxCount' totalInputCount' totalOutputCount' headers' unspentTransactions' spentTransactions
Long Parameter List,BitSharp.Core.Monitor,ChainPosition,C:\repos\pmlyon_BitSharp\BitSharp.Core\Monitor\ChainPosition.cs,ChainPosition,The method has 5 parameters. Parameters: blockHash' txIndex' txHash' inputIndex' outputIndex
Long Parameter List,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,VerifyScript,The method has 6 parameters. Parameters: blockHash' txIndex' scriptPubKey' tx' inputIndex' script
Long Parameter List,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The method has 6 parameters. Parameters: scriptPubKey' tx' inputIndex' script' stack' altStack
Long Parameter List,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,VerifySignature,The method has 8 parameters. Parameters: scriptPubKey' tx' sig' pubKey' inputIndex' hashType' txSignature' txSignatureHash
Long Parameter List,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreatePrivateKeyScript,The method has 5 parameters. Parameters: tx' inputIndex' hashType' privateKey' publicKey
Long Parameter List,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateSpendTransaction,The method has 7 parameters. Parameters: prevTx' prevInputIndex' hashType' value' fromPrivateKey' fromPublicKey' toPublicKey
Long Parameter List,BitSharp.Core.Workers,ChainStateWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\ChainStateWorker.cs,ChainStateWorker,The method has 5 parameters. Parameters: workerConfig' targetChainWorker' chainStateBuilder' rules' coreStorage
Long Identifier,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesStorage.cs,BeginTransaction,The length of the parameter unconfirmedTxesByPrevTxOutputKey is 32.
Long Identifier,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesStorage.cs,CommitTransaction,The length of the parameter unconfirmedTxesByPrevTxOutputKey is 32.
Long Identifier,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesStorage.cs,,The length of the parameter unconfirmedTxesByPrevTxOutputKey is 32.
Long Identifier,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesCursor.cs,,The length of the parameter unconfirmedTxesByPrevTxOutputKey is 32.
Long Identifier,BitSharp.Core.Workers,ChainStateWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\ChainStateWorker.cs,,The length of the parameter blockProcessingDurationMeasure is 30.
Long Statement,BitSharp.Core,BlockchainWalker,C:\repos\pmlyon_BitSharp\BitSharp.Core\BlockchainWalker.cs,GetBlockchainPath,The length of the statement  "                        return new BlockchainPath(fromBlock' toBlock' pathElement.ChainedHeader' rewindBlocks.ToImmutable()' advanceBlocks.ToImmutable()); " is 130.
Long Statement,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,CalculateBlockHash,The length of the statement  "            return new UInt256(SHA256Static.ComputeDoubleHash(DataEncoder.EncodeBlockHeader(Version' PreviousBlock' MerkleRoot' Time' Bits' Nonce))); " is 137.
Long Statement,BitSharp.Core.Builders,WorkItem,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\WorkQueueDictionary.cs,TryChange,The length of the statement  "                    else if (newOperation == WorkQueueOperation.Update && (operation == WorkQueueOperation.Add || operation == WorkQueueOperation.Update)) " is 134.
Long Statement,BitSharp.Core.Builders,DeferredDictionary<TKey;TValue>,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredDictionary.cs,TryRemove,The length of the statement  "            else if (read.ContainsKey(key) || updated.ContainsKey(key) || added.ContainsKey(key) || TryGetParentValue(key' out ignore)) " is 123.
Long Statement,BitSharp.Core.Builders,UtxoLookAhead,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoLookAhead.cs,InitWarmupUtxo,The length of the statement  "                new ExecutionDataflowBlockOptions { CancellationToken = cancelToken' MaxDegreeOfParallelism = Math.Min(Environment.ProcessorCount' deferredChainStateCursor.CursorCount) }); " is 172.
Long Statement,BitSharp.Core.Builders,UtxoReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoReplayer.cs,ReplayRollbackUtxo,The length of the statement  "                    //TODO DeferredChainStateCursor should be used in order to re-org the chainstate in memory and calculate the unminted information " is 129.
Long Statement,BitSharp.Core.Builders,UtxoReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoReplayer.cs,ReplayRollbackUtxo,The length of the statement  "                blockTxesBuffer.SendAndCompleteAsync(blockTxes.UsingAsEnumerable().Select(x => x.Decode()).Reverse()' cancelToken).Forget(); " is 124.
Long Statement,BitSharp.Core.Builders,UtxoReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoReplayer.cs,ReplayFromTxIndex,The length of the statement  "                blockTxesBuffer.SendAndCompleteAsync(blockTxes.UsingAsEnumerable().Select(x => x.Decode()).Reverse()' cancelToken).Forget(); " is 124.
Long Statement,BitSharp.Core.Builders,UtxoReplayer,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoReplayer.cs,InitLookupValidatableTx,The length of the statement  "                new ExecutionDataflowBlockOptions { CancellationToken = cancelToken' MaxDegreeOfParallelism = Math.Min(Environment.ProcessorCount' chainState.CursorCount) }); " is 158.
Long Statement,BitSharp.Core.Builders,TxLoader,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\TxLoader.cs,InitLoadTxInputAndReturnLoadedTx,The length of the statement  "                new ExecutionDataflowBlockOptions { CancellationToken = cancelToken' MaxDegreeOfParallelism = Environment.ProcessorCount }); " is 124.
Long Statement,BitSharp.Core.Builders,BlockValidator,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\BlockValidator.cs,InitTxValidator,The length of the statement  "                new ExecutionDataflowBlockOptions { CancellationToken = cancelToken' MaxDegreeOfParallelism = Environment.ProcessorCount }); " is 124.
Long Statement,BitSharp.Core.Builders,BlockValidator,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\BlockValidator.cs,InitScriptValidator,The length of the statement  "                new ExecutionDataflowBlockOptions { CancellationToken = cancelToken' MaxDegreeOfParallelism = Environment.ProcessorCount }); " is 124.
Long Statement,BitSharp.Core.Builders,UtxoBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoBuilder.cs,CalculateUtxo,The length of the statement  "                    // ignore the first occurrences of these duplicates so that they do not need to later be deleted from the utxo' an unsupported operation " is 136.
Long Statement,BitSharp.Core.Builders,UtxoBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoBuilder.cs,Mint,The length of the statement  "            var unspentTx = new UnspentTx(tx.Hash' chainedHeader.Height' txIndex' tx.Version' tx.IsCoinbase' tx.Outputs.Length' OutputState.Unspent); " is 137.
Long Statement,BitSharp.Core.Builders,ChainStateBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilder.cs,CreateMerkleRootException,The length of the statement  "            return new ValidationException(chainedHeader.Hash' $"Failing block {chainedHeader.Hash} at height {chainedHeader.Height}: Merkle root is invalid"); " is 147.
Long Statement,BitSharp.Core.Domain,BlockTxNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockTxNode.cs,ToBlockTx,The length of the statement  "                throw new InvalidOperationException($"Cannot convert a BlockTxNode to a BlockTx with pruned: {Pruned} and depth: {Depth}"); " is 123.
Long Statement,BitSharp.Core.Domain,BlockTxNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockTxNode.cs,Equals,The length of the statement  "            return other.Index == this.Index && other.Depth == this.Depth && other.Hash == this.Hash && other.Pruned == this.Pruned; " is 120.
Long Statement,BitSharp.Core.Domain,PrevTxOutput,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\PrevTxOutput.cs,Equals,The length of the statement  "            return other.Value == this.Value && other.ScriptPublicKey.SequenceEqual(this.ScriptPublicKey) && other.BlockHeight == this.BlockHeight && other.TxIndex == this.TxIndex && other.TxVersion == this.TxVersion; " is 205.
Long Statement,BitSharp.Core.Domain,LoadedTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\LoadedTx.cs,GetInputPrevTxOutput,The length of the statement  "                throw new InvalidOperationException($"{nameof(prevTxOutputIndex)} of {prevTxOutputIndex} is < 0 or >= {prevTxOutputsLength}"); " is 126.
Long Statement,BitSharp.Core.Domain,BlockchainPath,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\BlockchainPath.cs,CreateSingleBlockPath,The length of the statement  "            return new BlockchainPath(chainedHeader' chainedHeader' chainedHeader' ImmutableList.Create<ChainedHeader>()' ImmutableList.Create<ChainedHeader>()); " is 149.
Long Statement,BitSharp.Core.Domain,SpentTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\SpentTx.cs,Equals,The length of the statement  "            return other.TxHash == this.TxHash && other.ConfirmedBlockIndex == this.ConfirmedBlockIndex && other.TxIndex == this.TxIndex; " is 125.
Long Statement,BitSharp.Core.Domain,UnspentTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\UnspentTx.cs,SetOutputState,The length of the statement  "            return new UnspentTx(this.TxHash' this.BlockIndex' this.TxIndex' this.TxVersion' this.IsCoinbase' this.OutputStates.Set(index' value)); " is 135.
Long Statement,BitSharp.Core.Domain,UnspentTx,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\UnspentTx.cs,Equals,The length of the statement  "            return other.TxHash == this.TxHash && other.BlockIndex == this.BlockIndex && other.TxIndex == this.TxIndex && other.TxVersion == this.TxVersion && other.IsCoinbase == this.IsCoinbase && other.OutputStates.Equals(this.OutputStates); " is 231.
Long Statement,BitSharp.Core.Domain,MerkleTreeNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\MerkleTreeNode.cs,Equals,The length of the statement  "            return other.Index == this.Index && other.Depth == this.Depth && other.Hash == this.Hash && other.Pruned == this.Pruned; " is 120.
Long Statement,BitSharp.Core.Rules,LibbitcoinConsensus,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\LibbitcoinConsensus.cs,VerifyScript,The length of the statement  "            return verify_script(txBytes.ToArray()' (UIntPtr)txBytes.Length' prevTxOutputPublicScriptBytes.ToArray()' (UIntPtr)prevTxOutputPublicScriptBytes.Length' (uint)inputIndex' flags) " is 177.
Long Statement,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PreValidateBlock,The length of the statement  "                    $"Failing block {chainedHeader.Hash} at height {chainedHeader.Height}: Block bits {chainedHeader.Bits} did not match required bits of {requiredBits}"); " is 151.
Long Statement,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PreValidateBlock,The length of the statement  "                    $"Failing block {chainedHeader.Hash} at height {chainedHeader.Height}: Block did not match its own target of {blockTarget}"); " is 125.
Long Statement,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PreValidateBlock,The length of the statement  "                        $"Failing block {chainedHeader.Hash} at height {chainedHeader.Height}: Block's time of {blockTime} must be greater than past median time of {medianPrevHeaderTime}"); " is 165.
Long Statement,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The length of the statement  "                    throw new ValidationException(chainedHeader.Hash' $"Failing tx {tx.Hash}: Transaction output value is greater than input value"); " is 129.
Long Statement,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The length of the statement  "                    dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24); " is 130.
Long Statement,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesStorage.cs,BeginTransaction,The length of the statement  "                unconfirmedTxesByPrevTxOutputKey = this.unconfirmedTxesByPrevTxOutputKey.AsUncommitted(x => x.ToImmutable().ToBuilder()); " is 121.
Long Statement,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,VerifyScript,The length of the statement  "@"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " is 162.
Long Statement,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,VerifyScript,The length of the statement  "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" " is 161.
Long Statement,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The length of the statement  "                                var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash); " is 124.
Long Statement,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The length of the statement  "    result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0")); " is 206.
Long Statement,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The length of the statement  "                                var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}"; " is 127.
Long Statement,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateSpendTransaction,The length of the statement  "            var scriptSignature = CreatePrivateKeyScript(tx.Transaction' 0' hashType' fromPrivateKey' fromPublicKey).ToImmutableArray(); " is 124.
Long Statement,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateSpendTransaction,The length of the statement  "            tx = tx.Transaction.CreateWith(Inputs: ImmutableArray.Create(tx.Transaction.Inputs[0].With(scriptSignature: scriptSignature))); " is 127.
Long Statement,BitSharp.Core.Workers,StatsWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\StatsWorker.cs,WorkAction,The length of the statement  "                            statsString.AppendLine($"[StatsWorker] Block {chainedHeader.Height}' {chainedHeader.Hash} confirmed at: {confirmTime}"); " is 120.
Long Statement,BitSharp.Core.Workers,StatsWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\StatsWorker.cs,OnTxesConfirmed,The length of the statement  "                    confirmedTx => new ConfirmedTxStats(confirmedTx.Hash' confirmTime - confirmedTx.DateSeen' confirmedTx.Fee' confirmedTx.TxByteSize)) " is 131.
Long Statement,BitSharp.Core.Workers,StatsWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\StatsWorker.cs,OnTxesConfirmed,The length of the statement  "                confirmedBlockStatsByHeight[e.ConfirmBlock.Height] = new ConfirmedBlockStats(e.ConfirmBlock' confirmedTxes' confirmTime); " is 121.
Long Statement,BitSharp.Core.Workers,TargetChainWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\TargetChainWorker.cs,UpdateTargetChain,The length of the statement  "                        var deltaBlockPath = new BlockchainWalker().GetBlockchainPath(newTargetChain.LastBlock' targetBlockLocal' blockHash => this.coreStorage.GetChainedHeader(blockHash)); " is 165.
Long Statement,BitSharp.Core.Workers,TargetChainWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\TargetChainWorker.cs,UpdateTargetChain,The length of the statement  "                        logger.Debug($"Winning chained block {newTargetChain.LastBlock.Hash} at height {newTargetChain.Height}' total work: {newTargetChain.LastBlock.TotalWork:X}"); " is 157.
Complex Conditional,BitSharp.Core.Builders,DeferredDictionary<TKey;TValue>,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredDictionary.cs,TryRemove,The conditional expression  "read.ContainsKey(key) || updated.ContainsKey(key) || added.ContainsKey(key) || TryGetParentValue(key' out ignore)"  is complex.
Complex Conditional,BitSharp.Core.Storage.Memory,MemoryUnconfirmedTxesStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryUnconfirmedTxesStorage.cs,CommitTransaction,The conditional expression  "this.chainTip.ConflictsWith(chainTip)                      || this.unconfirmedTxCount.ConflictsWith(unconfirmedTxCount)                      || this.unconfirmedTxes.ConflictsWith(unconfirmedTxes)                      || this.unconfirmedTxesByPrevTxOutputKey.ConflictsWith(unconfirmedTxesByPrevTxOutputKey)"  is complex.
Complex Conditional,BitSharp.Core.Storage.Memory,MemoryChainStateStorage,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryChainStateStorage.cs,CommitTransaction,The conditional expression  "this.chainTip.ConflictsWith(chainTip)                      || this.unspentTxCount.ConflictsWith(unspentTxCount)                      || this.unspentOutputCount.ConflictsWith(unspentOutputCount)                      || this.totalTxCount.ConflictsWith(totalTxCount)                      || this.totalInputCount.ConflictsWith(totalInputCount)                      || this.totalOutputCount.ConflictsWith(totalOutputCount)                      || this.headers.ConflictsWith(headers)                      || this.unspentTransactions.ConflictsWith(unspentTransactions)                      || this.unspentTxOutputs.ConflictsWith(unspentTxOutputs)                      || this.blockSpentTxes.ConflictsWith(blockSpentTxes)                      || this.blockUnmintedTxes.ConflictsWith(blockUnmintedTxes)"  is complex.
Empty Catch Block,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,Dispose,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,Dispose,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,BeginTransaction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,BeginTransaction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Builders,DeferredChainStateCursor,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\DeferredChainStateCursor.cs,RollbackTransaction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.JsonRpc,ListenerWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\JsonRpc\CoreRpcServer.cs,WorkAction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Workers,UnconfirmedTxesWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\UnconfirmedTxesWorker.cs,WorkAction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Workers,ChainStateWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\ChainStateWorker.cs,WorkAction,The method has an empty catch block.
Empty Catch Block,BitSharp.Core.Workers,TargetChainWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\TargetChainWorker.cs,UpdateTargetChain,The method has an empty catch block.
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeBlock,The following statement contains a magic number: var header = DecodeBlockHeader(null' reader.ReadExactly(80));
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeBlockHeader,The following statement contains a magic number: blockHash = blockHash ?? new UInt256(SHA256Static.ComputeDoubleHash(buffer' initialOffset' 80));
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeTotalWork,The following statement contains a magic number: var totalWorkBytes = new byte[64];
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeTotalWork,The following statement contains a magic number: Buffer.BlockCopy(buffer' 0' totalWorkBytes' 0' 64);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: var txBytes = new byte[1024];
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: reader.ReadExactly(txBytes' offset' 4);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: offset += 4;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < inputCount; i++)              {                  // read prevTxHash and prevTxOutputIndex                  SizeAtLeast(ref txBytes' offset + 36);                  reader.ReadExactly(txBytes' offset' 36);                  offset += 36;                    // read scriptSignatureLength                  var scriptSignatureLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptSignature                  SizeAtLeast(ref txBytes' offset + scriptSignatureLength);                  reader.ReadExactly(txBytes' offset' scriptSignatureLength);                  offset += scriptSignatureLength;                    // read sequence                  SizeAtLeast(ref txBytes' offset + 4);                  reader.ReadExactly(txBytes' offset' 4);                  offset += 4;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < outputCount; i++)              {                  // read value                  SizeAtLeast(ref txBytes' offset + 8);                  reader.ReadExactly(txBytes' offset' 8);                  offset += 8;                    // read scriptPublicKeyLength                  var scriptPublicKeyLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptPublicKey                  SizeAtLeast(ref txBytes' offset + scriptPublicKeyLength);                  reader.ReadExactly(txBytes' offset' scriptPublicKeyLength);                  offset += scriptPublicKeyLength;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < outputCount; i++)              {                  // read value                  SizeAtLeast(ref txBytes' offset + 8);                  reader.ReadExactly(txBytes' offset' 8);                  offset += 8;                    // read scriptPublicKeyLength                  var scriptPublicKeyLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptPublicKey                  SizeAtLeast(ref txBytes' offset + scriptPublicKeyLength);                  reader.ReadExactly(txBytes' offset' scriptPublicKeyLength);                  offset += scriptPublicKeyLength;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: for (var i = 0; i < outputCount; i++)              {                  // read value                  SizeAtLeast(ref txBytes' offset + 8);                  reader.ReadExactly(txBytes' offset' 8);                  offset += 8;                    // read scriptPublicKeyLength                  var scriptPublicKeyLength = reader.ReadVarInt(ref txBytes' ref offset).ToIntChecked();                    // read scriptPublicKey                  SizeAtLeast(ref txBytes' offset + scriptPublicKeyLength);                  reader.ReadExactly(txBytes' offset' scriptPublicKeyLength);                  offset += scriptPublicKeyLength;              }
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: SizeAtLeast(ref txBytes' offset + 4);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: reader.ReadExactly(txBytes' offset' 4);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,ReadTransaction,The following statement contains a magic number: offset += 4;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeOutputStates,The following statement contains a magic number: var outputStateBytes = new byte[buffer.Length - 4];
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeOutputStates,The following statement contains a magic number: Buffer.BlockCopy(buffer' 4' outputStateBytes' 0' buffer.Length - 4);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeOutputStates,The following statement contains a magic number: Buffer.BlockCopy(buffer' 4' outputStateBytes' 0' buffer.Length - 4);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,SizeAtLeast,The following statement contains a magic number: if (buffer.Length < minLength)                  Array.Resize(ref buffer' ((minLength + 1023) / 1024) * 1024);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,SizeAtLeast,The following statement contains a magic number: if (buffer.Length < minLength)                  Array.Resize(ref buffer' ((minLength + 1023) / 1024) * 1024);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,SizeAtLeast,The following statement contains a magic number: if (buffer.Length < minLength)                  Array.Resize(ref buffer' ((minLength + 1023) / 1024) * 1024);
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeInt32,The following statement contains a magic number: offset += 4;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeUInt32,The following statement contains a magic number: offset += 4;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeInt64,The following statement contains a magic number: offset += 8;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeUInt64,The following statement contains a magic number: offset += 8;
Magic Number,BitSharp.Core,DataDecoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataDecoder.cs,DecodeUInt256,The following statement contains a magic number: offset += 32;
Magic Number,BitSharp.Core,MerkleStream<T>,C:\repos\pmlyon_BitSharp\BitSharp.Core\MerkleStream.cs,ClosePairs,The following statement contains a magic number: while (this.leftNodes.Count >= 2)              {                  var leftNode = this.leftNodes[this.leftNodes.Count - 2];                  var rightNode = this.leftNodes[this.leftNodes.Count - 1];                    if (leftNode.Depth == rightNode.Depth)                  {                      this.leftNodes.RemoveAt(this.leftNodes.Count - 1);                      this.leftNodes[this.leftNodes.Count - 1] = leftNode.PairWith(rightNode);                  }                  else                  {                      break;                  }              }
Magic Number,BitSharp.Core,MerkleStream<T>,C:\repos\pmlyon_BitSharp\BitSharp.Core\MerkleStream.cs,ClosePairs,The following statement contains a magic number: while (this.leftNodes.Count >= 2)              {                  var leftNode = this.leftNodes[this.leftNodes.Count - 2];                  var rightNode = this.leftNodes[this.leftNodes.Count - 1];                    if (leftNode.Depth == rightNode.Depth)                  {                      this.leftNodes.RemoveAt(this.leftNodes.Count - 1);                      this.leftNodes[this.leftNodes.Count - 1] = leftNode.PairWith(rightNode);                  }                  else                  {                      break;                  }              }
Magic Number,BitSharp.Core,MerkleTree,C:\repos\pmlyon_BitSharp\BitSharp.Core\MerkleTree.cs,PairHashes,The following statement contains a magic number: var bytes = new byte[64];
Magic Number,BitSharp.Core,MerkleTree,C:\repos\pmlyon_BitSharp\BitSharp.Core\MerkleTree.cs,PairHashes,The following statement contains a magic number: right.ToByteArray(bytes' 32);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: targetChainWorker = new TargetChainWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(0)' maxIdleTime: TimeSpan.FromSeconds(30))'                  ChainParams' coreStorage);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: chainStateWorker = new ChainStateWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(0)' maxIdleTime: TimeSpan.FromSeconds(5))'                  targetChainWorker' chainStateBuilder' this.rules' coreStorage);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: unconfirmedTxesWorker = new UnconfirmedTxesWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMilliseconds(0)' maxIdleTime: TimeSpan.FromSeconds(5))'                  chainStateWorker' unconfirmedTxesBuilder' coreStorage);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: pruningWorker = new PruningWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromSeconds(0)' maxIdleTime: TimeSpan.FromMinutes(5))'                  this' this.storageManager' chainStateWorker);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: defragWorker = new DefragWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMinutes(5)' maxIdleTime: TimeSpan.FromMinutes(5))'                  this.storageManager);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: defragWorker = new DefragWorker(                  new WorkerConfig(initialNotify: true' minIdleTime: TimeSpan.FromMinutes(5)' maxIdleTime: TimeSpan.FromMinutes(5))'                  this.storageManager);
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: gcWorker = new WorkerMethod("GC Worker"' GcWorker'                  initialNotify: true' minIdleTime: TimeSpan.FromMinutes(5)' maxIdleTime: TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: gcWorker = new WorkerMethod("GC Worker"' GcWorker'                  initialNotify: true' minIdleTime: TimeSpan.FromMinutes(5)' maxIdleTime: TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: utxoScanWorker = new WorkerMethod("UTXO Scan Worker"' UtxoScanWorker'                  initialNotify: true' minIdleTime: TimeSpan.FromSeconds(60)' maxIdleTime: TimeSpan.FromSeconds(60));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,CoreDaemon,The following statement contains a magic number: utxoScanWorker = new WorkerMethod("UTXO Scan Worker"' UtxoScanWorker'                  initialNotify: true' minIdleTime: TimeSpan.FromSeconds(60)' maxIdleTime: TimeSpan.FromSeconds(60));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,GcWorker,The following statement contains a magic number: logger.Info(                  string.Join("\n"'                      new string('-'' 80)'                      $"GC Memory:      {(float)GC.GetTotalMemory(false) / 1.MILLION()'10:N2} MB"'                      $"Process Memory: {(float)Process.GetCurrentProcess().PrivateMemorySize64 / 1.MILLION()'10:N2} MB"'                      new string('-'' 80)                  ));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,GcWorker,The following statement contains a magic number: logger.Info(                  string.Join("\n"'                      new string('-'' 80)'                      $"GC Memory:      {(float)GC.GetTotalMemory(false) / 1.MILLION()'10:N2} MB"'                      $"Process Memory: {(float)Process.GetCurrentProcess().PrivateMemorySize64 / 1.MILLION()'10:N2} MB"'                      new string('-'' 80)                  ));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,GcWorker,The following statement contains a magic number: logger.Info(                  string.Join("\n"'                      new string('-'' 80)'                      $"GC Memory:      {(float)GC.GetTotalMemory(false) / 1.MILLION()'10:N2} MB"'                      $"Process Memory: {(float)Process.GetCurrentProcess().PrivateMemorySize64 / 1.MILLION()'10:N2} MB"'                      new string('-'' 80)                  ));
Magic Number,BitSharp.Core,CoreDaemon,C:\repos\pmlyon_BitSharp\BitSharp.Core\CoreDaemon.cs,GcWorker,The following statement contains a magic number: logger.Info(                  string.Join("\n"'                      new string('-'' 80)'                      $"GC Memory:      {(float)GC.GetTotalMemory(false) / 1.MILLION()'10:N2} MB"'                      $"Process Memory: {(float)Process.GetCurrentProcess().PrivateMemorySize64 / 1.MILLION()'10:N2} MB"'                      new string('-'' 80)                  ));
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: var size = (int)(compact >> 24);
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: if (size <= 3)              {                  word >>= 8 * (3 - size);                  value = (UInt256)word;              }              else              {                  value = (UInt256)word;                  value <<= 8 * (size - 3);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: if (size <= 3)              {                  word >>= 8 * (3 - size);                  value = (UInt256)word;              }              else              {                  value = (UInt256)word;                  value <<= 8 * (size - 3);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: if (size <= 3)              {                  word >>= 8 * (3 - size);                  value = (UInt256)word;              }              else              {                  value = (UInt256)word;                  value <<= 8 * (size - 3);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: if (size <= 3)              {                  word >>= 8 * (3 - size);                  value = (UInt256)word;              }              else              {                  value = (UInt256)word;                  value <<= 8 * (size - 3);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: if (size <= 3)              {                  word >>= 8 * (3 - size);                  value = (UInt256)word;              }              else              {                  value = (UInt256)word;                  value <<= 8 * (size - 3);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: overflow = word != 0 && ((size > 34) ||                                       (word > 0xff && size > 33) ||                                       (word > 0xffff && size > 32));
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: overflow = word != 0 && ((size > 34) ||                                       (word > 0xff && size > 33) ||                                       (word > 0xffff && size > 32));
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,FromCompact,The following statement contains a magic number: overflow = word != 0 && ((size > 34) ||                                       (word > 0xff && size > 33) ||                                       (word > 0xffff && size > 32));
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: var size = (HighBit(value) + 7) / 8;
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: var size = (HighBit(value) + 7) / 8;
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if (size <= 3)              {                  compact = (uint)(value.Part4 << 8 * (3 - size));              }              else              {                  value >>= 8 * (size - 3);                  compact = (uint)(value.Part4);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if (size <= 3)              {                  compact = (uint)(value.Part4 << 8 * (3 - size));              }              else              {                  value >>= 8 * (size - 3);                  compact = (uint)(value.Part4);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if (size <= 3)              {                  compact = (uint)(value.Part4 << 8 * (3 - size));              }              else              {                  value >>= 8 * (size - 3);                  compact = (uint)(value.Part4);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if (size <= 3)              {                  compact = (uint)(value.Part4 << 8 * (3 - size));              }              else              {                  value >>= 8 * (size - 3);                  compact = (uint)(value.Part4);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if (size <= 3)              {                  compact = (uint)(value.Part4 << 8 * (3 - size));              }              else              {                  value >>= 8 * (size - 3);                  compact = (uint)(value.Part4);              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: if ((compact & 0x00800000) != 0)              {                  compact >>= 8;                  size++;              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: Debug.Assert(size < 256);
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,ToCompact,The following statement contains a magic number: compact |= (uint)(size << 24);
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,HighBit,The following statement contains a magic number: for (var pos = parts.Length - 1; pos >= 0; pos--)              {                  var part = parts[pos];                  if (part != 0)                  {                      for (var bits = 63; bits > 0; bits--)                      {                          if ((part & 1UL << bits) != 0)                              return 64 * pos + bits + 1;                      }                      return 64 * pos + 1;                  }              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,HighBit,The following statement contains a magic number: for (var pos = parts.Length - 1; pos >= 0; pos--)              {                  var part = parts[pos];                  if (part != 0)                  {                      for (var bits = 63; bits > 0; bits--)                      {                          if ((part & 1UL << bits) != 0)                              return 64 * pos + bits + 1;                      }                      return 64 * pos + 1;                  }              }
Magic Number,BitSharp.Core,DataCalculator,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataCalculator.cs,HighBit,The following statement contains a magic number: for (var pos = parts.Length - 1; pos >= 0; pos--)              {                  var part = parts[pos];                  if (part != 0)                  {                      for (var bits = 63; bits > 0; bits--)                      {                          if ((part & 1UL << bits) != 0)                              return 64 * pos + bits + 1;                      }                      return 64 * pos + 1;                  }              }
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeTotalWork,The following statement contains a magic number: if (totalWorkBytesLittleEndian.Length > 64)                  throw new ArgumentOutOfRangeException();
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeTotalWork,The following statement contains a magic number: var totalWorkBytesLittleEndian64 = new byte[64];
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeOutputStates,The following statement contains a magic number: var buffer = new byte[4 + outputStateBytes.Length];
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeOutputStates,The following statement contains a magic number: Buffer.BlockCopy(BitConverter.GetBytes(outputStates.Length)' 0' buffer' 0' 4);
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,EncodeOutputStates,The following statement contains a magic number: Buffer.BlockCopy(outputStateBytes' 0' buffer' 4' outputStateBytes.Length);
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,VarIntSize,The following statement contains a magic number: if (value < 0xFD)              {                  return 1;              }              else if (value <= 0xFFFF)              {                  return 3;              }              else if (value <= 0xFFFFFFFF)              {                  return 5;              }              else              {                  return 9;              }
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,VarIntSize,The following statement contains a magic number: if (value < 0xFD)              {                  return 1;              }              else if (value <= 0xFFFF)              {                  return 3;              }              else if (value <= 0xFFFFFFFF)              {                  return 5;              }              else              {                  return 9;              }
Magic Number,BitSharp.Core,DataEncoder,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoder.cs,VarIntSize,The following statement contains a magic number: if (value < 0xFD)              {                  return 1;              }              else if (value <= 0xFFFF)              {                  return 3;              }              else if (value <= 0xFFFFFFFF)              {                  return 5;              }              else              {                  return 9;              }
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Height:           {Height'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Duration:         {durationFormatted'15}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Blocks Rate:      {blockRateMeasure.GetAverage()'15:N0}/s");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Tx Rate:          {txRateMeasure.GetAverage()'15:N0}/s");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Input Rate:       {inputRateMeasure.GetAverage()'15:N0}/s");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Txes per block:   {txesPerBlockMeasure.GetAverage()'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Inputs per block: {inputsPerBlockMeasure.GetAverage()'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Processed Txes:   {TotalTxCount'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Processed Inputs: {TotalInputCount'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Utx Size:         {UnspentTxCount'15:N0}");
Magic Number,BitSharp.Core.Builders,ChainStateBuilderStats,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilderStats.cs,ToString,The following statement contains a magic number: statString.AppendLine($"Utxo Size:        {UnspentOutputCount'15:N0}");
Magic Number,BitSharp.Core.Builders,UtxoLookAhead,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\UtxoLookAhead.cs,InitQueueUnspentTxLookup,The following statement contains a magic number: return new TransformManyBlock<DecodedBlockTx' Tuple<TxOutputKey' CompletionCount' DecodedBlockTx>>(                  blockTx =>                  {                      var tx = blockTx.Transaction;                        var outputCount = tx.Outputs.Length;                      var inputCount = !blockTx.IsCoinbase ? tx.Inputs.Length * 2 : 0;                        var txOutputKeys = new Tuple<TxOutputKey' CompletionCount' DecodedBlockTx>[1 + outputCount + inputCount];                      var completionCount = new CompletionCount(txOutputKeys.Length);                      var keyIndex = 0;                        // warm-up the UnspentTx entry that will be added for the new tx                      txOutputKeys[keyIndex++] = Tuple.Create(new TxOutputKey(blockTx.Hash' uint.MaxValue)' completionCount' blockTx);                        // warm-up the TxOutput entries that will be added for each of the tx's outputs                      for (var outputIndex = 0; outputIndex < tx.Outputs.Length; outputIndex++)                      {                          var txOutputKey = new TxOutputKey(blockTx.Hash' (uint)outputIndex);                          txOutputKeys[keyIndex++] = Tuple.Create(txOutputKey' completionCount' blockTx);                      }                        // warm-up the previous UnspentTx and TxOutput entries that will be needed for each of the tx's inputs                      if (!blockTx.IsCoinbase)                      {                          for (var inputIndex = 0; inputIndex < tx.Inputs.Length; inputIndex++)                          {                              var input = tx.Inputs[inputIndex];                                // input's previous tx's UnspentTx entry                              var txOutputKey = new TxOutputKey(input.PrevTxHash' uint.MaxValue);                              txOutputKeys[keyIndex++] = Tuple.Create(txOutputKey' completionCount' blockTx);                                // input's previous tx outputs's TxOutput entry                              txOutputKey = input.PrevTxOutputKey;                              txOutputKeys[keyIndex++] = Tuple.Create(txOutputKey' completionCount' blockTx);                          }                      }                        Debug.Assert(txOutputKeys.All(x => x != null));                        return txOutputKeys;                  }'                  new ExecutionDataflowBlockOptions { CancellationToken = cancelToken });
Magic Number,BitSharp.Core.Builders,ChainStateBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Builders\ChainStateBuilder.cs,LogBlockchainProgress,The following statement contains a magic number: Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  logger.Info(stats.ToString()));
Magic Number,BitSharp.Core.Domain,UnconfirmedTxes,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\UnconfirmedTxes.cs,UnconfirmedTxes,The following statement contains a magic number: CursorCount = 32;
Magic Number,BitSharp.Core.Domain,IMerkleTreeNode_ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\IMerkleTreeNode.cs,Pair,The following statement contains a magic number: var pairHashBytes = new byte[64];
Magic Number,BitSharp.Core.Domain,IMerkleTreeNode_ExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\IMerkleTreeNode.cs,Pair,The following statement contains a magic number: right.Hash.ToByteArray(pairHashBytes' 32);
Magic Number,BitSharp.Core.Domain,PrevTxOutput,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\PrevTxOutput.cs,IsPayToScriptHash,The following statement contains a magic number: return ScriptPublicKey.Length == 23                  && ScriptPublicKey[0] == (byte)ScriptOp.OP_HASH160                  && ScriptPublicKey[1] == 0x14 // push 20 bytes                  && ScriptPublicKey[22] == (byte)ScriptOp.OP_EQUAL;
Magic Number,BitSharp.Core.Domain,PrevTxOutput,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\PrevTxOutput.cs,IsPayToScriptHash,The following statement contains a magic number: return ScriptPublicKey.Length == 23                  && ScriptPublicKey[0] == (byte)ScriptOp.OP_HASH160                  && ScriptPublicKey[1] == 0x14 // push 20 bytes                  && ScriptPublicKey[22] == (byte)ScriptOp.OP_EQUAL;
Magic Number,BitSharp.Core.Domain,TxLookupKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxLookupKey.cs,TxLookupKey,The following statement contains a magic number: var hashBytes = new byte[36];
Magic Number,BitSharp.Core.Domain,TxLookupKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxLookupKey.cs,TxLookupKey,The following statement contains a magic number: Bits.EncodeInt32(txIndex' hashBytes' 32);
Magic Number,BitSharp.Core.Domain,TxLookupKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxLookupKey.cs,TxLookupKey,The following statement contains a magic number: hashCode = Bits.ToInt32(new xxHash(32).ComputeHash(hashBytes));
Magic Number,BitSharp.Core.Domain,TxOutputKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxOutputKey.cs,TxOutputKey,The following statement contains a magic number: var hashBytes = new byte[36];
Magic Number,BitSharp.Core.Domain,TxOutputKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxOutputKey.cs,TxOutputKey,The following statement contains a magic number: Bits.EncodeUInt32(txOutputIndex' hashBytes' 32);
Magic Number,BitSharp.Core.Domain,TxOutputKey,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\TxOutputKey.cs,TxOutputKey,The following statement contains a magic number: hashCode = Bits.ToInt32(new xxHash(32).ComputeHash(hashBytes));
Magic Number,BitSharp.Core.Domain,MerkleTreeNode,C:\repos\pmlyon_BitSharp\BitSharp.Core\Domain\MerkleTreeNode.cs,MerkleTreeNode,The following statement contains a magic number: if (depth < 0 || depth > 31)                  throw new ArgumentException("depth");
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PreValidateBlock,The following statement contains a magic number: var maxBlockTime = adjustedTime + TimeSpan.FromHours(2);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PreValidateBlock,The following statement contains a magic number: if (chainedHeader.Height > 0)              {                  var medianTimeSpan = Math.Min(11' newChain.Blocks.Count - 1);                    var prevHeaderTimes = newChain.Blocks.GetRange(newChain.Blocks.Count - 1 - medianTimeSpan' medianTimeSpan)                      //TODO pull tester doesn't fail if the sort step is missed                      .OrderBy(x => x.Time).ToList();                    var medianPrevHeaderTime = GetMedianPrevHeaderTime(newChain' chainedHeader.Height);                    if (blockTime <= medianPrevHeaderTime)                  {                      throw new ValidationException(chainedHeader.Hash'                          $"Failing block {chainedHeader.Hash} at height {chainedHeader.Height}: Block's time of {blockTime} must be greater than past median time of {medianPrevHeaderTime}");                  }              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The following statement contains a magic number: if (runningTally == null)              {                  var medianPrevHeaderTime = GetMedianPrevHeaderTime(newChain' chainedHeader.Height);                    var lockTimeFlags = 0; // TODO why is this used here?                  var lockTimeCutoff = ((lockTimeFlags & LOCKTIME_MEDIAN_TIME_PAST) != 0)                                        ? GetMedianPrevHeaderTime(newChain' chainedHeader.Height).ToUnixTimeSeconds()                                        : chainedHeader.Time.ToUnixTimeSeconds();                    runningTally = new BlockTally { BlockSize = 80' LockTimeCutoff = lockTimeCutoff };              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The following statement contains a magic number: if (validatableTx.Index == 0 && !tx.IsCoinbase)                  throw new ValidationException(chainedHeader.Hash);              // all other transactions must not be coinbase              else if (validatableTx.Index > 0 && tx.IsCoinbase)                  throw new ValidationException(chainedHeader.Hash);              // must have inputs              else if (tx.Inputs.Length == 0)                  throw new ValidationException(chainedHeader.Hash);              // must have outputs              else if (tx.Outputs.Length == 0)                  throw new ValidationException(chainedHeader.Hash);              // coinbase scriptSignature length must be >= 2 && <= 100              else if (tx.IsCoinbase && (tx.Inputs[0].ScriptSignature.Length < 2 || tx.Inputs[0].ScriptSignature.Length > 100))                  throw new ValidationException(chainedHeader.Hash);              // all transactions must be finalized              else if (!IsFinal(tx' chainedHeader.Height' blockTally.LockTimeCutoff))                  throw new ValidationException(chainedHeader.Hash);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The following statement contains a magic number: if (validatableTx.Index == 0 && !tx.IsCoinbase)                  throw new ValidationException(chainedHeader.Hash);              // all other transactions must not be coinbase              else if (validatableTx.Index > 0 && tx.IsCoinbase)                  throw new ValidationException(chainedHeader.Hash);              // must have inputs              else if (tx.Inputs.Length == 0)                  throw new ValidationException(chainedHeader.Hash);              // must have outputs              else if (tx.Outputs.Length == 0)                  throw new ValidationException(chainedHeader.Hash);              // coinbase scriptSignature length must be >= 2 && <= 100              else if (tx.IsCoinbase && (tx.Inputs[0].ScriptSignature.Length < 2 || tx.Inputs[0].ScriptSignature.Length > 100))                  throw new ValidationException(chainedHeader.Hash);              // all transactions must be finalized              else if (!IsFinal(tx' chainedHeader.Height' blockTally.LockTimeCutoff))                  throw new ValidationException(chainedHeader.Hash);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The following statement contains a magic number: if (tx.IsCoinbase                  && chainedHeader.Version >= 2                  && IsSuperMajority(2' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  var requiredScript = GetPushInt64Script(chainedHeader.Height);                  var actualScript = tx.Inputs[0].ScriptSignature;                    if (actualScript.Length < requiredScript.Length                      || !actualScript.Take(requiredScript.Length).SequenceEqual(requiredScript))                  {                      throw new ValidationException(chainedHeader.Hash);                  }              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,TallyTransaction,The following statement contains a magic number: if (tx.IsCoinbase                  && chainedHeader.Version >= 2                  && IsSuperMajority(2' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  var requiredScript = GetPushInt64Script(chainedHeader.Height);                  var actualScript = tx.Inputs[0].ScriptSignature;                    if (actualScript.Length < requiredScript.Length                      || !actualScript.Take(requiredScript.Length).SequenceEqual(requiredScript))                  {                      throw new ValidationException(chainedHeader.Hash);                  }              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,ValidationTransactionScript,The following statement contains a magic number: if (chainedHeader.Version >= 3                  && IsSuperMajority(3' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  flags |= verify_flags_type.verify_flags_dersig;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,ValidationTransactionScript,The following statement contains a magic number: if (chainedHeader.Version >= 3                  && IsSuperMajority(3' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  flags |= verify_flags_type.verify_flags_dersig;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,ValidationTransactionScript,The following statement contains a magic number: if (chainedHeader.Version >= 4                  && IsSuperMajority(4' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  flags |= verify_flags_type.verify_flags_checklocktimeverify;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,ValidationTransactionScript,The following statement contains a magic number: if (chainedHeader.Version >= 4                  && IsSuperMajority(4' newChain' ChainParams.MajorityEnforceBlockUpgrade))              {                  flags |= verify_flags_type.verify_flags_checklocktimeverify;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PostValidateBlock,The following statement contains a magic number: var subsidy = (ulong)(50 * SATOSHI_PER_BTC);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PostValidateBlock,The following statement contains a magic number: if (chainedHeader.Height / 210000 <= 32)                  subsidy /= (ulong)Math.Pow(2' chainedHeader.Height / 210000);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PostValidateBlock,The following statement contains a magic number: if (chainedHeader.Height / 210000 <= 32)                  subsidy /= (ulong)Math.Pow(2' chainedHeader.Height / 210000);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PostValidateBlock,The following statement contains a magic number: if (chainedHeader.Height / 210000 <= 32)                  subsidy /= (ulong)Math.Pow(2' chainedHeader.Height / 210000);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,PostValidateBlock,The following statement contains a magic number: if (chainedHeader.Height / 210000 <= 32)                  subsidy /= (ulong)Math.Pow(2' chainedHeader.Height / 210000);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetRequiredNextBits,The following statement contains a magic number: if (chain.Height % ChainParams.DifficultyInterval != 0)              {                  if (!ChainParams.AllowMininimumDifficultyBlocks)                      return prevHeader.Bits;                  else                  {                      // Special difficulty rule for testnet:                      // If the new block's timestamp is more than 2* 10 minutes                      // then allow mining of a min-difficulty block.                      var currentHeader = chain.LastBlock;                      if (currentHeader.Time > prevHeader.Time + TimeSpan.FromTicks(ChainParams.PowTargetSpacing.Ticks * 2))                          return powLimitCompact;                      else                      {                          // Return the last non-special-min-difficulty-rules-block                          var header = prevHeader;                          while (header.Height > 0                              && header.Height % ChainParams.DifficultyInterval != 0                              && header.Bits == powLimitCompact)                          {                              header = chain.Blocks[header.Height - 1];                          }                          return header.Bits;                      }                  }              }              // on an adjustment interval' calculate the required next target              else              {                  // get the block difficultyInterval blocks ago                  var prevIntervalHeight = prevHeader.Height - (ChainParams.DifficultyInterval - 1);                  var prevIntervalHeader = chain.Blocks[prevIntervalHeight];                    var actualTimespan = (uint)(prevHeader.Time - prevIntervalHeader.Time).TotalSeconds;                  var targetTimespan = (uint)(ChainParams.DifficultyTargetTimespan).TotalSeconds;                    // limit adjustment to 4x or 1/4x                  if (actualTimespan < targetTimespan / 4)                      actualTimespan = targetTimespan / 4;                  else if (actualTimespan > targetTimespan * 4)                      actualTimespan = targetTimespan * 4;                    // calculate the new target                  var target = prevHeader.BlockHeader.CalculateTarget();                  target *= actualTimespan;                  target /= targetTimespan;                    // make sure target isn't too high (too low difficulty)                  if (target > ChainParams.HighestTarget)                      target = ChainParams.HighestTarget;                    return DataCalculator.ToCompact(target);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetRequiredNextBits,The following statement contains a magic number: if (chain.Height % ChainParams.DifficultyInterval != 0)              {                  if (!ChainParams.AllowMininimumDifficultyBlocks)                      return prevHeader.Bits;                  else                  {                      // Special difficulty rule for testnet:                      // If the new block's timestamp is more than 2* 10 minutes                      // then allow mining of a min-difficulty block.                      var currentHeader = chain.LastBlock;                      if (currentHeader.Time > prevHeader.Time + TimeSpan.FromTicks(ChainParams.PowTargetSpacing.Ticks * 2))                          return powLimitCompact;                      else                      {                          // Return the last non-special-min-difficulty-rules-block                          var header = prevHeader;                          while (header.Height > 0                              && header.Height % ChainParams.DifficultyInterval != 0                              && header.Bits == powLimitCompact)                          {                              header = chain.Blocks[header.Height - 1];                          }                          return header.Bits;                      }                  }              }              // on an adjustment interval' calculate the required next target              else              {                  // get the block difficultyInterval blocks ago                  var prevIntervalHeight = prevHeader.Height - (ChainParams.DifficultyInterval - 1);                  var prevIntervalHeader = chain.Blocks[prevIntervalHeight];                    var actualTimespan = (uint)(prevHeader.Time - prevIntervalHeader.Time).TotalSeconds;                  var targetTimespan = (uint)(ChainParams.DifficultyTargetTimespan).TotalSeconds;                    // limit adjustment to 4x or 1/4x                  if (actualTimespan < targetTimespan / 4)                      actualTimespan = targetTimespan / 4;                  else if (actualTimespan > targetTimespan * 4)                      actualTimespan = targetTimespan * 4;                    // calculate the new target                  var target = prevHeader.BlockHeader.CalculateTarget();                  target *= actualTimespan;                  target /= targetTimespan;                    // make sure target isn't too high (too low difficulty)                  if (target > ChainParams.HighestTarget)                      target = ChainParams.HighestTarget;                    return DataCalculator.ToCompact(target);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetRequiredNextBits,The following statement contains a magic number: if (chain.Height % ChainParams.DifficultyInterval != 0)              {                  if (!ChainParams.AllowMininimumDifficultyBlocks)                      return prevHeader.Bits;                  else                  {                      // Special difficulty rule for testnet:                      // If the new block's timestamp is more than 2* 10 minutes                      // then allow mining of a min-difficulty block.                      var currentHeader = chain.LastBlock;                      if (currentHeader.Time > prevHeader.Time + TimeSpan.FromTicks(ChainParams.PowTargetSpacing.Ticks * 2))                          return powLimitCompact;                      else                      {                          // Return the last non-special-min-difficulty-rules-block                          var header = prevHeader;                          while (header.Height > 0                              && header.Height % ChainParams.DifficultyInterval != 0                              && header.Bits == powLimitCompact)                          {                              header = chain.Blocks[header.Height - 1];                          }                          return header.Bits;                      }                  }              }              // on an adjustment interval' calculate the required next target              else              {                  // get the block difficultyInterval blocks ago                  var prevIntervalHeight = prevHeader.Height - (ChainParams.DifficultyInterval - 1);                  var prevIntervalHeader = chain.Blocks[prevIntervalHeight];                    var actualTimespan = (uint)(prevHeader.Time - prevIntervalHeader.Time).TotalSeconds;                  var targetTimespan = (uint)(ChainParams.DifficultyTargetTimespan).TotalSeconds;                    // limit adjustment to 4x or 1/4x                  if (actualTimespan < targetTimespan / 4)                      actualTimespan = targetTimespan / 4;                  else if (actualTimespan > targetTimespan * 4)                      actualTimespan = targetTimespan * 4;                    // calculate the new target                  var target = prevHeader.BlockHeader.CalculateTarget();                  target *= actualTimespan;                  target /= targetTimespan;                    // make sure target isn't too high (too low difficulty)                  if (target > ChainParams.HighestTarget)                      target = ChainParams.HighestTarget;                    return DataCalculator.ToCompact(target);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetRequiredNextBits,The following statement contains a magic number: if (chain.Height % ChainParams.DifficultyInterval != 0)              {                  if (!ChainParams.AllowMininimumDifficultyBlocks)                      return prevHeader.Bits;                  else                  {                      // Special difficulty rule for testnet:                      // If the new block's timestamp is more than 2* 10 minutes                      // then allow mining of a min-difficulty block.                      var currentHeader = chain.LastBlock;                      if (currentHeader.Time > prevHeader.Time + TimeSpan.FromTicks(ChainParams.PowTargetSpacing.Ticks * 2))                          return powLimitCompact;                      else                      {                          // Return the last non-special-min-difficulty-rules-block                          var header = prevHeader;                          while (header.Height > 0                              && header.Height % ChainParams.DifficultyInterval != 0                              && header.Bits == powLimitCompact)                          {                              header = chain.Blocks[header.Height - 1];                          }                          return header.Bits;                      }                  }              }              // on an adjustment interval' calculate the required next target              else              {                  // get the block difficultyInterval blocks ago                  var prevIntervalHeight = prevHeader.Height - (ChainParams.DifficultyInterval - 1);                  var prevIntervalHeader = chain.Blocks[prevIntervalHeight];                    var actualTimespan = (uint)(prevHeader.Time - prevIntervalHeader.Time).TotalSeconds;                  var targetTimespan = (uint)(ChainParams.DifficultyTargetTimespan).TotalSeconds;                    // limit adjustment to 4x or 1/4x                  if (actualTimespan < targetTimespan / 4)                      actualTimespan = targetTimespan / 4;                  else if (actualTimespan > targetTimespan * 4)                      actualTimespan = targetTimespan * 4;                    // calculate the new target                  var target = prevHeader.BlockHeader.CalculateTarget();                  target *= actualTimespan;                  target /= targetTimespan;                    // make sure target isn't too high (too low difficulty)                  if (target > ChainParams.HighestTarget)                      target = ChainParams.HighestTarget;                    return DataCalculator.ToCompact(target);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetRequiredNextBits,The following statement contains a magic number: if (chain.Height % ChainParams.DifficultyInterval != 0)              {                  if (!ChainParams.AllowMininimumDifficultyBlocks)                      return prevHeader.Bits;                  else                  {                      // Special difficulty rule for testnet:                      // If the new block's timestamp is more than 2* 10 minutes                      // then allow mining of a min-difficulty block.                      var currentHeader = chain.LastBlock;                      if (currentHeader.Time > prevHeader.Time + TimeSpan.FromTicks(ChainParams.PowTargetSpacing.Ticks * 2))                          return powLimitCompact;                      else                      {                          // Return the last non-special-min-difficulty-rules-block                          var header = prevHeader;                          while (header.Height > 0                              && header.Height % ChainParams.DifficultyInterval != 0                              && header.Bits == powLimitCompact)                          {                              header = chain.Blocks[header.Height - 1];                          }                          return header.Bits;                      }                  }              }              // on an adjustment interval' calculate the required next target              else              {                  // get the block difficultyInterval blocks ago                  var prevIntervalHeight = prevHeader.Height - (ChainParams.DifficultyInterval - 1);                  var prevIntervalHeader = chain.Blocks[prevIntervalHeight];                    var actualTimespan = (uint)(prevHeader.Time - prevIntervalHeader.Time).TotalSeconds;                  var targetTimespan = (uint)(ChainParams.DifficultyTargetTimespan).TotalSeconds;                    // limit adjustment to 4x or 1/4x                  if (actualTimespan < targetTimespan / 4)                      actualTimespan = targetTimespan / 4;                  else if (actualTimespan > targetTimespan * 4)                      actualTimespan = targetTimespan * 4;                    // calculate the new target                  var target = prevHeader.BlockHeader.CalculateTarget();                  target *= actualTimespan;                  target /= targetTimespan;                    // make sure target isn't too high (too low difficulty)                  if (target > ChainParams.HighestTarget)                      target = ChainParams.HighestTarget;                    return DataCalculator.ToCompact(target);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,CountLegacySigOps,The following statement contains a magic number: while (index < script.Length)              {                  ScriptOp op;                  if (!GetOp(script' ref index' out op))                      break;                    switch (op)                  {                      case ScriptOp.OP_CHECKSIG:                      case ScriptOp.OP_CHECKSIGVERIFY:                          sigOpCount++;                          break;                        case ScriptOp.OP_CHECKMULTISIG:                      case ScriptOp.OP_CHECKMULTISIGVERIFY:                          //TODO                          var prevOpCode = index >= 2 ? script[index - 2] : (byte)ScriptOp.OP_INVALIDOPCODE;                          if (accurate && prevOpCode >= (byte)ScriptOp.OP_1 && prevOpCode <= (byte)ScriptOp.OP_16)                              sigOpCount += prevOpCode - ((byte)ScriptOp.OP_1 - 1);                          else                              sigOpCount += MAX_PUBKEYS_PER_MULTISIG;                            break;                  }              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,CountLegacySigOps,The following statement contains a magic number: while (index < script.Length)              {                  ScriptOp op;                  if (!GetOp(script' ref index' out op))                      break;                    switch (op)                  {                      case ScriptOp.OP_CHECKSIG:                      case ScriptOp.OP_CHECKSIGVERIFY:                          sigOpCount++;                          break;                        case ScriptOp.OP_CHECKMULTISIG:                      case ScriptOp.OP_CHECKMULTISIGVERIFY:                          //TODO                          var prevOpCode = index >= 2 ? script[index - 2] : (byte)ScriptOp.OP_INVALIDOPCODE;                          if (accurate && prevOpCode >= (byte)ScriptOp.OP_1 && prevOpCode <= (byte)ScriptOp.OP_16)                              sigOpCount += prevOpCode - ((byte)ScriptOp.OP_1 - 1);                          else                              sigOpCount += MAX_PUBKEYS_PER_MULTISIG;                            break;                  }              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetOp,The following statement contains a magic number: if (currentOp <= ScriptOp.OP_PUSHDATA4)              {                  //OP_PUSHBYTES1-75                  uint dataLength;                  if (currentOp < ScriptOp.OP_PUSHDATA1)                  {                      dataLength = opByte;                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA1)                  {                      if (index + 1 > script.Length)                          return false;                        dataLength = script[index++];                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA2)                  {                      if (index + 2 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8);                  }                  else if (currentOp == ScriptOp.OP_PUSHDATA4)                  {                      if (index + 4 > script.Length)                          return false;                        dataLength = (uint)script[index++] + ((uint)script[index++] << 8) + ((uint)script[index++] << 16) + ((uint)script[index++] << 24);                  }                  else                  {                      dataLength = 0;                      Debug.Assert(false);                  }                    if ((ulong)index + dataLength > (uint)script.Length)                      return false;                    if (readData)                      data = ImmutableArray.Create(script' index' (int)dataLength);                    index += (int)dataLength;              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetMedianPrevHeaderTime,The following statement contains a magic number: var medianTimeSpan = Math.Min(11' height);
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetMedianPrevHeaderTime,The following statement contains a magic number: return prevHeaderTimes[prevHeaderTimes.Count / 2].Time;
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,GetPushInt64Script,The following statement contains a magic number: if (value == 0)              {                  script.WriteOp(ScriptOp.OP_0);              }              // push -1 onto the stack using OP_1NEGATE              else if (value == -1)              {                  script.WriteOp(ScriptOp.OP_1NEGATE);              }              // push 1-16 onto the stack using OP_1 to OP_16              else if (value >= 1 && value <= 16)              {                  script.WriteOp((ScriptOp)(value + ((long)ScriptOp.OP_1 - 1)));              }              else              {                  var valueBytes = SerializeScriptValue(value);                  script.WritePushData(valueBytes);              }
Magic Number,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,SerializeScriptValue,The following statement contains a magic number: while (absvalue != 0)              {                  result.Add((byte)(absvalue & 0xff));                  absvalue >>= 8;              }
Magic Number,BitSharp.Core.Storage.Memory,MemoryMerkleTreePruningCursor<T>,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryMerkleTreePruningCursor.cs,MemoryMerkleTreePruningCursor,The following statement contains a magic number: this.index = -2;
Magic Number,BitSharp.Core.Storage.Memory,MemoryMerkleTreePruningCursor<T>,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryMerkleTreePruningCursor.cs,TryMoveToIndex,The following statement contains a magic number: if (this.index >= 0 && this.index < this.nodes.Count)              {                  return true;              }              else              {                  this.index = -2;                  return false;              }
Magic Number,BitSharp.Core.Storage.Memory,MemoryStorageManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryStorageManager.cs,MemoryStorageManager,The following statement contains a magic number: chainStateCursorCache = new DisposableCache<IChainStateCursor>(1024'                  createFunc: () => new MemoryChainStateCursor(chainStateStorage)'                  prepareAction: cursor =>                  {                      // rollback any open transaction before returning the cursor to the cache                      if (cursor.InTransaction)                          cursor.RollbackTransaction();                  });
Magic Number,BitSharp.Core.Storage.Memory,MemoryStorageManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Storage\Memory\MemoryStorageManager.cs,MemoryStorageManager,The following statement contains a magic number: unconfirmedTxesCursorCache = new DisposableCache<IUnconfirmedTxesCursor>(1024'                  createFunc: () => new MemoryUnconfirmedTxesCursor(unconfirmedTxesStorage)'                  prepareAction: cursor =>                  {                      // rollback any open transaction before returning the cursor to the cache                      if (cursor.InTransaction)                          cursor.RollbackTransaction();                  });
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadUInt16BE,The following statement contains a magic number: using (var reverse = reader.ReverseRead(2))                  return reverse.ReadUInt16();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadUInt256,The following statement contains a magic number: return new UInt256(reader.ReadExactly(32));
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 2);                  reader.ReadExactly(bytes' offset' 2);                  value = Bits.ToUInt16(bytes' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 4);                  reader.ReadExactly(bytes' offset' 4);                  value = Bits.ToUInt32(bytes' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  DataDecoder.SizeAtLeast(ref bytes' offset + 8);                  reader.ReadExactly(bytes' offset' 8);                  value = Bits.ToUInt64(bytes' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  value = Bits.ToUInt16(buffer' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  value = Bits.ToUInt32(buffer' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  value = Bits.ToUInt64(buffer' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  value = Bits.ToUInt16(buffer' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  value = Bits.ToUInt32(buffer' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  value = Bits.ToUInt64(buffer' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,ReadVarInt,The following statement contains a magic number: if (value < 0xFD)              {                  return value;              }              else if (value == 0xFD)              {                  value = Bits.ToUInt16(buffer' offset);                  offset += 2;                  return value;              }              else if (value == 0xFE)              {                  value = Bits.ToUInt32(buffer' offset);                  offset += 4;                  return value;              }              else if (value == 0xFF)              {                  value = Bits.ToUInt64(buffer' offset);                  offset += 8;                  return value;              }              else                  throw new Exception();
Magic Number,BitSharp.Core.ExtensionMethods,DataEncoderExtensionMethods,C:\repos\pmlyon_BitSharp\BitSharp.Core\DataEncoderExtensionMethods.cs,WriteUInt16BE,The following statement contains a magic number: writer.ReverseWrite(2' reverseWriter => reverseWriter.WriteUInt16(value));
Magic Number,BitSharp.Core.Script,ScriptBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptBuilder.cs,WritePushData,The following statement contains a magic number: checked              {                  if (data.Length <= (int)ScriptOp.OP_PUSHBYTES75)                  {                      stream.WriteByte((byte)data.Length);                      stream.Write(data' 0' data.Length);                  }                  else if (data.Length < 0x100)                  {                      WriteOp(ScriptOp.OP_PUSHDATA1);                      stream.WriteByte((byte)data.Length);                      stream.Write(data' 0' data.Length);                  }                  else if (data.Length < 0x10000)                  {                      WriteOp(ScriptOp.OP_PUSHDATA2);                      stream.Write(Bits.GetBytes((UInt16)data.Length)' 0' 2);                      stream.Write(data' 0' data.Length);                  }                  else if (data.LongLength < 0x100000000L)                  {                      WriteOp(ScriptOp.OP_PUSHDATA4);                      stream.Write(Bits.GetBytes((UInt32)data.Length)' 0' 4);                      stream.Write(data' 0' data.Length);                  }                  else                  {                      throw new ArgumentOutOfRangeException("data");                  }              }
Magic Number,BitSharp.Core.Script,ScriptBuilder,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptBuilder.cs,WritePushData,The following statement contains a magic number: checked              {                  if (data.Length <= (int)ScriptOp.OP_PUSHBYTES75)                  {                      stream.WriteByte((byte)data.Length);                      stream.Write(data' 0' data.Length);                  }                  else if (data.Length < 0x100)                  {                      WriteOp(ScriptOp.OP_PUSHDATA1);                      stream.WriteByte((byte)data.Length);                      stream.Write(data' 0' data.Length);                  }                  else if (data.Length < 0x10000)                  {                      WriteOp(ScriptOp.OP_PUSHDATA2);                      stream.Write(Bits.GetBytes((UInt16)data.Length)' 0' 2);                      stream.Write(data' 0' data.Length);                  }                  else if (data.LongLength < 0x100000000L)                  {                      WriteOp(ScriptOp.OP_PUSHDATA4);                      stream.Write(Bits.GetBytes((UInt32)data.Length)' 0' 4);                      stream.Write(data' 0' data.Length);                  }                  else                  {                      throw new ArgumentOutOfRangeException("data");                  }              }
Magic Number,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The following statement contains a magic number: using (var scriptStream = new MemoryStream(script))              using (var opReader = new BinaryReader(scriptStream))              {                  while (opReader.BaseStream.Position < script.Length)                  {                      var opByte = opReader.ReadByte();                      var op = (ScriptOp)Enum.ToObject(typeof(ScriptOp)' opByte);                        if (logger.IsTraceEnabled)                          logger.Trace("Executing {0} with stack count: {1}"' OpName(opByte)' stack.Count);                        switch (op)                      {                          // Constants                          case ScriptOp.OP_PUSHDATA1:                              {                                  if (opReader.BaseStream.Position + 1 >= script.Length)                                      return false;                                    var length = opReader.ReadByte();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA2:                              {                                  if (opReader.BaseStream.Position + 2 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt16();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA4:                              {                                  if (opReader.BaseStream.Position + 4 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt32();                                  stack.PushBytes(opReader.ReadExactly(length.ToIntChecked()));                              }                              break;                            // Flow control                          case ScriptOp.OP_NOP:                              {                              }                              break;                            // Stack                          case ScriptOp.OP_DROP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes();                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} dropped {1}"' OpName(opByte)' value);                              }                              break;                            case ScriptOp.OP_DUP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PeekBytes();                                  stack.PushBytes(value);                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} duplicated {2}"' OpName(opByte)' value);                              }                              break;                            // Splice                            // Bitwise logic                          case ScriptOp.OP_EQUAL:                          case ScriptOp.OP_EQUALVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var value1 = stack.PopBytes();                                  var value2 = stack.PopBytes();                                    var result = value1.SequenceEqual(value2);                                  stack.PushBool(result);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} compared values:      value1: {1}      value2: {2}      result: {3}"' OpName(opByte)' value1' value2' result);                                    if (op == ScriptOp.OP_EQUALVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Arithmetic                          // Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.                            // Crypto                          case ScriptOp.OP_SHA256:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = SHA256Static.ComputeHash(value);                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_HASH160:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = RIPEMD160Static.ComputeHash(SHA256Static.ComputeHash(value));                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_CHECKSIG:                          case ScriptOp.OP_CHECKSIGVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var pubKey = stack.PopBytes().ToArray();                                  var sig = stack.PopBytes().ToArray();                                    var startTime = DateTime.UtcNow;                                    byte hashType; byte[] txSignature' txSignatureHash;                                  var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash);                                  stack.PushBool(result);                                    var finishTime = DateTime.UtcNow;                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} executed in {9} ms:      tx:                 {1}      inputIndex:         {2}      pubKey:             {3}      sig:                {4}      hashType:           {5}      txSignature:        {6}      txSignatureHash:    {7}      result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0"));                                    if (op == ScriptOp.OP_CHECKSIGVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Pseudo-words                          // These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.                            // Reserved words                          // Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.                            default:                              //OP_PUSHBYTES1-75                              if (opByte >= (int)ScriptOp.OP_PUSHBYTES1 && opByte <= (int)ScriptOp.OP_PUSHBYTES75)                              {                                  stack.PushBytes(opReader.ReadExactly(opByte));                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} loaded {1} bytes onto the stack: {2}"' OpName(opByte)' opByte' stack.PeekBytes());                              }                              // Unknown op                              else                              {                                  var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}";                                  //logger.Warn(message);                                  throw new Exception(message);                              }                              break;                      }                        if (logger.IsTraceEnabled)                          logger.Trace(new string('-'' 80));                  }              }
Magic Number,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The following statement contains a magic number: using (var scriptStream = new MemoryStream(script))              using (var opReader = new BinaryReader(scriptStream))              {                  while (opReader.BaseStream.Position < script.Length)                  {                      var opByte = opReader.ReadByte();                      var op = (ScriptOp)Enum.ToObject(typeof(ScriptOp)' opByte);                        if (logger.IsTraceEnabled)                          logger.Trace("Executing {0} with stack count: {1}"' OpName(opByte)' stack.Count);                        switch (op)                      {                          // Constants                          case ScriptOp.OP_PUSHDATA1:                              {                                  if (opReader.BaseStream.Position + 1 >= script.Length)                                      return false;                                    var length = opReader.ReadByte();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA2:                              {                                  if (opReader.BaseStream.Position + 2 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt16();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA4:                              {                                  if (opReader.BaseStream.Position + 4 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt32();                                  stack.PushBytes(opReader.ReadExactly(length.ToIntChecked()));                              }                              break;                            // Flow control                          case ScriptOp.OP_NOP:                              {                              }                              break;                            // Stack                          case ScriptOp.OP_DROP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes();                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} dropped {1}"' OpName(opByte)' value);                              }                              break;                            case ScriptOp.OP_DUP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PeekBytes();                                  stack.PushBytes(value);                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} duplicated {2}"' OpName(opByte)' value);                              }                              break;                            // Splice                            // Bitwise logic                          case ScriptOp.OP_EQUAL:                          case ScriptOp.OP_EQUALVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var value1 = stack.PopBytes();                                  var value2 = stack.PopBytes();                                    var result = value1.SequenceEqual(value2);                                  stack.PushBool(result);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} compared values:      value1: {1}      value2: {2}      result: {3}"' OpName(opByte)' value1' value2' result);                                    if (op == ScriptOp.OP_EQUALVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Arithmetic                          // Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.                            // Crypto                          case ScriptOp.OP_SHA256:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = SHA256Static.ComputeHash(value);                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_HASH160:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = RIPEMD160Static.ComputeHash(SHA256Static.ComputeHash(value));                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_CHECKSIG:                          case ScriptOp.OP_CHECKSIGVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var pubKey = stack.PopBytes().ToArray();                                  var sig = stack.PopBytes().ToArray();                                    var startTime = DateTime.UtcNow;                                    byte hashType; byte[] txSignature' txSignatureHash;                                  var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash);                                  stack.PushBool(result);                                    var finishTime = DateTime.UtcNow;                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} executed in {9} ms:      tx:                 {1}      inputIndex:         {2}      pubKey:             {3}      sig:                {4}      hashType:           {5}      txSignature:        {6}      txSignatureHash:    {7}      result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0"));                                    if (op == ScriptOp.OP_CHECKSIGVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Pseudo-words                          // These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.                            // Reserved words                          // Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.                            default:                              //OP_PUSHBYTES1-75                              if (opByte >= (int)ScriptOp.OP_PUSHBYTES1 && opByte <= (int)ScriptOp.OP_PUSHBYTES75)                              {                                  stack.PushBytes(opReader.ReadExactly(opByte));                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} loaded {1} bytes onto the stack: {2}"' OpName(opByte)' opByte' stack.PeekBytes());                              }                              // Unknown op                              else                              {                                  var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}";                                  //logger.Warn(message);                                  throw new Exception(message);                              }                              break;                      }                        if (logger.IsTraceEnabled)                          logger.Trace(new string('-'' 80));                  }              }
Magic Number,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The following statement contains a magic number: using (var scriptStream = new MemoryStream(script))              using (var opReader = new BinaryReader(scriptStream))              {                  while (opReader.BaseStream.Position < script.Length)                  {                      var opByte = opReader.ReadByte();                      var op = (ScriptOp)Enum.ToObject(typeof(ScriptOp)' opByte);                        if (logger.IsTraceEnabled)                          logger.Trace("Executing {0} with stack count: {1}"' OpName(opByte)' stack.Count);                        switch (op)                      {                          // Constants                          case ScriptOp.OP_PUSHDATA1:                              {                                  if (opReader.BaseStream.Position + 1 >= script.Length)                                      return false;                                    var length = opReader.ReadByte();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA2:                              {                                  if (opReader.BaseStream.Position + 2 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt16();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA4:                              {                                  if (opReader.BaseStream.Position + 4 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt32();                                  stack.PushBytes(opReader.ReadExactly(length.ToIntChecked()));                              }                              break;                            // Flow control                          case ScriptOp.OP_NOP:                              {                              }                              break;                            // Stack                          case ScriptOp.OP_DROP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes();                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} dropped {1}"' OpName(opByte)' value);                              }                              break;                            case ScriptOp.OP_DUP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PeekBytes();                                  stack.PushBytes(value);                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} duplicated {2}"' OpName(opByte)' value);                              }                              break;                            // Splice                            // Bitwise logic                          case ScriptOp.OP_EQUAL:                          case ScriptOp.OP_EQUALVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var value1 = stack.PopBytes();                                  var value2 = stack.PopBytes();                                    var result = value1.SequenceEqual(value2);                                  stack.PushBool(result);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} compared values:      value1: {1}      value2: {2}      result: {3}"' OpName(opByte)' value1' value2' result);                                    if (op == ScriptOp.OP_EQUALVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Arithmetic                          // Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.                            // Crypto                          case ScriptOp.OP_SHA256:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = SHA256Static.ComputeHash(value);                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_HASH160:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = RIPEMD160Static.ComputeHash(SHA256Static.ComputeHash(value));                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_CHECKSIG:                          case ScriptOp.OP_CHECKSIGVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var pubKey = stack.PopBytes().ToArray();                                  var sig = stack.PopBytes().ToArray();                                    var startTime = DateTime.UtcNow;                                    byte hashType; byte[] txSignature' txSignatureHash;                                  var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash);                                  stack.PushBool(result);                                    var finishTime = DateTime.UtcNow;                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} executed in {9} ms:      tx:                 {1}      inputIndex:         {2}      pubKey:             {3}      sig:                {4}      hashType:           {5}      txSignature:        {6}      txSignatureHash:    {7}      result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0"));                                    if (op == ScriptOp.OP_CHECKSIGVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Pseudo-words                          // These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.                            // Reserved words                          // Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.                            default:                              //OP_PUSHBYTES1-75                              if (opByte >= (int)ScriptOp.OP_PUSHBYTES1 && opByte <= (int)ScriptOp.OP_PUSHBYTES75)                              {                                  stack.PushBytes(opReader.ReadExactly(opByte));                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} loaded {1} bytes onto the stack: {2}"' OpName(opByte)' opByte' stack.PeekBytes());                              }                              // Unknown op                              else                              {                                  var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}";                                  //logger.Warn(message);                                  throw new Exception(message);                              }                              break;                      }                        if (logger.IsTraceEnabled)                          logger.Trace(new string('-'' 80));                  }              }
Magic Number,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The following statement contains a magic number: using (var scriptStream = new MemoryStream(script))              using (var opReader = new BinaryReader(scriptStream))              {                  while (opReader.BaseStream.Position < script.Length)                  {                      var opByte = opReader.ReadByte();                      var op = (ScriptOp)Enum.ToObject(typeof(ScriptOp)' opByte);                        if (logger.IsTraceEnabled)                          logger.Trace("Executing {0} with stack count: {1}"' OpName(opByte)' stack.Count);                        switch (op)                      {                          // Constants                          case ScriptOp.OP_PUSHDATA1:                              {                                  if (opReader.BaseStream.Position + 1 >= script.Length)                                      return false;                                    var length = opReader.ReadByte();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA2:                              {                                  if (opReader.BaseStream.Position + 2 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt16();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA4:                              {                                  if (opReader.BaseStream.Position + 4 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt32();                                  stack.PushBytes(opReader.ReadExactly(length.ToIntChecked()));                              }                              break;                            // Flow control                          case ScriptOp.OP_NOP:                              {                              }                              break;                            // Stack                          case ScriptOp.OP_DROP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes();                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} dropped {1}"' OpName(opByte)' value);                              }                              break;                            case ScriptOp.OP_DUP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PeekBytes();                                  stack.PushBytes(value);                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} duplicated {2}"' OpName(opByte)' value);                              }                              break;                            // Splice                            // Bitwise logic                          case ScriptOp.OP_EQUAL:                          case ScriptOp.OP_EQUALVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var value1 = stack.PopBytes();                                  var value2 = stack.PopBytes();                                    var result = value1.SequenceEqual(value2);                                  stack.PushBool(result);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} compared values:      value1: {1}      value2: {2}      result: {3}"' OpName(opByte)' value1' value2' result);                                    if (op == ScriptOp.OP_EQUALVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Arithmetic                          // Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.                            // Crypto                          case ScriptOp.OP_SHA256:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = SHA256Static.ComputeHash(value);                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_HASH160:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = RIPEMD160Static.ComputeHash(SHA256Static.ComputeHash(value));                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_CHECKSIG:                          case ScriptOp.OP_CHECKSIGVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var pubKey = stack.PopBytes().ToArray();                                  var sig = stack.PopBytes().ToArray();                                    var startTime = DateTime.UtcNow;                                    byte hashType; byte[] txSignature' txSignatureHash;                                  var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash);                                  stack.PushBool(result);                                    var finishTime = DateTime.UtcNow;                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} executed in {9} ms:      tx:                 {1}      inputIndex:         {2}      pubKey:             {3}      sig:                {4}      hashType:           {5}      txSignature:        {6}      txSignatureHash:    {7}      result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0"));                                    if (op == ScriptOp.OP_CHECKSIGVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Pseudo-words                          // These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.                            // Reserved words                          // Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.                            default:                              //OP_PUSHBYTES1-75                              if (opByte >= (int)ScriptOp.OP_PUSHBYTES1 && opByte <= (int)ScriptOp.OP_PUSHBYTES75)                              {                                  stack.PushBytes(opReader.ReadExactly(opByte));                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} loaded {1} bytes onto the stack: {2}"' OpName(opByte)' opByte' stack.PeekBytes());                              }                              // Unknown op                              else                              {                                  var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}";                                  //logger.Warn(message);                                  throw new Exception(message);                              }                              break;                      }                        if (logger.IsTraceEnabled)                          logger.Trace(new string('-'' 80));                  }              }
Magic Number,BitSharp.Core.Script,ScriptEngine,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\ScriptEngine.cs,ExecuteOps,The following statement contains a magic number: using (var scriptStream = new MemoryStream(script))              using (var opReader = new BinaryReader(scriptStream))              {                  while (opReader.BaseStream.Position < script.Length)                  {                      var opByte = opReader.ReadByte();                      var op = (ScriptOp)Enum.ToObject(typeof(ScriptOp)' opByte);                        if (logger.IsTraceEnabled)                          logger.Trace("Executing {0} with stack count: {1}"' OpName(opByte)' stack.Count);                        switch (op)                      {                          // Constants                          case ScriptOp.OP_PUSHDATA1:                              {                                  if (opReader.BaseStream.Position + 1 >= script.Length)                                      return false;                                    var length = opReader.ReadByte();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA2:                              {                                  if (opReader.BaseStream.Position + 2 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt16();                                  stack.PushBytes(opReader.ReadExactly(length));                              }                              break;                            case ScriptOp.OP_PUSHDATA4:                              {                                  if (opReader.BaseStream.Position + 4 >= script.Length)                                      return false;                                    var length = opReader.ReadUInt32();                                  stack.PushBytes(opReader.ReadExactly(length.ToIntChecked()));                              }                              break;                            // Flow control                          case ScriptOp.OP_NOP:                              {                              }                              break;                            // Stack                          case ScriptOp.OP_DROP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes();                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} dropped {1}"' OpName(opByte)' value);                              }                              break;                            case ScriptOp.OP_DUP:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PeekBytes();                                  stack.PushBytes(value);                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} duplicated {2}"' OpName(opByte)' value);                              }                              break;                            // Splice                            // Bitwise logic                          case ScriptOp.OP_EQUAL:                          case ScriptOp.OP_EQUALVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var value1 = stack.PopBytes();                                  var value2 = stack.PopBytes();                                    var result = value1.SequenceEqual(value2);                                  stack.PushBool(result);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} compared values:      value1: {1}      value2: {2}      result: {3}"' OpName(opByte)' value1' value2' result);                                    if (op == ScriptOp.OP_EQUALVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Arithmetic                          // Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.                            // Crypto                          case ScriptOp.OP_SHA256:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = SHA256Static.ComputeHash(value);                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_HASH160:                              {                                  if (stack.Count < 1)                                      return false;                                    var value = stack.PopBytes().ToArray();                                    var hash = RIPEMD160Static.ComputeHash(SHA256Static.ComputeHash(value));                                  stack.PushBytes(hash);                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} hashed value:      value:  {1}      hash:   {2}"' OpName(opByte)' value' hash);                              }                              break;                            case ScriptOp.OP_CHECKSIG:                          case ScriptOp.OP_CHECKSIGVERIFY:                              {                                  if (stack.Count < 2)                                      return false;                                    var pubKey = stack.PopBytes().ToArray();                                  var sig = stack.PopBytes().ToArray();                                    var startTime = DateTime.UtcNow;                                    byte hashType; byte[] txSignature' txSignatureHash;                                  var result = VerifySignature(scriptPubKey' tx' sig' pubKey' inputIndex' out hashType' out txSignature' out txSignatureHash);                                  stack.PushBool(result);                                    var finishTime = DateTime.UtcNow;                                    if (logger.IsTraceEnabled)                                      logger.Trace(  @"{0} executed in {9} ms:      tx:                 {1}      inputIndex:         {2}      pubKey:             {3}      sig:                {4}      hashType:           {5}      txSignature:        {6}      txSignatureHash:    {7}      result:             {8}"' OpName(opByte)' new byte[0] /*tx.ToRawBytes()*/' inputIndex' pubKey' sig' hashType' txSignature' txSignatureHash' result' (finishTime - startTime).TotalMilliseconds.ToString("0"));                                    if (op == ScriptOp.OP_CHECKSIGVERIFY)                                  {                                      if (result)                                          stack.PopBool();                                      else                                          return false;                                  }                              }                              break;                            // Pseudo-words                          // These words are used internally for assisting with transaction matching. They are invalid if used in actual scripts.                            // Reserved words                          // Any opcode not assigned is also reserved. Using an unassigned opcode makes the transaction invalid.                            default:                              //OP_PUSHBYTES1-75                              if (opByte >= (int)ScriptOp.OP_PUSHBYTES1 && opByte <= (int)ScriptOp.OP_PUSHBYTES75)                              {                                  stack.PushBytes(opReader.ReadExactly(opByte));                                    if (logger.IsTraceEnabled)                                      logger.Trace("{0} loaded {1} bytes onto the stack: {2}"' OpName(opByte)' opByte' stack.PeekBytes());                              }                              // Unknown op                              else                              {                                  var message = $"Invalid operation in tx {tx.Hash} input {inputIndex}: {new[] { opByte }.ToHexNumberString()} {OpName(opByte)}";                                  //logger.Warn(message);                                  throw new Exception(message);                              }                              break;                      }                        if (logger.IsTraceEnabled)                          logger.Trace(new string('-'' 80));                  }              }
Magic Number,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateCoinbaseTransaction,The following statement contains a magic number: var tx = Transaction.Create              (                  version: 1'                  inputs: ImmutableArray.Create                  (                      new TxInput                      (                          prevTxHash: UInt256.Zero'                          prevTxOutputIndex: 0'                          scriptSignature: coinbase.ToImmutableArray()'                          sequence: 0                      )                  )'                  outputs: ImmutableArray.Create                  (                      new TxOutput                      (                          value: 50L * (100 * 1000 * 1000)'                          scriptPublicKey: CreatePublicKeyScript(publicKey).ToImmutableArray()                      )                  )'                  lockTime: 0              );
Magic Number,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateCoinbaseTransaction,The following statement contains a magic number: var tx = Transaction.Create              (                  version: 1'                  inputs: ImmutableArray.Create                  (                      new TxInput                      (                          prevTxHash: UInt256.Zero'                          prevTxOutputIndex: 0'                          scriptSignature: coinbase.ToImmutableArray()'                          sequence: 0                      )                  )'                  outputs: ImmutableArray.Create                  (                      new TxOutput                      (                          value: 50L * (100 * 1000 * 1000)'                          scriptPublicKey: CreatePublicKeyScript(publicKey).ToImmutableArray()                      )                  )'                  lockTime: 0              );
Magic Number,BitSharp.Core.Script,TransactionManager,C:\repos\pmlyon_BitSharp\BitSharp.Core\Script\TransactionManager.cs,CreateCoinbaseTransaction,The following statement contains a magic number: var tx = Transaction.Create              (                  version: 1'                  inputs: ImmutableArray.Create                  (                      new TxInput                      (                          prevTxHash: UInt256.Zero'                          prevTxOutputIndex: 0'                          scriptSignature: coinbase.ToImmutableArray()'                          sequence: 0                      )                  )'                  outputs: ImmutableArray.Create                  (                      new TxOutput                      (                          value: 50L * (100 * 1000 * 1000)'                          scriptPublicKey: CreatePublicKeyScript(publicKey).ToImmutableArray()                      )                  )'                  lockTime: 0              );
Magic Number,BitSharp.Core.Workers,ChainStateWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\ChainStateWorker.cs,ChainStateWorker,The following statement contains a magic number: this.blockProcessingDurationMeasure = new DurationMeasure(sampleCutoff: TimeSpan.FromMinutes(5));
Magic Number,BitSharp.Core.Workers,ChainStateWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\ChainStateWorker.cs,ChainStateWorker,The following statement contains a magic number: this.blockMissCountMeasure = new CountMeasure(TimeSpan.FromSeconds(30));
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Magic Number,BitSharp.Core.Workers,PruningWorker,C:\repos\pmlyon_BitSharp\BitSharp.Core\Workers\PruningWorker.cs,WorkAction,The following statement contains a magic number: foreach (var pathElement in this.prunedChain.ToImmutable().NavigateTowards(() => this.coreDaemon.CurrentChain))              {                  // cooperative loop                  if (!this.IsStarted)                      break;                    // get candidate block to be pruned                  var direction = pathElement.Item1;                  var chainedHeader = pathElement.Item2;                    // get the current processed chain                  var processedChain = this.coreDaemon.CurrentChain;                    // determine maximum safe pruning height' based on a buffer distance from the processed chain height                  var blocksPerDay = 144;                  //TODO there should also be a buffer between when blocks are pruned' and when the pruning information                  //TODO to perform that operation is removed (tx index' spent txes)                  var pruneBuffer = blocksPerDay * 7;                  var maxHeight = processedChain.Height - pruneBuffer;                  //TODO                  maxHeight = Math.Min(maxHeight' this.PrunableHeight);                    // check if this block is safe to prune                  if (chainedHeader.Height > maxHeight)                      break;                    if (direction > 0)                  {                      // prune the block' except genesis block                      if (chainedHeader.Height > 0)                          await this.PruneBlock(mode' processedChain' chainedHeader);                        // track pruned block                      this.prunedChain.AddBlock(chainedHeader);                  }                  else if (direction < 0)                  {                      // pruning should not roll back' the buffer is in place to prevent this on orphans                      throw new InvalidOperationException();                  }                  else                  {                      throw new InvalidOperationException();                  }                    // pause chain state processing when pruning lags too far behind                  var isLagging = maxHeight - chainedHeader.Height > 100;                  if (isLagging)                  {                      Throttler.IfElapsed(TimeSpan.FromSeconds(5)' () =>                      {                          logger.Info("Pruning is lagging.");                          lagLogged = true;                      });                        //TODO better way to block chain state worker when pruning is behind                      if (this.chainStateWorker?.IsStarted ?? false)                          this.chainStateWorker.Stop(TimeSpan.Zero);                  }                  else                  {                      //TODO better way to block chain state worker when pruning is behind                      if (!(this.chainStateWorker?.IsStarted ?? true))                      {                          this.chainStateWorker.NotifyAndStart();                          if (lagLogged)                          {                              logger.Info("Pruning is caught up.");                              lagLogged = false;                          }                      }                  }                    // log pruning stats periodically                  Throttler.IfElapsed(TimeSpan.FromSeconds(15)' () =>                  {                      logger.Info(string.Join(Environment.NewLine'                          $"Pruned from block {lastLogHeight:N0} to {chainedHeader.Height:N0}:"'                          $"- avg tx rate:    {txRateMeasure.GetAverage()'8:N0}/s"'                          $"- per block stats:"'                          $"- tx count:       {txCountMeasure.GetAverage()'8:N0}"'                          $"- prune blocks:   {pruneBlockTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune index:    {pruneTxIndexDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- prune spent:    {pruneSpentTxesDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"'                          $"- TOTAL:          {totalDurationMeasure.GetAverage().TotalMilliseconds'12:N3}ms"                      ));                        lastLogHeight = chainedHeader.Height + 1;                  });              }
Missing Default,BitSharp.Core.Rules,CoreRules,C:\repos\pmlyon_BitSharp\BitSharp.Core\Rules\CoreRules.cs,CountLegacySigOps,The following switch statement is missing a default case: switch (op)                  {                      case ScriptOp.OP_CHECKSIG:                      case ScriptOp.OP_CHECKSIGVERIFY:                          sigOpCount++;                          break;                        case ScriptOp.OP_CHECKMULTISIG:                      case ScriptOp.OP_CHECKMULTISIGVERIFY:                          //TODO                          var prevOpCode = index >= 2 ? script[index - 2] : (byte)ScriptOp.OP_INVALIDOPCODE;                          if (accurate && prevOpCode >= (byte)ScriptOp.OP_1 && prevOpCode <= (byte)ScriptOp.OP_16)                              sigOpCount += prevOpCode - ((byte)ScriptOp.OP_1 - 1);                          else                              sigOpCount += MAX_PUBKEYS_PER_MULTISIG;                            break;                  }
