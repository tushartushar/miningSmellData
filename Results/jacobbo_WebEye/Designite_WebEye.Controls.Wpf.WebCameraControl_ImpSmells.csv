Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,WebEye.Controls.Wpf,VideoWindow,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\VideoWindow.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Statement,WebEye.Controls.Wpf,WebCameraControl,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\WebCameraControl.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/WebEye.Controls.Wpf.WebCameraControl;component/webcameracontrol.xaml"' System.UriKind.Relative); " is 142.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Magic Number,WebEye.Controls.Wpf,WebCameraId,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\WebCameraId.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (Name.GetHashCode() * 397) ^ DevicePath.GetHashCode();              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Magic Number,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following statement contains a magic number: try              {                  BITMAPINFOHEADER biHeader = (BITMAPINFOHEADER)Marshal.PtrToStructure(dibPtr' typeof(BITMAPINFOHEADER));                  Int32 stride = biHeader.biWidth * (biHeader.biBitCount / 8);                    // The bits in the array are packed together' but each scan line must be                  // padded with zeros to end on a LONG data-type boundary.                  Int32 padding = stride % 4 > 0 ? 4 - stride % 4 : 0;                  stride += padding;                    PixelFormat pixelFormat = PixelFormat.Undefined;                  switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }                    Bitmap image = new Bitmap(biHeader.biWidth' biHeader.biHeight' stride'                      pixelFormat' (IntPtr)(dibPtr.ToInt64() + Marshal.SizeOf(biHeader)));                  image.RotateFlip(RotateFlipType.RotateNoneFlipY);                    return image;              }              finally              {                  if (dibPtr != IntPtr.Zero)                  {                      Marshal.FreeCoTaskMem(dibPtr);                  }              }
Missing Default,WebEye.Controls.Wpf,DirectShowProxy,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\DirectShowProxy.cs,GetCurrentImage,The following switch statement is missing a default case: switch (biHeader.biBitCount)                  {                      case 1:                          pixelFormat = PixelFormat.Format1bppIndexed;                          break;                      case 4:                          pixelFormat = PixelFormat.Format4bppIndexed;                          break;                      case 8:                          pixelFormat = PixelFormat.Format8bppIndexed;                          break;                      case 16:                          pixelFormat = PixelFormat.Format16bppRgb555;                          break;                      case 24:                          pixelFormat = PixelFormat.Format24bppRgb;                          break;                      case 32:                          pixelFormat = PixelFormat.Format32bppRgb;                          break;                  }
Missing Default,WebEye.Controls.Wpf,WebCameraControl,C:\repos\jacobbo_WebEye\WebCameraControl\WPF\WebCameraControl\WebCameraControl.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this._videoWindow = ((WebEye.Controls.Wpf.VideoWindow)(target));              return;              }
