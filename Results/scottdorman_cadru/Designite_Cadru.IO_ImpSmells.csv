Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Cadru.IO.Interop,SafeNativeMethods,C:\repos\scottdorman_cadru\src\Cadru.IO\InteropServices\SafeNativeMethods.cs,NetServerEnum,The method has 9 parameters. Parameters: servername' level' bufptr' prefmaxlen' entriesread' totalentries' servertype' domain' resume_handle
Long Parameter List,Cadru.IO.Interop,SafeNativeMethods,C:\repos\scottdorman_cadru\src\Cadru.IO\InteropServices\SafeNativeMethods.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' sfi' cbFileInfo' uFlags
Long Statement,Cadru.IO,ExtendedFileInfo,C:\repos\scottdorman_cadru\src\Cadru.IO\ExtendedFileInfo.cs,Initialize,The length of the statement  "                IntPtr ptr = SafeNativeMethods.SHGetFileInfo(fileName' FileAttributes.Normal' ref this.shellFileInfo' Marshal.SizeOf<SHFILEINFO>()' SHGFI.TYPENAME); " is 148.
Long Statement,Cadru.IO,ExtendedFileInfo,C:\repos\scottdorman_cadru\src\Cadru.IO\ExtendedFileInfo.cs,Initialize,The length of the statement  "                ptr = SafeNativeMethods.SHGetFileInfo(fileName' FileAttributes.Normal' ref this.shellFileInfo' Marshal.SizeOf<SHFILEINFO>()' SHGFI.EXETYPE); " is 140.
Long Statement,Cadru.IO,ExtendedFileInfo,C:\repos\scottdorman_cadru\src\Cadru.IO\ExtendedFileInfo.cs,Initialize,The length of the statement  "                //                                                  Microsoft Windows NT' Windows 2000' Windows XP: MS-DOS .exe or .com file " is 124.
Long Statement,Cadru.IO,ExtendedFileInfo,C:\repos\scottdorman_cadru\src\Cadru.IO\ExtendedFileInfo.cs,Initialize,The length of the statement  "                //                                                  Windows NT' Windows 2000' Windows XP: Win32 console application or .bat file " is 128.
Magic Number,Cadru.IO,ExtendedFileInfo,C:\repos\scottdorman_cadru\src\Cadru.IO\ExtendedFileInfo.cs,Initialize,The following statement contains a magic number: if (this.fileInfo.Exists)              {                  this.fileVersionInfo = FileVersionInfo.GetVersionInfo(fileName);                    // Try to fill the SHFILEINFO struct for the file type' if the returned pointer is 0 then an error occurred.                  IntPtr ptr = SafeNativeMethods.SHGetFileInfo(fileName' FileAttributes.Normal' ref this.shellFileInfo' Marshal.SizeOf<SHFILEINFO>()' SHGFI.TYPENAME);                  if (ptr == IntPtr.Zero)                  {                      throw new IOException();                  }                    Marshal.FreeCoTaskMem(ptr);                    // Try to fill the same SHFILEINFO struct for the exe type. The returned pointer contains the encoded                  // executable type data.                  ptr = IntPtr.Zero;                  ptr = SafeNativeMethods.SHGetFileInfo(fileName' FileAttributes.Normal' ref this.shellFileInfo' Marshal.SizeOf<SHFILEINFO>()' SHGFI.EXETYPE);                    // We need to split the returned pointer up into the high and low order words. These are important                  // because they help distinguish some of the types. The possible values are:                  //                  // Value                                            Meaning                  // ----------------------------------------------------------------------------------------------                  // 0                                                Nonexecutable file or an error condition.                  // LOWORD = NE or PE and HIWORD = Windows version   Microsoft Windows application.                  // LOWORD = MZ and HIWORD = 0                       Windows 95' Windows 98: Microsoft MS-DOS .exe' .com' or .bat file                  //                                                  Microsoft Windows NT' Windows 2000' Windows XP: MS-DOS .exe or .com file                  // LOWORD = PE and HIWORD = 0                       Windows 95' Windows 98: Microsoft Win32 console application                  //                                                  Windows NT' Windows 2000' Windows XP: Win32 console application or .bat file                  // MZ = 0x5A4D - DOS signature.                  // NE = 0x454E - OS/2 signature.                  // LE = 0x454C - OS/2 LE or VXD signature.                  // PE = 0x4550 - Win32/NT signature.                  int wparam = ptr.ToInt32();                  int loWord = wparam & 0xffff;                  int hiWord = wparam >> 16;                    if (wparam == 0)                  {                      this.executableType = ExecutableType.Unknown;                  }                  else                  {                      if (hiWord == 0x0000)                      {                          if (loWord == 0x5A4D)                          {                              // The file is an MS-DOS .exe' .com' or .bat                              this.executableType = ExecutableType.DOS;                          }                          else if (loWord == 0x4550)                          {                              this.executableType = ExecutableType.Win32Console;                          }                      }                      else                      {                          if (loWord == 0x454E || loWord == 0x4550)                          {                              this.executableType = ExecutableType.Windows;                          }                          else if (loWord == 0x454C)                          {                              this.executableType = ExecutableType.Windows;                          }                      }                  }                    FileSecurity fs = new FileSecurity(this.originalFileName' AccessControlSections.Owner);                  owner = fs.GetOwner(typeof(NTAccount)).ToString();              }
