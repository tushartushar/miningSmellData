Implementation smell,Namespace,Class,File,Method,Description
Long Method,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The method has 217 lines of code.
Long Method,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The method has 263 lines of code.
Long Method,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,ParseDictionary,The method has 130 lines of code.
Long Method,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ParseDictionary,The method has 122 lines of code.
Complex Method,RaptorDB,View<T>,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\View.cs,Verify,Cyclomatic complexity of the method is 8
Complex Method,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,ToObject,Cyclomatic complexity of the method is 12
Complex Method,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,ParseDictionary,Cyclomatic complexity of the method is 20
Complex Method,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteObject,Cyclomatic complexity of the method is 8
Complex Method,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ChangeType,Cyclomatic complexity of the method is 8
Complex Method,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ParseDictionary,Cyclomatic complexity of the method is 20
Complex Method,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ReadDataTable,Cyclomatic complexity of the method is 10
Complex Method,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,Cyclomatic complexity of the method is 10
Complex Method,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteObject,Cyclomatic complexity of the method is 9
Complex Method,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteString,Cyclomatic complexity of the method is 8
Complex Method,fastJSON,Reflection,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\Reflection.cs,GetGetters,Cyclomatic complexity of the method is 23
Long Parameter List,RaptorDB,FileLogger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,FormatLog,The method has 5 parameters. Parameters: log' type' meth' msg' objs
Long Parameter List,RaptorDB,FileLogger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,Log,The method has 5 parameters. Parameters: logtype' type' meth' msg' objs
Long Parameter List,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The method has 8 parameters. Parameters: src' srcstart' srcLength' dst' dststart' dstlen' workmem' workmemstart
Long Parameter List,RaptorDB,RaptorDBClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\RaptorDBClient.cs,Query,The method has 5 parameters. Parameters: viewname' filter' start' count' orderby
Long Parameter List,RaptorDB,RaptorDBClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\RaptorDBClient.cs,Query,The method has 5 parameters. Parameters: viewname' filter' start' count' orderby
Long Parameter List,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The method has 9 parameters. Parameters: year' month' day' hour' min' sec' milli' extraTicks' offset
Long Parameter List,RaptorDB.Common,IRaptorDB,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\IRaptorDB.cs,Query,The method has 5 parameters. Parameters: viewname' filter' start' count' orderby
Long Parameter List,RaptorDB.Common,ZIP,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,docompressdirectory,The method has 5 parameters. Parameters: zip' dir' prefix' recursive' log
Long Parameter List,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,AddStream,The method has 5 parameters. Parameters: _method' _filenameInZip' _source' _modTime' _comment
Long Statement,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The length of the statement  "            uint compressedSize = Compress(sourceBuffer' sourceOffset' sourceLength' destinationBuffer' 0' destinationLength' workspaceBuffer' workspaceOffset); " is 148.
Long Statement,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The length of the statement  "            byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))]; " is 132.
Long Statement,RaptorDB,View<T>,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\View.cs,Verify,The length of the statement  "                        throw new Exception("The schema must be derived from RaptorDB.RDBSchema or must contain a 'docid' Guid field or property"); " is 123.
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,ParseDictionary,The length of the statement  "            Dictionary<string' myPropInfo> props = Reflection.Instance.Getproperties(type' typename);//' Reflection.Instance.IsTypeRegistered(type)); " is 137.
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataset,The length of the statement  "                DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 128.
Long Statement,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataTable,The length of the statement  "                var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 123.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ParseDictionary,The length of the statement  "            Dictionary<string' myPropInfo> props = Reflection.Instance.Getproperties(type' typename);//' Reflection.Instance.IsTypeRegistered(type)); " is 137.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ParseDictionary,The length of the statement  "                            case myPropInfoType.StringKeyDictionary: oset = CreateStringKeyDictionary((Dictionary<string' object>)v' pi.pt' pi.GenericTypes' globaltypes); break; " is 149.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataset,The length of the statement  "                DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 128.
Long Statement,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataTable,The length of the statement  "                var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null); " is 123.
Long Statement,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Open,The length of the statement  "            Stream stream = (Stream)new FileStream(_filename' FileMode.Open' _access == FileAccess.Read ? FileAccess.Read : FileAccess.ReadWrite); " is 134.
Long Statement,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The length of the statement  "            this.ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0))' 0' 2); // filename and comment encoding  " is 127.
Long Statement,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The length of the statement  "            this.ZipFileStream.Write(new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0 }' 0' 12); // unused CRC' un/compressed size' updated later " is 132.
Long Statement,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The length of the statement  "            this.ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0))' 0' 2); // filename and comment encoding  " is 127.
Long Statement,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Store,The length of the statement  "            if (_zfe.Method == Compression.Deflate && !this.ForceDeflating && _source.CanSeek && _zfe.CompressedSize > _zfe.FileSize) " is 121.
Complex Conditional,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The conditional expression  "pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++"  is complex.
Complex Conditional,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The conditional expression  "!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match"  is complex.
Complex Conditional,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,ParseDictionary,The conditional expression  "(pi.IsClass || pi.IsStruct || pi.IsInterface) && v is Dictionary<string' object>"  is complex.
Complex Conditional,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ParseDictionary,The conditional expression  "(pi.IsClass || pi.IsStruct || pi.IsInterface) && v is Dictionary<string' object>"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseNumber,The conditional expression  "(c >= '0' && c <= '9') || c == '.' || c == '-' || c == '+' || c == 'e' || c == 'E'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "c != ' ' && c != '\t' && c != '\n' && c != '\r'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e'"  is complex.
Complex Conditional,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The conditional expression  "json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l'"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteValue,The conditional expression  "obj is int || obj is long ||                  obj is decimal ||                  obj is byte || obj is short ||                  obj is sbyte || obj is ushort ||                  obj is uint || obj is ulong"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteValue,The conditional expression  "_params.KVStyleStringDictionary == false && obj is IDictionary &&                  obj.GetType().IsGenericType && obj.GetType().GetGenericArguments()[0] == typeof(string)"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteString,The conditional expression  "c >= ' ' && c < 128 && c != '\"' && c != '\\'"  is complex.
Complex Conditional,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteString,The conditional expression  "c != '\t' && c != '\n' && c != '\r' && c != '\"' && c != '\\'"  is complex.
Complex Conditional,fastJSON,Reflection,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\Reflection.cs,CreateMyProp,The conditional expression  "t.IsValueType && !t.IsPrimitive && !t.IsEnum && t != typeof(decimal)"  is complex.
Complex Conditional,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Store,The conditional expression  "_zfe.Method == Compression.Deflate && !this.ForceDeflating && _source.CanSeek && _zfe.CompressedSize > _zfe.FileSize"  is complex.
Empty Catch Block,RaptorDB,RaptorDBClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\RaptorDBClient.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadFileInfo,The method has an empty catch block.
Magic Number,RaptorDB,StringIndexLength,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Interfaces.cs,StringIndexLength,The following statement contains a magic number: Length = 60;
Magic Number,RaptorDB,FileLogger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,Init,The following statement contains a magic number: _saveTimer = new System.Timers.Timer(500);
Magic Number,RaptorDB,FileLogger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,WriteData,The following statement contains a magic number: lock (_que)              {                  while (_que.Count > 0)                  {                      object o = _que.Dequeue();                      if (_output != null && o != null)                      {                          if (_sizeLimit > 0)                          {                              // implement size limited logs                              // implement rolling logs                              #region [  rolling size limit ]                              _lastSize += ("" + o).Length;                              if (_lastSize > _sizeLimit * 1000)                              {                                  _output.Flush();                                  _output.Close();                                  int count = 1;                                  while (File.Exists(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")))                                      count++;                                    File.Move(_filename'                                      _FilePath +                                      Path.GetFileNameWithoutExtension(_filename) +                                      "." + count.ToString("0000"));                                  _output = new StreamWriter(_filename' true);                                  _lastSize = 0;                              }                              #endregion                          }                          if (DateTime.Now.Subtract(_lastFileDate).Days > 0)                          {                              // implement date logs                              #region [  rolling dates  ]                              _output.Flush();                              _output.Close();                              int count = 1;                              while (File.Exists(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")))                              {                                  File.Move(_FilePath + Path.GetFileNameWithoutExtension(_filename) + "." + count.ToString("0000")'                                     _FilePath +                                     Path.GetFileNameWithoutExtension(_filename) +                                     "." + count.ToString("0000") +                                     "." + _lastFileDate.ToString("yyyy-MM-dd"));                                  count++;                              }                              File.Move(_filename'                                 _FilePath +                                 Path.GetFileNameWithoutExtension(_filename) +                                 "." + count.ToString("0000") +                                 "." + _lastFileDate.ToString("yyyy-MM-dd"));                              // compress old logs here                              ZipLogs(_FilePath' _lastFileDate);                                _output = new StreamWriter(_filename' true);                              _lastFileDate = DateTime.Now;                              _lastSize = 0;                              #endregion                          }                          _output.Write(o);                      }                  }                  if (_output != null)                      _output.Flush();              }
Magic Number,RaptorDB,logger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,log,The following statement contains a magic number: if (FileLogger.Instance.ShowMethodNames)              {                  System.Diagnostics.StackTrace st = new System.Diagnostics.StackTrace(2);                  System.Diagnostics.StackFrame sf = st.GetFrame(0);                  meth = sf.GetMethod().Name;              }
Magic Number,RaptorDB,logger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,Error,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 4)                  log("ERROR"' "" + msg' objs);
Magic Number,RaptorDB,logger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,Warn,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 3)                  log("WARN"' "" + msg' objs);
Magic Number,RaptorDB,logger,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\Logger.cs,Debug,The following statement contains a magic number: if (FileLogger.Instance._logabove <= 2)                  log("DEBUG"' "" + msg' objs);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,MiniLZO,The following statement contains a magic number: if (IntPtr.Size == 8)                  DICT_SIZE = (65536 + 3) * 2;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint dstlen = (uint)(srcLength + (srcLength / 16) + 64 + 3 + 4);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: destinationLength = sourceLength + (sourceLength / 16) + 64 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: uint inplaceOverhead = Math.Min(sourceLength' M4_MAX_OFFSET) + sourceLength / 64 + 16 + 3 + 4;
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (srcLength <= M2_MAX_LEN + 5)              {                  tmp = (uint)srcLength;                  dstlen = 0;              }              else              {                  fixed (byte* work = &workmem[workmemstart]' input = &src[srcstart]' output = &dst[dststart])                  {                      byte** dict = (byte**)work;                      byte* in_end = input + srcLength;                      byte* ip_end = input + srcLength - M2_MAX_LEN - 5;                      byte* ii = input;                      byte* ip = input + 4;                      byte* op = output;                      bool literal = false;                      bool match = false;                      uint offset;                      uint length;                      uint index;                      byte* pos;                        for (; ; )                      {                          offset = 0;                          index = D_INDEX1(ip);                          pos = ip - (ip - dict[index]);                          if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                              literal = true;                          else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                          else                          {                              index = D_INDEX2(index);                              pos = ip - (ip - dict[index]);                              if (pos < input || (offset = (uint)(ip - pos)) <= 0 || offset > M4_MAX_OFFSET)                                  literal = true;                              else if (offset <= M2_MAX_OFFSET || pos[3] == ip[3]) { }                              else                                  literal = true;                          }                            if (!literal)                          {                              if (*((ushort*)pos) == *((ushort*)ip) && pos[2] == ip[2])                                  match = true;                          }                            literal = false;                          if (!match)                          {                              dict[index] = ip;                              ++ip;                              if (ip >= ip_end)                                  break;                              continue;                          }                          match = false;                          dict[index] = ip;                          if (ip - ii > 0)                          {                              uint t = (uint)(ip - ii);                              if (t <= 3)                              {                                  //Debug.Assert(op - 2 > output);                                  op[-2] |= (byte)(t);                              }                              else if (t <= 18)                                  *op++ = (byte)(t - 3);                              else                              {                                  uint tt = t - 18;                                  *op++ = 0;                                  while (tt > 255)                                  {                                      tt -= 255;                                      *op++ = 0;                                  }                                  //Debug.Assert(tt > 0);                                  *op++ = (byte)(tt);                              }                              do                              {                                  *op++ = *ii++;                              } while (--t > 0);                          }                          //Debug.Assert(ii == ip);                          ip += 3;                          if (pos[3] != *ip++ || pos[4] != *ip++ || pos[5] != *ip++                             || pos[6] != *ip++ || pos[7] != *ip++ || pos[8] != *ip++)                          {                              --ip;                              length = (uint)(ip - ii);                              //Debug.Assert(length >= 3);                              //Debug.Assert(length <= M2_MAX_LEN);                              if (offset <= M2_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(((length - 1) << 5) | ((offset & 7) << 2));                                  *op++ = (byte)(offset >> 3);                              }                              else if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  *op++ = (byte)(M3_MARKER | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  *op++ = (byte)((offset & 63) << 2);                                  *op++ = (byte)(offset >> 6);                              }                          }                          else                          {                              byte* m = pos + M2_MAX_LEN + 1;                              while (ip < in_end && *m == *ip)                              {                                  ++m;                                  ++ip;                              }                              length = (uint)(ip - ii);                              //Debug.Assert(length > M2_MAX_LEN);                              if (offset <= M3_MAX_OFFSET)                              {                                  --offset;                                  if (length <= 33)                                      *op++ = (byte)(M3_MARKER | (length - 2));                                  else                                  {                                      length -= 33;                                      *op++ = M3_MARKER | 0;                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              else                              {                                  offset -= 0x4000;                                  //Debug.Assert(offset > 0);                                  //Debug.Assert(offset <= 0x7FFF);                                  if (length <= M4_MAX_LEN)                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11) | (length - 2));                                  else                                  {                                      length -= M4_MAX_LEN;                                      *op++ = (byte)(M4_MARKER | ((offset & 0x4000) >> 11));                                      while (length > 255)                                      {                                          length -= 255;                                          *op++ = 0;                                      }                                      //Debug.Assert(length > 0);                                      *op++ = (byte)(length);                                  }                              }                              *op++ = (byte)((offset & 63) << 2);                              *op++ = (byte)(offset >> 6);                          }                          ii = ip;                          if (ip >= ip_end)                              break;                      }                      dstlen = (uint)(op - output);                      tmp = (uint)(in_end - ii);                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: if (tmp > 0)              {                  uint ii = (uint)srcLength - tmp + srcstart;                  if (dstlen == 0 && tmp <= 238)                  {                      dst[dstlen++] = (byte)(17 + tmp);                  }                  else if (tmp <= 3)                  {                      dst[dstlen - 2] |= (byte)(tmp);                  }                  else if (tmp <= 18)                  {                      dst[dstlen++] = (byte)(tmp - 3);                  }                  else                  {                      uint tt = tmp - 18;                      dst[dstlen++] = 0;                      while (tt > 255)                      {                          tt -= 255;                          dst[dstlen++] = 0;                      }                      //Debug.Assert(tt > 0);                      dst[dstlen++] = (byte)(tt);                  }                  do                  {                      dst[dstlen++] = src[ii++];                  } while (--tmp > 0);              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 8);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 16);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Compress,The following statement contains a magic number: dst[dstlen++] = (byte)(srcLength >> 24);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: byte[] dst = new byte[(src[src.Length - 4] | (src[src.Length - 3] << 8) | (src[src.Length - 2] << 16 | src[src.Length - 1] << 24))];
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* input = src' output = dst)              {                  byte* pos = null;                  byte* ip_end = input + src.Length - 4;                  byte* op_end = output + dst.Length;                  byte* ip = input;                  byte* op = output;                  bool match = false;                  bool match_next = false;                  bool match_done = false;                  bool copy_match = false;                  bool first_literal_run = false;                  bool eof_found = false;                    if (*ip > 17)                  {                      t = (uint)(*ip++ - 17);                      if (t < 4)                          match_next = true;                      else                      {                          //Debug.Assert(t > 0);                          if ((op_end - op) < t)                              throw new OverflowException("Output Overrun");                          if ((ip_end - ip) < t + 1)                              throw new OverflowException("Input Overrun");                          do                          {                              *op++ = *ip++;                          } while (--t > 0);                          first_literal_run = true;                      }                  }                  while (!eof_found && ip < ip_end)                  {                      if (!match_next && !first_literal_run)                      {                          t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(15 + *ip++);                              }                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 3)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 4)                                  throw new OverflowException("Input Overrun");                              for (int x = 0; x < 4; ++x' ++op' ++ip)                                  *op = *ip;                              if (--t > 0)                              {                                  if (t >= 4)                                  {                                      do                                      {                                          for (int x = 0; x < 4; ++x' ++op' ++ip)                                              *op = *ip;                                          t -= 4;                                      } while (t >= 4);                                      if (t > 0)                                      {                                          do                                          {                                              *op++ = *ip++;                                          } while (--t > 0);                                      }                                  }                                  else                                  {                                      do                                      {                                          *op++ = *ip++;                                      } while (--t > 0);                                  }                              }                          }                      }                      if (!match && !match_next)                      {                          first_literal_run = false;                            t = *ip++;                          if (t >= 16)                              match = true;                          else                          {                              pos = op - (1 + M2_MAX_OFFSET);                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 3)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                      }                      match = false;                      do                      {                          if (t >= 64)                          {                              pos = op - 1;                              pos -= (t >> 2) & 7;                              pos -= *ip++ << 3;                              t = (t >> 5) - 1;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                              copy_match = true;                          }                          else if (t >= 32)                          {                              t &= 31;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(31 + *ip++);                              }                              pos = op - 1;                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                          }                          else if (t >= 16)                          {                              pos = op;                              pos -= (t & 8) << 11;                                t &= 7;                              if (t == 0)                              {                                  if ((ip_end - ip) < 1)                                      throw new OverflowException("Input Overrun");                                  while (*ip == 0)                                  {                                      t += 255;                                      ++ip;                                      if ((ip_end - ip) < 1)                                          throw new OverflowException("Input Overrun");                                  }                                  t += (uint)(7 + *ip++);                              }                              pos -= (*(ushort*)ip) >> 2;                              ip += 2;                              if (pos == op)                                  eof_found = true;                              else                                  pos -= 0x4000;                          }                          else                          {                              pos = op - 1;                              pos -= t >> 2;                              pos -= *ip++ << 2;                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              if ((op_end - op) < 2)                                  throw new OverflowException("Output Overrun");                              *op++ = *pos++;                              *op++ = *pos++;                              match_done = true;                          }                          if (!eof_found && !match_done && !copy_match)                          {                              if (pos < output || pos >= op)                                  throw new OverflowException("Lookbehind Overrun");                              //Debug.Assert(t > 0);                              if ((op_end - op) < t + 2)                                  throw new OverflowException("Output Overrun");                          }                          if (!eof_found && t >= 2 * 4 - 2 && (op - pos) >= 4 && !match_done && !copy_match)                          {                              for (int x = 0; x < 4; ++x' ++op' ++pos)                                  *op = *pos;                              t -= 2;                              do                              {                                  for (int x = 0; x < 4; ++x' ++op' ++pos)                                      *op = *pos;                                  t -= 4;                              } while (t >= 4);                              if (t > 0)                              {                                  do                                  {                                      *op++ = *pos++;                                  } while (--t > 0);                              }                          }                          else if (!eof_found && !match_done)                          {                              copy_match = false;                                *op++ = *pos++;                              *op++ = *pos++;                              do                              {                                  *op++ = *pos++;                              } while (--t > 0);                          }                            if (!eof_found && !match_next)                          {                              match_done = false;                                t = (uint)(ip[-2] & 3);                              if (t == 0)                                  break;                          }                          if (!eof_found)                          {                              match_next = false;                              //Debug.Assert(t > 0);                              //Debug.Assert(t < 4);                              if ((op_end - op) < t)                                  throw new OverflowException("Output Overrun");                              if ((ip_end - ip) < t + 1)                                  throw new OverflowException("Input Overrun");                              *op++ = *ip++;                              if (t > 1)                              {                                  *op++ = *ip++;                                  if (t > 2)                                      *op++ = *ip++;                              }                              t = *ip++;                          }                      } while (!eof_found && ip < ip_end);                  }                  if (!eof_found)                      throw new OverflowException("EOF Marker Not Found");                  else                  {                      //Debug.Assert(t == 1);                      if (ip > ip_end)                          throw new OverflowException("Input Overrun");                      else if (ip < ip_end)                          throw new OverflowException("Input Not Consumed");                  }              }
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,D_INDEX1,The following statement contains a magic number: return D_MS(D_MUL(0x21' D_X3(input' 5' 5' 6)) >> 5' 0);
Magic Number,RaptorDB,MiniLZO,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MiniLZO.cs,D_X2,The following statement contains a magic number: return (uint)((((input[2] << s2) ^ input[1]) << s1) ^ input[0]);
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseObject,The following statement contains a magic number: while (!breakparse)              {                  byte t = GetToken();                  if (t == TOKENS.COMMA)                      continue;                  if (t == TOKENS.DOC_END)                      break;                  if (t == TOKENS.TYPES_POINTER)                  {                      // save curr index position                      int savedindex = _index;                      // set index = pointer                       _index = ParseInt();                      t = GetToken();                      // read $types                      breakparse = readkeyvalue(dic' ref t);                      // set index = saved + 4                      _index = savedindex + 4;                  }                  else                      breakparse = readkeyvalue(dic' ref t);              }
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseChar,The following statement contains a magic number: _index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: byte[] b = new byte[16];
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: Buffer.BlockCopy(_json' _index' b' 0' 16);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseGuid,The following statement contains a magic number: _index += 16;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseFloat,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseUShort,The following statement contains a magic number: _index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseULong,The following statement contains a magic number: _index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseUint,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseShort,The following statement contains a magic number: _index += 2;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseLong,The following statement contains a magic number: _index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseInt,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDouble,The following statement contains a magic number: _index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseUnicodeString,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseString,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: int[] i = new int[4];
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: i[2] = Helper.ToInt32(_json' _index);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: i[3] = Helper.ToInt32(_json' _index);
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDecimal,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseDateTime,The following statement contains a magic number: _index += 8;
Magic Number,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseByteArray,The following statement contains a magic number: _index += 4;
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,ConvertToBJSON,The following statement contains a magic number: if (_params.UsingGlobalTypes && _globalTypes != null && _globalTypes.Count > 0)              {                  var pointer = (int)_output.Length;                  WriteName("$types");                  WriteColon();                  WriteTypes(_globalTypes);                  //var i = _output.Length;                  _output.Seek(_typespointer' SeekOrigin.Begin);                  _output.Write(Helper.GetBytes(pointer' false)' 0' 4);                    return _output.ToArray();              }
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteTypedArray,The following statement contains a magic number: if (t != null) // non generic array              {                  if (t.GetElementType().IsClass)                  {                      _output.WriteByte(TOKENS.ARRAY_TYPED);                      token = false;                      // array type name                      byte[] b = Reflection.Instance.utf8.GetBytes(Reflection.Instance.GetTypeAssemblyName(t.GetElementType()));                      _output.WriteByte((byte)b.Length);                      _output.Write(b' 0' b.Length % 256);                      // array count                      _output.Write(Helper.GetBytes(array.Count' false)' 0' 4); //count                  }              }
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteTypedArray,The following statement contains a magic number: if (t != null) // non generic array              {                  if (t.GetElementType().IsClass)                  {                      _output.WriteByte(TOKENS.ARRAY_TYPED);                      token = false;                      // array type name                      byte[] b = Reflection.Instance.utf8.GetBytes(Reflection.Instance.GetTypeAssemblyName(t.GetElementType()));                      _output.WriteByte((byte)b.Length);                      _output.Write(b' 0' b.Length % 256);                      // array count                      _output.Write(Helper.GetBytes(array.Count' false)' 0' 4); //count                  }              }
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteUShort,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteShort,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteDecimal,The following statement contains a magic number: foreach (var c in b)                  _output.Write(Helper.GetBytes(c' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteULong,The following statement contains a magic number: _output.Write(Helper.GetBytes((long)p' false)' 0' 8);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteUInt,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteLong,The following statement contains a magic number: _output.Write(Helper.GetBytes(p' false)' 0' 8);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteChar,The following statement contains a magic number: _output.Write(Helper.GetBytes((short)p' false)' 0' 2);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteBytes,The following statement contains a magic number: _output.Write(Helper.GetBytes(p.Length' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteInt,The following statement contains a magic number: _output.Write(Helper.GetBytes(i' false)' 0' 4);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteGuid,The following statement contains a magic number: _output.Write(g.ToByteArray()' 0' 16);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteObject,The following statement contains a magic number: if (_params.UsingGlobalTypes == false)                  _output.WriteByte(TOKENS.DOC_START);              else              {                  if (_TypesWritten == false)                  {                      _output.WriteByte(TOKENS.DOC_START);                      // write pointer to $types position                      _output.WriteByte(TOKENS.TYPES_POINTER);                      _typespointer = (int)_output.Length; // place holder                      _output.Write(new byte[4]' 0' 4); // zero pointer for now                                                        //_output = new MemoryStream();                      _TypesWritten = true;                  }                  else                      _output.WriteByte(TOKENS.DOC_START);                }
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteObject,The following statement contains a magic number: if (_params.UsingGlobalTypes == false)                  _output.WriteByte(TOKENS.DOC_START);              else              {                  if (_TypesWritten == false)                  {                      _output.WriteByte(TOKENS.DOC_START);                      // write pointer to $types position                      _output.WriteByte(TOKENS.TYPES_POINTER);                      _typespointer = (int)_output.Length; // place holder                      _output.Write(new byte[4]' 0' 4); // zero pointer for now                                                        //_output = new MemoryStream();                      _TypesWritten = true;                  }                  else                      _output.WriteByte(TOKENS.DOC_START);                }
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteName,The following statement contains a magic number: _output.Write(b' 0' b.Length % 256);
Magic Number,fastBinaryJSON,BJSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonSerializer.cs,WriteString,The following statement contains a magic number: _output.Write(Helper.GetBytes(b.Length' false)' 0' 4);
Magic Number,fastJSON,JSON,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateLong,The following statement contains a magic number: for (int x = 0; x < count; x++' index++)              {                  char cc = s[index];                    if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: year = CreateInteger(value' 0' 4);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: int p = 20;
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')              {                  ms = CreateInteger(value' p' 3);                  p = 23;                    // handle 7 digit case                  if (value.Length > 25 && char.IsDigit(value[p]))                  {                      usTicks = CreateInteger(value' p' 4);                      p = 27;                  }                              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: th = CreateInteger(value' p + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: tm = CreateInteger(value' p + 1 + 2 + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTimeOffset,The following statement contains a magic number: tm = CreateInteger(value' p + 1 + 2 + 1' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateLong,The following statement contains a magic number: for (int x = 0; x < count; x++' index++)              {                  char cc = s[index];                    if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateInteger,The following statement contains a magic number: for (int x = 0; x < count; x++' index++)              {                  char cc = s[index];                    if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateGuid,The following statement contains a magic number: if (s.Length > 30)                  return new Guid(s);              else                  return new Guid(Convert.FromBase64String(s));
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length < 19)                  return DateTime.MinValue;
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: year = CreateInteger(value' 0' 4);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: month = CreateInteger(value' 5' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: day = CreateInteger(value' 8' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: hour = CreateInteger(value' 11' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: min = CreateInteger(value' 14' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: sec = CreateInteger(value' 17' 2);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDateTime,The following statement contains a magic number: if (value.Length > 21 && value[19] == '.')                  ms = CreateInteger(value' 20' 3);
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataset,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  ds.ReadXmlSchema(tr);              }              else              {                  DatasetSchema ms = (DatasetSchema)ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  ds.DataSetName = ms.Name;                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      if (ds.Tables.Contains(ms.Info[i]) == false)                          ds.Tables.Add(ms.Info[i]);                      ds.Tables[ms.Info[i]].Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,ReadDataTable,The following statement contains a magic number: foreach (List<object> row in rows)              {                  object[] v = new object[row.Count];                  row.CopyTo(v' 0);                  foreach (int i in guidcols)                  {                      string s = (string)v[i];                      if (s != null && s.Length < 36)                          v[i] = new Guid(Convert.FromBase64String(s));                  }                  if (_params.UseUTCDateTime)                  {                      foreach (int i in datecol)                      {                          string s = (string)v[i];                          if (s != null)                              v[i] = CreateDateTime(s);                      }                  }                  dt.Rows.Add(v);              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,deserializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JSON.cs,CreateDataTable,The following statement contains a magic number: if (schema is string)              {                  TextReader tr = new StringReader((string)schema);                  dt.ReadXmlSchema(tr);              }              else              {                  var ms = (DatasetSchema)this.ParseDictionary((Dictionary<string' object>)schema' globalTypes' typeof(DatasetSchema)' null);                  dt.TableName = ms.Info[0];                  for (int i = 0; i < ms.Info.Count; i += 3)                  {                      dt.Columns.Add(ms.Info[i + 1]' Type.GetType(ms.Info[i + 2]));                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,The following statement contains a magic number: {                  while (index < l)                  {                      var c = p[index++];                        if (c == '"')                      {                          if (runIndex != -1)                          {                              if (s.Length == 0)                                  return json.Substring(runIndex' index - runIndex - 1);                                s.Append(json' runIndex' index - runIndex - 1);                          }                          return s.ToString();                      }                        if (c != '\\')                      {                          if (runIndex == -1)                              runIndex = index - 1;                            continue;                      }                        if (index == l) break;                        if (runIndex != -1)                      {                          s.Append(json' runIndex' index - runIndex - 1);                          runIndex = -1;                      }                        switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseSingleChar,The following statement contains a magic number: if (c1 >= '0' && c1 <= '9')                  p1 = (uint)(c1 - '0') * multipliyer;              else if (c1 >= 'A' && c1 <= 'F')                  p1 = (uint)((c1 - 'A') + 10) * multipliyer;              else if (c1 >= 'a' && c1 <= 'f')                  p1 = (uint)((c1 - 'a') + 10) * multipliyer;
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseSingleChar,The following statement contains a magic number: if (c1 >= '0' && c1 <= '9')                  p1 = (uint)(c1 - '0') * multipliyer;              else if (c1 >= 'A' && c1 <= 'F')                  p1 = (uint)((c1 - 'A') + 10) * multipliyer;              else if (c1 >= 'a' && c1 <= 'f')                  p1 = (uint)((c1 - 'a') + 10) * multipliyer;
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,CreateLong,The following statement contains a magic number: foreach (char cc in s)              {                  if (cc == '-')                      neg = true;                  else if (cc == '+')                      neg = false;                  else                  {                      num *= 10;                      num += (int)(cc - '0');                  }              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following statement contains a magic number: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
Magic Number,fastJSON,JSONSerializer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonSerializer.cs,WriteString,The following statement contains a magic number: for (var index = 0; index < l; ++index)              {                  var c = s[index];                    if (_useEscapedUnicode)                  {                      if (c >= ' ' && c < 128 && c != '\"' && c != '\\')                      {                          if (runIndex == -1)                              runIndex = index;                            continue;                      }                  }                  else                  {                      if (c != '\t' && c != '\n' && c != '\r' && c != '\"' && c != '\\')// && c != ':' && c!=''')                      {                          if (runIndex == -1)                              runIndex = index;                            continue;                      }                  }                    if (runIndex != -1)                  {                      _output.Append(s' runIndex' index - runIndex);                      runIndex = -1;                  }                    switch (c)                  {                      case '\t': _output.Append("\\t"); break;                      case '\r': _output.Append("\\r"); break;                      case '\n': _output.Append("\\n"); break;                      case '"':                      case '\\': _output.Append('\\'); _output.Append(c); break;                      default:                          if (_useEscapedUnicode)                          {                              _output.Append("\\u");                              _output.Append(((int)c).ToString("X4"' NumberFormatInfo.InvariantInfo));                          }                          else                              _output.Append(c);                            break;                  }              }
Magic Number,fastJSON,Reflection,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\Reflection.cs,CreateSetField,The following statement contains a magic number: Type[] arguments = new Type[2];
Magic Number,fastJSON,Reflection,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\Reflection.cs,CreateSetMethod,The following statement contains a magic number: Type[] arguments = new Type[2];
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: Int32 remainingBytes = length & 3;
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: Int32 numberOfLoops = length >> 2;
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: fixed (byte* firstByte = &(data[0]))              {                  UInt32* realData = (UInt32*)firstByte;                  while (numberOfLoops != 0)                  {                      UInt32 k = *realData;                      k *= m;                      k ^= k >> r;                      k *= m;                        h *= m;                      h ^= k;                      numberOfLoops--;                      realData++;                  }                  switch (remainingBytes)                  {                      case 3:                          h ^= (UInt16)(*realData);                          h ^= ((UInt32)(*(((Byte*)(realData)) + 2))) << 16;                          h *= m;                          break;                      case 2:                          h ^= (UInt16)(*realData);                          h *= m;                          break;                      case 1:                          h ^= *((Byte*)realData);                          h *= m;                          break;                      default:                          break;                  }              }
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: h ^= h >> 13;
Magic Number,RaptorDB.Common,MurmurHash2Unsafe,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\MurMurHash2.cs,Hash,The following statement contains a magic number: h ^= h >> 15;
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: byte[] hdr = new byte[5];
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: hdr[0] = (UseBJSON ? (byte)3 : (byte)0);
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: Array.Copy(len' 0' hdr' 1' 4);
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: byte[] rechdr = new byte[5];
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: using (NetworkStream n = new NetworkStream(_client.Client))              {                  n.Read(rechdr' 0' 5);                  int c = Helper.ToInt32(rechdr' 1);                  byte[] recd = new byte[c];                  int bytesRead = 0;                  int chunksize = 1;                  while (bytesRead < c && chunksize > 0)                      bytesRead +=                        chunksize = n.Read                          (recd' bytesRead' c - bytesRead);                  if ((rechdr[0] & (byte)4) == (byte)4)                      recd = MiniLZO.Decompress(recd);                  if ((rechdr[0] & (byte)3) == (byte)3)                      return fastBinaryJSON.BJSON.ToObject(recd);              }
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: using (NetworkStream n = new NetworkStream(_client.Client))              {                  n.Read(rechdr' 0' 5);                  int c = Helper.ToInt32(rechdr' 1);                  byte[] recd = new byte[c];                  int bytesRead = 0;                  int chunksize = 1;                  while (bytesRead < c && chunksize > 0)                      bytesRead +=                        chunksize = n.Read                          (recd' bytesRead' c - bytesRead);                  if ((rechdr[0] & (byte)4) == (byte)4)                      recd = MiniLZO.Decompress(recd);                  if ((rechdr[0] & (byte)3) == (byte)3)                      return fastBinaryJSON.BJSON.ToObject(recd);              }
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: using (NetworkStream n = new NetworkStream(_client.Client))              {                  n.Read(rechdr' 0' 5);                  int c = Helper.ToInt32(rechdr' 1);                  byte[] recd = new byte[c];                  int bytesRead = 0;                  int chunksize = 1;                  while (bytesRead < c && chunksize > 0)                      bytesRead +=                        chunksize = n.Read                          (recd' bytesRead' c - bytesRead);                  if ((rechdr[0] & (byte)4) == (byte)4)                      recd = MiniLZO.Decompress(recd);                  if ((rechdr[0] & (byte)3) == (byte)3)                      return fastBinaryJSON.BJSON.ToObject(recd);              }
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: using (NetworkStream n = new NetworkStream(_client.Client))              {                  n.Read(rechdr' 0' 5);                  int c = Helper.ToInt32(rechdr' 1);                  byte[] recd = new byte[c];                  int bytesRead = 0;                  int chunksize = 1;                  while (bytesRead < c && chunksize > 0)                      bytesRead +=                        chunksize = n.Read                          (recd' bytesRead' c - bytesRead);                  if ((rechdr[0] & (byte)4) == (byte)4)                      recd = MiniLZO.Decompress(recd);                  if ((rechdr[0] & (byte)3) == (byte)3)                      return fastBinaryJSON.BJSON.ToObject(recd);              }
Magic Number,RaptorDB.Common,NetworkClient,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Send,The following statement contains a magic number: using (NetworkStream n = new NetworkStream(_client.Client))              {                  n.Read(rechdr' 0' 5);                  int c = Helper.ToInt32(rechdr' 1);                  byte[] recd = new byte[c];                  int bytesRead = 0;                  int chunksize = 1;                  while (bytesRead < c && chunksize > 0)                      bytesRead +=                        chunksize = n.Read                          (recd' bytesRead' c - bytesRead);                  if ((rechdr[0] & (byte)4) == (byte)4)                      recd = MiniLZO.Decompress(recd);                  if ((rechdr[0] & (byte)3) == (byte)3)                      return fastBinaryJSON.BJSON.ToObject(recd);              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Start,The following statement contains a magic number: ThreadPool.SetMinThreads(50' 50);
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Start,The following statement contains a magic number: ThreadPool.SetMinThreads(50' 50);
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Start,The following statement contains a magic number: System.Timers.Timer t = new System.Timers.Timer(1000);
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,NetworkServer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\NetworkClient.cs,Accept,The following statement contains a magic number: using (NetworkStream n = client.GetStream())              {                  while (client.Connected)                  {                      this.count++;                      byte[] c = new byte[5];                      n.Read(c' 0' 5);                      int count = BitConverter.ToInt32(c' 1);                      byte[] data = new byte[count];                      int bytesRead = 0;                      int chunksize = 1;                      while (bytesRead < count && chunksize > 0)                          bytesRead +=                            chunksize = n.Read                              (data' bytesRead' count - bytesRead);                        object o = fastBinaryJSON.BJSON.ToObject(data);                        object r = _handler(o);                      bool compressed = false;                      data = fastBinaryJSON.BJSON.ToBJSON(r);                      if (data.Length > NetworkClient.Config.CompressDataOver)                      {                          log.Debug("compressing data over limit : " + data.Length.ToString("#'#"));                          compressed = true;                          data = MiniLZO.Compress(data);                          log.Debug("new size : " + data.Length.ToString("#'#"));                      }                      if (data.Length > NetworkClient.Config.LogDataSizesOver)                          log.Debug("data size (bytes) = " + data.Length.ToString("#'#"));                        byte[] b = BitConverter.GetBytes(data.Length);                      byte[] hdr = new byte[5];                      hdr[0] = (byte)(3 + (compressed ? 4 : 0));                      Array.Copy(b' 0' hdr' 1' 4);                      n.Write(hdr' 0' 5);                      n.Write(data' 0' data.Length);                        int wait = 0;                      while (n.DataAvailable == false)                      {                          wait++;                          if (wait < 10000) // kludge : for insert performance                              Thread.Sleep(0);                          else                              Thread.Sleep(1);                          // FEATURE : if wait > 10 min -> close connection                       }                  }              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt32,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[4];                  Buffer.BlockCopy(value' startIndex' b' 0' 4);                  Array.Reverse(b);                  return ToInt32(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt32,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[4];                  Buffer.BlockCopy(value' startIndex' b' 0' 4);                  Array.Reverse(b);                  return ToInt32(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt64,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[8];                  Buffer.BlockCopy(value' startIndex' b' 0' 8);                  Array.Reverse(b);                  return ToInt64(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt64,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[8];                  Buffer.BlockCopy(value' startIndex' b' 0' 8);                  Array.Reverse(b);                  return ToInt64(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt16,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[2];                  Buffer.BlockCopy(value' startIndex' b' 0' 2);                  Array.Reverse(b);                  return ToInt16(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,ToInt16,The following statement contains a magic number: if (reverse)              {                  byte[] b = new byte[2];                  Buffer.BlockCopy(value' startIndex' b' 0' 2);                  Array.Reverse(b);                  return ToInt16(b' 0);              }
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[8];
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,RaptorDB.Common,Helper,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\SafeDictionary.cs,GetBytes,The following statement contains a magic number: byte[] buffer = new byte[2];
Magic Number,RaptorDB.Common,ZIP,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Main,The following statement contains a magic number: if (args[1].StartsWith("/") || args[1].StartsWith("-"))              {                  r = true;                  fn = args[2];                  dir = args[3];              }              else              {                  fn = args[1];                  dir = args[2];              }
Magic Number,RaptorDB.Common,ZIP,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Main,The following statement contains a magic number: if (args[1].StartsWith("/") || args[1].StartsWith("-"))              {                  r = true;                  fn = args[2];                  dir = args[3];              }              else              {                  fn = args[1];                  dir = args[2];              }
Magic Number,RaptorDB.Common,ZIP,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Main,The following statement contains a magic number: if (args[1].StartsWith("/") || args[1].StartsWith("-"))              {                  r = true;                  fn = args[2];                  dir = args[3];              }              else              {                  fn = args[1];                  dir = args[2];              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ZipStorer,The following statement contains a magic number: CrcTable = new UInt32[256];
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ZipStorer,The following statement contains a magic number: for (int i = 0; i < CrcTable.Length; i++)              {                  UInt32 c = (UInt32)i;                  for (int j = 0; j < 8; j++)                  {                      if ((c & 1) != 0)                          c = 3988292384 ^ (c >> 1);                      else                          c >>= 1;                  }                  CrcTable[i] = c;              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ZipStorer,The following statement contains a magic number: for (int i = 0; i < CrcTable.Length; i++)              {                  UInt32 c = (UInt32)i;                  for (int j = 0; j < 8; j++)                  {                      if ((c & 1) != 0)                          c = 3988292384 ^ (c >> 1);                      else                          c >>= 1;                  }                  CrcTable[i] = c;              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadCentralDir,The following statement contains a magic number: for (int pointer = 0; pointer < this.CentralDirImage.Length;)              {                  uint signature = BitConverter.ToUInt32(CentralDirImage' pointer);                  if (signature != 0x02014b50)                      break;                    bool encodeUTF8 = (BitConverter.ToUInt16(CentralDirImage' pointer + 8) & 0x0800) != 0;                  ushort method = BitConverter.ToUInt16(CentralDirImage' pointer + 10);                  uint modifyTime = BitConverter.ToUInt32(CentralDirImage' pointer + 12);                  uint crc32 = BitConverter.ToUInt32(CentralDirImage' pointer + 16);                  uint comprSize = BitConverter.ToUInt32(CentralDirImage' pointer + 20);                  uint fileSize = BitConverter.ToUInt32(CentralDirImage' pointer + 24);                  ushort filenameSize = BitConverter.ToUInt16(CentralDirImage' pointer + 28);                  ushort extraSize = BitConverter.ToUInt16(CentralDirImage' pointer + 30);                  ushort commentSize = BitConverter.ToUInt16(CentralDirImage' pointer + 32);                  uint headerOffset = BitConverter.ToUInt32(CentralDirImage' pointer + 42);                  uint headerSize = (uint)(46 + filenameSize + extraSize + commentSize);                    Encoding encoder = encodeUTF8 ? Encoding.UTF8 : DefaultEncoding;                    ZipFileEntry zfe = new ZipFileEntry();                  zfe.Method = (Compression)method;                  zfe.FilenameInZip = encoder.GetString(CentralDirImage' pointer + 46' filenameSize);                  zfe.FileOffset = GetFileOffset(headerOffset);                  zfe.FileSize = fileSize;                  zfe.CompressedSize = comprSize;                  zfe.HeaderOffset = headerOffset;                  zfe.HeaderSize = headerSize;                  zfe.Crc32 = crc32;                  zfe.ModifyTime = DosTimeToDateTime(modifyTime);                  if (commentSize > 0)                      zfe.Comment = encoder.GetString(CentralDirImage' pointer + 46 + filenameSize + extraSize' commentSize);                    result.Add(zfe);                  pointer += (46 + filenameSize + extraSize + commentSize);              }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ExtractFile,The following statement contains a magic number: byte[] signature = new byte[4];
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ExtractFile,The following statement contains a magic number: this.ZipFileStream.Read(signature' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ExtractFile,The following statement contains a magic number: byte[] buffer = new byte[16384];
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,GetFileOffset,The following statement contains a magic number: byte[] buffer = new byte[2];
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,GetFileOffset,The following statement contains a magic number: this.ZipFileStream.Seek(_headerOffset + 26' SeekOrigin.Begin);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,GetFileOffset,The following statement contains a magic number: this.ZipFileStream.Read(buffer' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,GetFileOffset,The following statement contains a magic number: this.ZipFileStream.Read(buffer' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,GetFileOffset,The following statement contains a magic number: return (uint)(30 + filenameSize + extraSize + _headerOffset);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 3' 4' 20' 0 }' 0' 6);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0))' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(DateTimeToDosTime(_zfe.ModifyTime))' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0 }' 0' 12);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedFilename.Length)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteLocalHeader,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 1' 2' 23' 0xB' 20' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0))' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(DateTimeToDosTime(_zfe.ModifyTime))' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.Crc32)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.CompressedSize)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.FileSize)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedFilename.Length)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedComment.Length)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)0x8100)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteCentralDirRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.HeaderOffset)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 5' 6' 0' 0' 0' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 5' 6' 0' 0' 0' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 5' 6' 0' 0' 0' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 5' 6' 0' 0' 0' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(new byte[] { 80' 75' 5' 6' 0' 0' 0' 0 }' 0' 8);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)Files.Count + ExistingFiles)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)Files.Count + ExistingFiles)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_size)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_offset)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,WriteEndRecord,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedComment.Length)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Store,The following statement contains a magic number: byte[] buffer = new byte[16384];
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,Store,The following statement contains a magic number: do              {                  bytesRead = _source.Read(buffer' 0' buffer.Length);                  totalRead += (uint)bytesRead;                  if (bytesRead > 0)                  {                      outStream.Write(buffer' 0' bytesRead);                        for (uint i = 0; i < bytesRead; i++)                      {                          _zfe.Crc32 = ZipStorer.CrcTable[(_zfe.Crc32 ^ buffer[i]) & 0xFF] ^ (_zfe.Crc32 >> 8);                      }                  }              } while (bytesRead == buffer.Length);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DateTimeToDosTime,The following statement contains a magic number: return (uint)(                  (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |                  (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,DosTimeToDateTime,The following statement contains a magic number: return new DateTime(                  (int)(_dt >> 25) + 1980'                  (int)(_dt >> 21) & 15'                  (int)(_dt >> 16) & 31'                  (int)(_dt >> 11) & 31'                  (int)(_dt >> 5) & 63'                  (int)(_dt & 31) * 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Position = _zfe.HeaderOffset + 8;
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method)' 0' 2);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Position = _zfe.HeaderOffset + 14;
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.Crc32)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.CompressedSize)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,UpdateCrcAndSizes,The following statement contains a magic number: this.ZipFileStream.Write(BitConverter.GetBytes(_zfe.FileSize)' 0' 4);
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadFileInfo,The following statement contains a magic number: if (this.ZipFileStream.Length < 22)                  return false;
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadFileInfo,The following statement contains a magic number: try              {                  this.ZipFileStream.Seek(-17' SeekOrigin.End);                  BinaryReader br = new BinaryReader(this.ZipFileStream);                  do                  {                      this.ZipFileStream.Seek(-5' SeekOrigin.Current);                      UInt32 sig = br.ReadUInt32();                      if (sig == 0x06054b50)                      {                          this.ZipFileStream.Seek(6' SeekOrigin.Current);                            UInt16 entries = br.ReadUInt16();                          Int32 centralSize = br.ReadInt32();                          UInt32 centralDirOffset = br.ReadUInt32();                          UInt16 commentSize = br.ReadUInt16();                            // check if comment field is the very last data in file                          if (this.ZipFileStream.Position + commentSize != this.ZipFileStream.Length)                              return false;                            // Copy entire central directory to a memory buffer                          this.ExistingFiles = entries;                          this.CentralDirImage = new byte[centralSize];                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          this.ZipFileStream.Read(this.CentralDirImage' 0' centralSize);                            // Leave the pointer at the begining of central dir' to append new files                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          return true;                      }                  } while (this.ZipFileStream.Position > 0);              }              catch { }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadFileInfo,The following statement contains a magic number: try              {                  this.ZipFileStream.Seek(-17' SeekOrigin.End);                  BinaryReader br = new BinaryReader(this.ZipFileStream);                  do                  {                      this.ZipFileStream.Seek(-5' SeekOrigin.Current);                      UInt32 sig = br.ReadUInt32();                      if (sig == 0x06054b50)                      {                          this.ZipFileStream.Seek(6' SeekOrigin.Current);                            UInt16 entries = br.ReadUInt16();                          Int32 centralSize = br.ReadInt32();                          UInt32 centralDirOffset = br.ReadUInt32();                          UInt16 commentSize = br.ReadUInt16();                            // check if comment field is the very last data in file                          if (this.ZipFileStream.Position + commentSize != this.ZipFileStream.Length)                              return false;                            // Copy entire central directory to a memory buffer                          this.ExistingFiles = entries;                          this.CentralDirImage = new byte[centralSize];                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          this.ZipFileStream.Read(this.CentralDirImage' 0' centralSize);                            // Leave the pointer at the begining of central dir' to append new files                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          return true;                      }                  } while (this.ZipFileStream.Position > 0);              }              catch { }
Magic Number,RaptorDB.Common,ZipStorer,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\ZipStorer.cs,ReadFileInfo,The following statement contains a magic number: try              {                  this.ZipFileStream.Seek(-17' SeekOrigin.End);                  BinaryReader br = new BinaryReader(this.ZipFileStream);                  do                  {                      this.ZipFileStream.Seek(-5' SeekOrigin.Current);                      UInt32 sig = br.ReadUInt32();                      if (sig == 0x06054b50)                      {                          this.ZipFileStream.Seek(6' SeekOrigin.Current);                            UInt16 entries = br.ReadUInt16();                          Int32 centralSize = br.ReadInt32();                          UInt32 centralDirOffset = br.ReadUInt32();                          UInt16 commentSize = br.ReadUInt16();                            // check if comment field is the very last data in file                          if (this.ZipFileStream.Position + commentSize != this.ZipFileStream.Length)                              return false;                            // Copy entire central directory to a memory buffer                          this.ExistingFiles = entries;                          this.CentralDirImage = new byte[centralSize];                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          this.ZipFileStream.Read(this.CentralDirImage' 0' centralSize);                            // Leave the pointer at the begining of central dir' to append new files                          this.ZipFileStream.Seek(centralDirOffset' SeekOrigin.Begin);                          return true;                      }                  } while (this.ZipFileStream.Position > 0);              }              catch { }
Missing Default,RaptorDB,LINQString,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\LINQString.cs,VisitBinary,The following switch statement is missing a default case: switch (b.NodeType)              {                  case ExpressionType.AndAlso:                  case ExpressionType.And:                      sb.Append(" AND ");                      break;                  case ExpressionType.OrElse:                  case ExpressionType.Or:                      sb.Append(" OR ");                      break;                  case ExpressionType.Equal:                      sb.Append(" = ");                      break;                  case ExpressionType.NotEqual:                      sb.Append(" != ");                      break;                  case ExpressionType.LessThan:                      sb.Append(" < ");                      break;                  case ExpressionType.LessThanOrEqual:                      sb.Append(" <= ");                      break;                  case ExpressionType.GreaterThan:                      sb.Append(" > ");                      break;                  case ExpressionType.GreaterThanOrEqual:                      sb.Append(" >= ");                      break;              }
Missing Default,fastBinaryJSON,BJsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastBinaryJSON\BJsonParser.cs,ParseValue,The following switch statement is missing a default case: switch (t)              {                  case TOKENS.BYTE:                      return ParseByte();                  case TOKENS.BYTEARRAY:                      return ParseByteArray();                  case TOKENS.CHAR:                      return ParseChar();                  case TOKENS.DATETIME:                      return ParseDateTime();                  case TOKENS.DECIMAL:                      return ParseDecimal();                  case TOKENS.DOUBLE:                      return ParseDouble();                  case TOKENS.FLOAT:                      return ParseFloat();                  case TOKENS.GUID:                      return ParseGuid();                  case TOKENS.INT:                      return ParseInt();                  case TOKENS.LONG:                      return ParseLong();                  case TOKENS.SHORT:                      return ParseShort();                  case TOKENS.UINT:                      return ParseUint();                  case TOKENS.ULONG:                      return ParseULong();                  case TOKENS.USHORT:                      return ParseUShort();                  case TOKENS.UNICODE_STRING:                      return ParseUnicodeString();                  case TOKENS.STRING:                      return ParseString();                  case TOKENS.DOC_START:                      return ParseObject();                  case TOKENS.ARRAY_START:                      return ParseArray();                  case TOKENS.TRUE:                      return true;                  case TOKENS.FALSE:                      return false;                  case TOKENS.NULL:                      return null;                  case TOKENS.ARRAY_END:                      breakparse = true;                      return TOKENS.ARRAY_END;                  case TOKENS.DOC_END:                      breakparse = true;                      return TOKENS.DOC_END;                  case TOKENS.COMMA:                      breakparse = true;                      return TOKENS.COMMA;                  case TOKENS.ARRAY_TYPED:                      return ParseTypedArray();              }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead())              {                  case Token.Number:                      return ParseNumber();                    case Token.String:                      return ParseString();                    case Token.Curly_Open:                      return ParseObject();                    case Token.Squared_Open:                      return ParseArray();                    case Token.True:                      ConsumeToken();                      return true;                    case Token.False:                      ConsumeToken();                      return false;                    case Token.Null:                      ConsumeToken();                      return null;              }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,ParseString,The following switch statement is missing a default case: switch (p[index++])                      {                          case '"':                              s.Append('"');                              break;                            case '\\':                              s.Append('\\');                              break;                            case '/':                              s.Append('/');                              break;                            case 'b':                              s.Append('\b');                              break;                            case 'f':                              s.Append('\f');                              break;                            case 'n':                              s.Append('\n');                              break;                            case 'r':                              s.Append('\r');                              break;                            case 't':                              s.Append('\t');                              break;                            case 'u':                              {                                  int remainingLength = l - index;                                  if (remainingLength < 4) break;                                    // parse the 32 bit hex into an integer codepoint                                  uint codePoint = ParseUnicode(p[index]' p[index + 1]' p[index + 2]' p[index + 3]);                                  s.Append((char)codePoint);                                    // skip 4 chars                                  index += 4;                              }                              break;                      }
Missing Default,fastJSON,JsonParser,C:\repos\mgholam_RaptorDB-Document\RaptorDB.Common\fastJSON\JsonParser.cs,NextTokenCore,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return Token.Curly_Open;                    case '}':                      return Token.Curly_Close;                    case '[':                      return Token.Squared_Open;                    case ']':                      return Token.Squared_Close;                    case ''':                      return Token.Comma;                    case '"':                      return Token.String;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                  case '+':                  case '.':                      return Token.Number;                    case ':':                      return Token.Colon;                    case 'f':                      if (json.Length - index >= 4 &&                          json[index + 0] == 'a' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 's' &&                          json[index + 3] == 'e')                      {                          index += 4;                          return Token.False;                      }                      break;                    case 't':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'r' &&                          json[index + 1] == 'u' &&                          json[index + 2] == 'e')                      {                          index += 3;                          return Token.True;                      }                      break;                    case 'n':                      if (json.Length - index >= 3 &&                          json[index + 0] == 'u' &&                          json[index + 1] == 'l' &&                          json[index + 2] == 'l')                      {                          index += 3;                          return Token.Null;                      }                      break;              }
