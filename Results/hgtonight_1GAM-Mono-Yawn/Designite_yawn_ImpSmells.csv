Implementation smell,Namespace,Class,File,Method,Description
Complex Method,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Board,Cyclomatic complexity of the method is 12
Complex Method,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Direction,Cyclomatic complexity of the method is 12
Complex Method,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,Cyclomatic complexity of the method is 23
Complex Method,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,Cyclomatic complexity of the method is 14
Complex Method,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,FindExtraRotation,Cyclomatic complexity of the method is 10
Long Statement,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The length of the statement  "		spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9)); " is 134.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The length of the statement  "	LogoPosition = new Vector2 ((BoardWidth * GridSize / 2) - (DaklutzLogo.Width / 2)' (BoardHeight * GridSize / 2) - (DaklutzLogo.Height / 2)); " is 140.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The length of the statement  "		if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) { " is 125.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The length of the statement  "		if (Keyboard.GetState ().IsKeyDown (Keys.Up) || Keyboard.GetState ().IsKeyDown (Keys.Down) || Keyboard.GetState ().IsKeyDown (Keys.Left) || Keyboard.GetState ().IsKeyDown (Keys.Right)) { " is 186.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The length of the statement  "		if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) { " is 125.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The length of the statement  "		spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f); " is 125.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The length of the statement  "		spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f); " is 129.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The length of the statement  "		spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f); " is 125.
Long Statement,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The length of the statement  "		spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f); " is 128.
Long Statement,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The length of the statement  "	spriteBatch.Draw (Tile' new Vector2 (HeadPosition.X * GridSize + GridSize / 2' HeadPosition.Y * GridSize + GridSize / 2)' Head' Color.Pink' CameFrom.Opposite ().RotationAngle ()' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipHead' 0.0f); " is 243.
Long Statement,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The length of the statement  "				if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) { " is 127.
Long Statement,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The length of the statement  "		spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f); " is 240.
Long Statement,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The length of the statement  "		//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black); " is 146.
Complex Conditional,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateStandardLevel,The conditional expression  "i == 0 || i == Width - 1 || j == 0 || j == Height - 1"  is complex.
Complex Conditional,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,OutOfBounds,The conditional expression  "vector2.X < 0 || vector2.X > Width || vector2.Y < 0 || vector2.Y > Height"  is complex.
Complex Conditional,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The conditional expression  "Keyboard.GetState ().IsKeyDown (Keys.Up) || Keyboard.GetState ().IsKeyDown (Keys.Down) || Keyboard.GetState ().IsKeyDown (Keys.Left) || Keyboard.GetState ().IsKeyDown (Keys.Right)"  is complex.
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Board,The following statement contains a magic number: switch (random) {  case 0:  	GenerateStandardLevel ();  	break;  case -1:  	GenerateBlockyLevel ();  	break;  case -2:  	GenerateWrappedLevel ();  	break;  default:  	GenerateRandomLevel (random);  	break;  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateWrappedLevel,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	j++;  	if (j % 2 == 1 || i == Width - 1) {  		BlockPositions.Add (new Vector2 (i' 0));  		BlockPositions.Add (new Vector2 (i' Height - 1));  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateWrappedLevel,The following statement contains a magic number: if (j % 2 == 1 || i == Width - 1) {  	BlockPositions.Add (new Vector2 (i' 0));  	BlockPositions.Add (new Vector2 (i' Height - 1));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateWrappedLevel,The following statement contains a magic number: for (int i = 0; i < Height; i++) {  	j++;  	if (j % 2 == 1 || j == Height - 1) {  		BlockPositions.Add (new Vector2 (0' i));  		BlockPositions.Add (new Vector2 (Width - 1' i));  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateWrappedLevel,The following statement contains a magic number: if (j % 2 == 1 || j == Height - 1) {  	BlockPositions.Add (new Vector2 (0' i));  	BlockPositions.Add (new Vector2 (Width - 1' i));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	for (int j = 0; j < Height; j++) {  		if (i % 2 == 1 && j % 2 == 1) {  			BlockPositions.Add (new Vector2 (i' j));  		}  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	for (int j = 0; j < Height; j++) {  		if (i % 2 == 1 && j % 2 == 1) {  			BlockPositions.Add (new Vector2 (i' j));  		}  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	if (i % 2 == 1 && j % 2 == 1) {  		BlockPositions.Add (new Vector2 (i' j));  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	if (i % 2 == 1 && j % 2 == 1) {  		BlockPositions.Add (new Vector2 (i' j));  	}  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: if (i % 2 == 1 && j % 2 == 1) {  	BlockPositions.Add (new Vector2 (i' j));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,GenerateBlockyLevel,The following statement contains a magic number: if (i % 2 == 1 && j % 2 == 1) {  	BlockPositions.Add (new Vector2 (i' j));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: for (int i = BlockPositions.Count - 1; i >= 0; i--) {  	spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: for (int i = BlockPositions.Count - 1; i >= 0; i--) {  	spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: for (int i = BlockPositions.Count - 1; i >= 0; i--) {  	spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  }  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  
Magic Number,yawn,Board,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Board.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (BlockPositions [i].X * GridSize' BlockPositions [i].Y * GridSize)' Block' new Color (68' 34' 9));  
Magic Number,yawn,Food,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Food.cs,Food,The following statement contains a magic number: Banana = new Rectangle (2 * gridsize' 1 * gridsize' gridsize' gridsize);  
Magic Number,yawn,Food,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Food.cs,Food,The following statement contains a magic number: Cherry = new Rectangle (3 * gridsize' 1 * gridsize' gridsize' gridsize);  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Direction,The following statement contains a magic number: ordinal = NormDeg / 90;  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Direction,The following statement contains a magic number: switch (ordinal) {  case 0:  	name = "North";  	break;  case 1:  	name = "East";  	break;  case 2:  	name = "South";  	break;  case 3:  	name = "West";  	break;  }  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Direction,The following statement contains a magic number: switch (ordinal) {  case 0:  	name = "North";  	break;  case 1:  	name = "East";  	break;  case 2:  	name = "South";  	break;  case 3:  	name = "West";  	break;  }  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Next,The following statement contains a magic number: return new Direction (degrees + 90);  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Opposite,The following statement contains a magic number: return new Direction (degrees + 180);  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Move,The following statement contains a magic number: switch (ordinal) {  default:  case 0:  	return new Vector2 (Position.X' Position.Y - 1);  case 1:  	return new Vector2 (Position.X + 1' Position.Y);  case 2:  	return new Vector2 (Position.X' Position.Y + 1);  case 3:  	return new Vector2 (Position.X - 1' Position.Y);  }  
Magic Number,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Move,The following statement contains a magic number: switch (ordinal) {  default:  case 0:  	return new Vector2 (Position.X' Position.Y - 1);  case 1:  	return new Vector2 (Position.X + 1' Position.Y);  case 2:  	return new Vector2 (Position.X' Position.Y + 1);  case 3:  	return new Vector2 (Position.X - 1' Position.Y);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,ResetGame,The following statement contains a magic number: BgColor = new Color (68' 34' 9);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,ResetGame,The following statement contains a magic number: BgColor = new Color (68' 34' 9);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,ResetGame,The following statement contains a magic number: BgColor = new Color (68' 34' 9);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The following statement contains a magic number: LogoPosition = new Vector2 ((BoardWidth * GridSize / 2) - (DaklutzLogo.Width / 2)' (BoardHeight * GridSize / 2) - (DaklutzLogo.Height / 2));  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The following statement contains a magic number: LogoPosition = new Vector2 ((BoardWidth * GridSize / 2) - (DaklutzLogo.Width / 2)' (BoardHeight * GridSize / 2) - (DaklutzLogo.Height / 2));  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The following statement contains a magic number: LogoPosition = new Vector2 ((BoardWidth * GridSize / 2) - (DaklutzLogo.Width / 2)' (BoardHeight * GridSize / 2) - (DaklutzLogo.Height / 2));  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The following statement contains a magic number: LogoPosition = new Vector2 ((BoardWidth * GridSize / 2) - (DaklutzLogo.Width / 2)' (BoardHeight * GridSize / 2) - (DaklutzLogo.Height / 2));  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,LoadContent,The following statement contains a magic number: TextPosition = new Vector2 (BoardWidth * GridSize / 2' LogoPosition.Y + DaklutzLogo.Height);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Paused) {  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up) || Keyboard.GetState ().IsKeyDown (Keys.Down) || Keyboard.GetState ().IsKeyDown (Keys.Left) || Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Paused = false;  	}  }  else if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Paused) {  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up) || Keyboard.GetState ().IsKeyDown (Keys.Down) || Keyboard.GetState ().IsKeyDown (Keys.Left) || Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Paused = false;  	}  }  else if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Paused) {  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up) || Keyboard.GetState ().IsKeyDown (Keys.Down) || Keyboard.GetState ().IsKeyDown (Keys.Left) || Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Paused = false;  	}  }  else if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (GameOver == false) {  	// Update that worm  	List<Direction> Dirs = new List<Direction> ();  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		Dirs.Add (Direction.NORTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		Dirs.Add (Direction.SOUTH);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		Dirs.Add (Direction.WEST);  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		Dirs.Add (Direction.EAST);  	}  	// Only update as fast as the game is going  	if (Ticks % GameSpeed == 0) {  		Ticks = 0;  		if (Worm.Update (gameTime' Dirs) == false) {  			GameOver = true;  		}  	}  	// Check for wrapping around the edge of the board  	if (Board.OutOfBounds (Worm.Position)) {  		Worm.WrapPosition (BoardWidth' BoardHeight);  	}  	// check for collision with the walls  	if (Board.Collides (Worm.Position)) {  		GameOver = true;  		Impact.Play ();  	}  	// Respawn food if needed  	if (Food.IsEaten ()) {  		Vector2 NewPosition = new Vector2 (-1' -1);  		Random random = new Random ();  		do {  			NewPosition.X = random.Next (0' BoardWidth);  			NewPosition.Y = random.Next (0' BoardHeight);  		}  		while (Worm.Collides (NewPosition) || Board.Collides (NewPosition));  		Food.Respawn (NewPosition);  	}  	// Check for collision with food  	if (Food.Collides (Worm.Position)) {  		Worm.Eat (Food.Potency ());  		Points++;  		// speed up the game  		if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  			GameSpeed--;  		}  		Food.Devoured ();  		Eat.Play ();  	}  }  else {  	// Game over  	if (GamePad.GetState (PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState ().IsKeyDown (Keys.Escape)) {  		Exit ();  	}  	if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  		ResetGame (0);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  		ResetGame (-1);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  		ResetGame (-2);  	}  	else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  		ResetGame (50);  	}  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Food.Collides (Worm.Position)) {  	Worm.Eat (Food.Potency ());  	Points++;  	// speed up the game  	if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  		GameSpeed--;  	}  	Food.Devoured ();  	Eat.Play ();  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (GameSpeed > 1 && Food.Potency () % 4 == 0) {  	GameSpeed--;  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  	ResetGame (0);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  	ResetGame (-1);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Up)) {  	ResetGame (0);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  	ResetGame (-1);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  	ResetGame (-1);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Down)) {  	ResetGame (-1);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Left)) {  	ResetGame (-2);  }  else if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: ResetGame (-2);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: if (Keyboard.GetState ().IsKeyDown (Keys.Right)) {  	ResetGame (50);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Update,The following statement contains a magic number: ResetGame (50);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (Paused == false && GameOver == false) {  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - PointOffset' Color.Black * 0.25f);  	Board.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Worm.Draw (gameTime' spriteBatch' SpriteSheet' Font);  	Food.Draw (gameTime' spriteBatch' SpriteSheet' Font);  }  else if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: if (GameOver == true) {  	Vector2 GameOverOffset = new Vector2 (Font.MeasureString ("GAME OVER").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "GAME OVER"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  	spriteBatch.DrawString (Font' "FINAL SCORE"' TextPosition - GameOverOffset' Color.White);  	GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  	spriteBatch.DrawString (Font' Points.ToString ()' TextPosition - GameOverOffset' Color.White);  }  else {  	// Default to paused screen  	Vector2 PausedOffset = new Vector2 (Font.MeasureString ("PAUSED").Length () / 2' 0);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' 0' BoardWidth * GridSize' BoardHeight * GridSize)' Color.DarkBlue * 0.25f);  	spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  	spriteBatch.DrawString (Font' "PAUSED"' TextPosition - PausedOffset' Color.White);  }  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 100)' Color.DarkBlue * 0.25f);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: GameOverOffset = new Vector2 (Font.MeasureString ("FINAL SCORE").Length () / 2' -25);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: GameOverOffset = new Vector2 (Font.MeasureString (Points.ToString ()).Length () / 2' -50);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  
Magic Number,yawn,Yawn,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Yawn.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (ColorTexture' new Rectangle (0' (int)TextPosition.Y - 25' BoardWidth * GridSize' 75)' Color.DarkBlue * 0.25f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: HeadPosition = new Vector2 (6' 6);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: HeadPosition = new Vector2 (6' 6);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: Length = 4;  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: Tail = new Rectangle (2 * GridSize' 0 * GridSize' GridSize' GridSize);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: Head = new Rectangle (3 * GridSize' 0 * GridSize' GridSize' GridSize);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: MainColor = new Color (110' 48' 45);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: MainColor = new Color (110' 48' 45);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Worm,The following statement contains a magic number: MainColor = new Color (110' 48' 45);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (CameFrom.Degrees () == 90) {  	FlipHead = SpriteEffects.FlipVertically;  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (HeadPosition.X * GridSize + GridSize / 2' HeadPosition.Y * GridSize + GridSize / 2)' Head' Color.Pink' CameFrom.Opposite ().RotationAngle ()' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipHead' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (HeadPosition.X * GridSize + GridSize / 2' HeadPosition.Y * GridSize + GridSize / 2)' Head' Color.Pink' CameFrom.Opposite ().RotationAngle ()' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipHead' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (HeadPosition.X * GridSize + GridSize / 2' HeadPosition.Y * GridSize + GridSize / 2)' Head' Color.Pink' CameFrom.Opposite ().RotationAngle ()' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipHead' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (HeadPosition.X * GridSize + GridSize / 2' HeadPosition.Y * GridSize + GridSize / 2)' Head' Color.Pink' CameFrom.Opposite ().RotationAngle ()' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipHead' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: for (int i = SectionPositions.Count - 1; i >= 0; i--) {  	// Assume we don't need to flip the tile  	FlipSection = SpriteEffects.None;  	// Find the rotation by looking at the previous direction  	Rotation = PrevDir.RotationAngle ();  	if (i == 0) {  		// if there is no previous position' print the end section  		TileSection = Tail;  	}  	else {  		if (i < SectionPositions.Count - 1) {  			if ((SectionPositions [i - 1].X == SectionPositions [i + 1].X) || (SectionPositions [i - 1].Y == SectionPositions [i + 1].Y)) {  				// if the previous position and the next position share an axis print a midsection  				TileSection = Mid1;  			}  			else {  				// If the previous position and the next position are kitty corner' print a corner  				TileSection = Corner;  				// Determine if the tile needs to be flipped  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' SectionPositions [i + 1]);  			}  		}  		else {  			// Check the head position against the last section position  			if (SectionPositions [i - 1].X == HeadPosition.X || SectionPositions [i - 1].Y == HeadPosition.Y) {  				TileSection = Mid1;  			}  			else {  				TileSection = Corner;  				Rotation += FindExtraRotation (SectionPositions [i - 1]' SectionPositions [i]' HeadPosition);  			}  		}  	}  	// If we are printing a mid section' change it for variation  	if (TileSection.Equals (Mid1)) {  		// Figure out which section we want to use  		if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  			TileSection = Mid2;  		}  		// Figure out if we want to flip the section  		if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  			FlipSection = SpriteEffects.FlipHorizontally;  		}  	}  	// Actually print the section with the proper rotation  	spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  	//spriteBatch.DrawString(Font' (i % 10).ToString()' new Vector2(SectionPositions[i].X * GridSize' SectionPositions[i].Y * GridSize)' Color.Black);  	// Save the current direction for next sections rotation calculation  	if (SectionPositions.Count > 1 && i > 0) {  		if (SectionPositions [i].X < SectionPositions [i - 1].X) {  			PrevDir = Direction.WEST;  		}  		else if (SectionPositions [i].X > SectionPositions [i - 1].X) {  			PrevDir = Direction.EAST;  		}  		else if (SectionPositions [i].Y < SectionPositions [i - 1].Y) {  			PrevDir = Direction.NORTH;  		}  		else {  			PrevDir = Direction.SOUTH;  		}  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (TileSection.Equals (Mid1)) {  	// Figure out which section we want to use  	if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  		TileSection = Mid2;  	}  	// Figure out if we want to flip the section  	if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  		FlipSection = SpriteEffects.FlipHorizontally;  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (TileSection.Equals (Mid1)) {  	// Figure out which section we want to use  	if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  		TileSection = Mid2;  	}  	// Figure out if we want to flip the section  	if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  		FlipSection = SpriteEffects.FlipHorizontally;  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (TileSection.Equals (Mid1)) {  	// Figure out which section we want to use  	if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  		TileSection = Mid2;  	}  	// Figure out if we want to flip the section  	if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  		FlipSection = SpriteEffects.FlipHorizontally;  	}  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if ((SectionPositions [i].X + SectionPositions [i].Y) % 2 > 0) {  	TileSection = Mid2;  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  	FlipSection = SpriteEffects.FlipHorizontally;  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: if (SectionPositions [i].X % 2 > 0 || SectionPositions [i].Y % 2 > 0) {  	FlipSection = SpriteEffects.FlipHorizontally;  }  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  
Magic Number,yawn,Worm,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Worm.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (Tile' new Vector2 (SectionPositions [i].X * GridSize + GridSize / 2' SectionPositions [i].Y * GridSize + GridSize / 2)' TileSection' Color.Pink' Rotation' new Vector2 (GridSize / 2' GridSize / 2)' 1.0f' FlipSection' 0.0f);  
Missing Default,yawn,Direction,C:\repos\hgtonight_1GAM-Mono-Yawn\yawn\yawn\Direction.cs,Direction,The following switch statement is missing a default case: switch (ordinal) {  case 0:  	name = "North";  	break;  case 1:  	name = "East";  	break;  case 2:  	name = "South";  	break;  case 3:  	name = "West";  	break;  }  
